// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: github.com/heroiclabs/nakama/apigrpc/apigrpc.proto
// Original file comments:
// Copyright 2018 The Nakama Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// *
// The Nakama server RPC protocol for games and apps.
#ifndef GRPC_github_2ecom_2fheroiclabs_2fnakama_2fapigrpc_2fapigrpc_2eproto__INCLUDED
#define GRPC_github_2ecom_2fheroiclabs_2fnakama_2fapigrpc_2fapigrpc_2eproto__INCLUDED

#include "github.com/heroiclabs/nakama/apigrpc/apigrpc.pb.h"

#include <functional>
#include <grpc/impl/codegen/port_platform.h>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace nakama {
namespace api {

// *
// The Nakama RPC protocol service built with GRPC.
class Nakama final {
 public:
  static constexpr char const* service_full_name() {
    return "nakama.api.Nakama";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Add friends by ID or username to a user's account.
    virtual ::grpc::Status AddFriends(::grpc::ClientContext* context, const ::nakama::api::AddFriendsRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncAddFriends(::grpc::ClientContext* context, const ::nakama::api::AddFriendsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncAddFriendsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncAddFriends(::grpc::ClientContext* context, const ::nakama::api::AddFriendsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncAddFriendsRaw(context, request, cq));
    }
    // Add users to a group.
    virtual ::grpc::Status AddGroupUsers(::grpc::ClientContext* context, const ::nakama::api::AddGroupUsersRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncAddGroupUsers(::grpc::ClientContext* context, const ::nakama::api::AddGroupUsersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncAddGroupUsersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncAddGroupUsers(::grpc::ClientContext* context, const ::nakama::api::AddGroupUsersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncAddGroupUsersRaw(context, request, cq));
    }
    // Refresh a user's session using a refresh token retrieved from a previous authentication request.
    virtual ::grpc::Status SessionRefresh(::grpc::ClientContext* context, const ::nakama::api::SessionRefreshRequest& request, ::nakama::api::Session* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Session>> AsyncSessionRefresh(::grpc::ClientContext* context, const ::nakama::api::SessionRefreshRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Session>>(AsyncSessionRefreshRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Session>> PrepareAsyncSessionRefresh(::grpc::ClientContext* context, const ::nakama::api::SessionRefreshRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Session>>(PrepareAsyncSessionRefreshRaw(context, request, cq));
    }
    // Log out a session, invalidate a refresh token, or log out all sessions/refresh tokens for a user.
    virtual ::grpc::Status SessionLogout(::grpc::ClientContext* context, const ::nakama::api::SessionLogoutRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncSessionLogout(::grpc::ClientContext* context, const ::nakama::api::SessionLogoutRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncSessionLogoutRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncSessionLogout(::grpc::ClientContext* context, const ::nakama::api::SessionLogoutRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncSessionLogoutRaw(context, request, cq));
    }
    // Authenticate a user with an Apple ID against the server.
    virtual ::grpc::Status AuthenticateApple(::grpc::ClientContext* context, const ::nakama::api::AuthenticateAppleRequest& request, ::nakama::api::Session* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Session>> AsyncAuthenticateApple(::grpc::ClientContext* context, const ::nakama::api::AuthenticateAppleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Session>>(AsyncAuthenticateAppleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Session>> PrepareAsyncAuthenticateApple(::grpc::ClientContext* context, const ::nakama::api::AuthenticateAppleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Session>>(PrepareAsyncAuthenticateAppleRaw(context, request, cq));
    }
    // Authenticate a user with a custom id against the server.
    virtual ::grpc::Status AuthenticateCustom(::grpc::ClientContext* context, const ::nakama::api::AuthenticateCustomRequest& request, ::nakama::api::Session* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Session>> AsyncAuthenticateCustom(::grpc::ClientContext* context, const ::nakama::api::AuthenticateCustomRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Session>>(AsyncAuthenticateCustomRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Session>> PrepareAsyncAuthenticateCustom(::grpc::ClientContext* context, const ::nakama::api::AuthenticateCustomRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Session>>(PrepareAsyncAuthenticateCustomRaw(context, request, cq));
    }
    // Authenticate a user with a device id against the server.
    virtual ::grpc::Status AuthenticateDevice(::grpc::ClientContext* context, const ::nakama::api::AuthenticateDeviceRequest& request, ::nakama::api::Session* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Session>> AsyncAuthenticateDevice(::grpc::ClientContext* context, const ::nakama::api::AuthenticateDeviceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Session>>(AsyncAuthenticateDeviceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Session>> PrepareAsyncAuthenticateDevice(::grpc::ClientContext* context, const ::nakama::api::AuthenticateDeviceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Session>>(PrepareAsyncAuthenticateDeviceRaw(context, request, cq));
    }
    // Authenticate a user with an email+password against the server.
    virtual ::grpc::Status AuthenticateEmail(::grpc::ClientContext* context, const ::nakama::api::AuthenticateEmailRequest& request, ::nakama::api::Session* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Session>> AsyncAuthenticateEmail(::grpc::ClientContext* context, const ::nakama::api::AuthenticateEmailRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Session>>(AsyncAuthenticateEmailRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Session>> PrepareAsyncAuthenticateEmail(::grpc::ClientContext* context, const ::nakama::api::AuthenticateEmailRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Session>>(PrepareAsyncAuthenticateEmailRaw(context, request, cq));
    }
    // Authenticate a user with a Facebook OAuth token against the server.
    virtual ::grpc::Status AuthenticateFacebook(::grpc::ClientContext* context, const ::nakama::api::AuthenticateFacebookRequest& request, ::nakama::api::Session* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Session>> AsyncAuthenticateFacebook(::grpc::ClientContext* context, const ::nakama::api::AuthenticateFacebookRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Session>>(AsyncAuthenticateFacebookRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Session>> PrepareAsyncAuthenticateFacebook(::grpc::ClientContext* context, const ::nakama::api::AuthenticateFacebookRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Session>>(PrepareAsyncAuthenticateFacebookRaw(context, request, cq));
    }
    // Authenticate a user with a Facebook Instant Game token against the server.
    virtual ::grpc::Status AuthenticateFacebookInstantGame(::grpc::ClientContext* context, const ::nakama::api::AuthenticateFacebookInstantGameRequest& request, ::nakama::api::Session* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Session>> AsyncAuthenticateFacebookInstantGame(::grpc::ClientContext* context, const ::nakama::api::AuthenticateFacebookInstantGameRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Session>>(AsyncAuthenticateFacebookInstantGameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Session>> PrepareAsyncAuthenticateFacebookInstantGame(::grpc::ClientContext* context, const ::nakama::api::AuthenticateFacebookInstantGameRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Session>>(PrepareAsyncAuthenticateFacebookInstantGameRaw(context, request, cq));
    }
    // Authenticate a user with Apple's GameCenter against the server.
    virtual ::grpc::Status AuthenticateGameCenter(::grpc::ClientContext* context, const ::nakama::api::AuthenticateGameCenterRequest& request, ::nakama::api::Session* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Session>> AsyncAuthenticateGameCenter(::grpc::ClientContext* context, const ::nakama::api::AuthenticateGameCenterRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Session>>(AsyncAuthenticateGameCenterRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Session>> PrepareAsyncAuthenticateGameCenter(::grpc::ClientContext* context, const ::nakama::api::AuthenticateGameCenterRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Session>>(PrepareAsyncAuthenticateGameCenterRaw(context, request, cq));
    }
    // Authenticate a user with Google against the server.
    virtual ::grpc::Status AuthenticateGoogle(::grpc::ClientContext* context, const ::nakama::api::AuthenticateGoogleRequest& request, ::nakama::api::Session* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Session>> AsyncAuthenticateGoogle(::grpc::ClientContext* context, const ::nakama::api::AuthenticateGoogleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Session>>(AsyncAuthenticateGoogleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Session>> PrepareAsyncAuthenticateGoogle(::grpc::ClientContext* context, const ::nakama::api::AuthenticateGoogleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Session>>(PrepareAsyncAuthenticateGoogleRaw(context, request, cq));
    }
    // Authenticate a user with Steam against the server.
    virtual ::grpc::Status AuthenticateSteam(::grpc::ClientContext* context, const ::nakama::api::AuthenticateSteamRequest& request, ::nakama::api::Session* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Session>> AsyncAuthenticateSteam(::grpc::ClientContext* context, const ::nakama::api::AuthenticateSteamRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Session>>(AsyncAuthenticateSteamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Session>> PrepareAsyncAuthenticateSteam(::grpc::ClientContext* context, const ::nakama::api::AuthenticateSteamRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Session>>(PrepareAsyncAuthenticateSteamRaw(context, request, cq));
    }
    // Ban a set of users from a group.
    virtual ::grpc::Status BanGroupUsers(::grpc::ClientContext* context, const ::nakama::api::BanGroupUsersRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncBanGroupUsers(::grpc::ClientContext* context, const ::nakama::api::BanGroupUsersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncBanGroupUsersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncBanGroupUsers(::grpc::ClientContext* context, const ::nakama::api::BanGroupUsersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncBanGroupUsersRaw(context, request, cq));
    }
    // Block one or more users by ID or username.
    virtual ::grpc::Status BlockFriends(::grpc::ClientContext* context, const ::nakama::api::BlockFriendsRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncBlockFriends(::grpc::ClientContext* context, const ::nakama::api::BlockFriendsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncBlockFriendsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncBlockFriends(::grpc::ClientContext* context, const ::nakama::api::BlockFriendsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncBlockFriendsRaw(context, request, cq));
    }
    // Create a new group with the current user as the owner.
    virtual ::grpc::Status CreateGroup(::grpc::ClientContext* context, const ::nakama::api::CreateGroupRequest& request, ::nakama::api::Group* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Group>> AsyncCreateGroup(::grpc::ClientContext* context, const ::nakama::api::CreateGroupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Group>>(AsyncCreateGroupRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Group>> PrepareAsyncCreateGroup(::grpc::ClientContext* context, const ::nakama::api::CreateGroupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Group>>(PrepareAsyncCreateGroupRaw(context, request, cq));
    }
    // Delete one or more users by ID or username.
    virtual ::grpc::Status DeleteFriends(::grpc::ClientContext* context, const ::nakama::api::DeleteFriendsRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncDeleteFriends(::grpc::ClientContext* context, const ::nakama::api::DeleteFriendsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncDeleteFriendsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncDeleteFriends(::grpc::ClientContext* context, const ::nakama::api::DeleteFriendsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncDeleteFriendsRaw(context, request, cq));
    }
    // Delete a group by ID.
    virtual ::grpc::Status DeleteGroup(::grpc::ClientContext* context, const ::nakama::api::DeleteGroupRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncDeleteGroup(::grpc::ClientContext* context, const ::nakama::api::DeleteGroupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncDeleteGroupRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncDeleteGroup(::grpc::ClientContext* context, const ::nakama::api::DeleteGroupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncDeleteGroupRaw(context, request, cq));
    }
    // Delete a leaderboard record.
    virtual ::grpc::Status DeleteLeaderboardRecord(::grpc::ClientContext* context, const ::nakama::api::DeleteLeaderboardRecordRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncDeleteLeaderboardRecord(::grpc::ClientContext* context, const ::nakama::api::DeleteLeaderboardRecordRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncDeleteLeaderboardRecordRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncDeleteLeaderboardRecord(::grpc::ClientContext* context, const ::nakama::api::DeleteLeaderboardRecordRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncDeleteLeaderboardRecordRaw(context, request, cq));
    }
    // Delete one or more notifications for the current user.
    virtual ::grpc::Status DeleteNotifications(::grpc::ClientContext* context, const ::nakama::api::DeleteNotificationsRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncDeleteNotifications(::grpc::ClientContext* context, const ::nakama::api::DeleteNotificationsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncDeleteNotificationsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncDeleteNotifications(::grpc::ClientContext* context, const ::nakama::api::DeleteNotificationsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncDeleteNotificationsRaw(context, request, cq));
    }
    // Delete one or more objects by ID or username.
    virtual ::grpc::Status DeleteStorageObjects(::grpc::ClientContext* context, const ::nakama::api::DeleteStorageObjectsRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncDeleteStorageObjects(::grpc::ClientContext* context, const ::nakama::api::DeleteStorageObjectsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncDeleteStorageObjectsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncDeleteStorageObjects(::grpc::ClientContext* context, const ::nakama::api::DeleteStorageObjectsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncDeleteStorageObjectsRaw(context, request, cq));
    }
    // Submit an event for processing in the server's registered runtime custom events handler.
    virtual ::grpc::Status Event(::grpc::ClientContext* context, const ::nakama::api::Event& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncEvent(::grpc::ClientContext* context, const ::nakama::api::Event& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncEventRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncEvent(::grpc::ClientContext* context, const ::nakama::api::Event& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncEventRaw(context, request, cq));
    }
    // Fetch the current user's account.
    virtual ::grpc::Status GetAccount(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::nakama::api::Account* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Account>> AsyncGetAccount(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Account>>(AsyncGetAccountRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Account>> PrepareAsyncGetAccount(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Account>>(PrepareAsyncGetAccountRaw(context, request, cq));
    }
    // Fetch zero or more users by ID and/or username.
    virtual ::grpc::Status GetUsers(::grpc::ClientContext* context, const ::nakama::api::GetUsersRequest& request, ::nakama::api::Users* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Users>> AsyncGetUsers(::grpc::ClientContext* context, const ::nakama::api::GetUsersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Users>>(AsyncGetUsersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Users>> PrepareAsyncGetUsers(::grpc::ClientContext* context, const ::nakama::api::GetUsersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Users>>(PrepareAsyncGetUsersRaw(context, request, cq));
    }
    // A healthcheck which load balancers can use to check the service.
    virtual ::grpc::Status Healthcheck(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncHealthcheck(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncHealthcheckRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncHealthcheck(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncHealthcheckRaw(context, request, cq));
    }
    // Import Facebook friends and add them to a user's account.
    virtual ::grpc::Status ImportFacebookFriends(::grpc::ClientContext* context, const ::nakama::api::ImportFacebookFriendsRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncImportFacebookFriends(::grpc::ClientContext* context, const ::nakama::api::ImportFacebookFriendsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncImportFacebookFriendsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncImportFacebookFriends(::grpc::ClientContext* context, const ::nakama::api::ImportFacebookFriendsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncImportFacebookFriendsRaw(context, request, cq));
    }
    // Import Steam friends and add them to a user's account.
    virtual ::grpc::Status ImportSteamFriends(::grpc::ClientContext* context, const ::nakama::api::ImportSteamFriendsRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncImportSteamFriends(::grpc::ClientContext* context, const ::nakama::api::ImportSteamFriendsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncImportSteamFriendsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncImportSteamFriends(::grpc::ClientContext* context, const ::nakama::api::ImportSteamFriendsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncImportSteamFriendsRaw(context, request, cq));
    }
    // Immediately join an open group, or request to join a closed one.
    virtual ::grpc::Status JoinGroup(::grpc::ClientContext* context, const ::nakama::api::JoinGroupRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncJoinGroup(::grpc::ClientContext* context, const ::nakama::api::JoinGroupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncJoinGroupRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncJoinGroup(::grpc::ClientContext* context, const ::nakama::api::JoinGroupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncJoinGroupRaw(context, request, cq));
    }
    // Attempt to join an open and running tournament.
    virtual ::grpc::Status JoinTournament(::grpc::ClientContext* context, const ::nakama::api::JoinTournamentRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncJoinTournament(::grpc::ClientContext* context, const ::nakama::api::JoinTournamentRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncJoinTournamentRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncJoinTournament(::grpc::ClientContext* context, const ::nakama::api::JoinTournamentRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncJoinTournamentRaw(context, request, cq));
    }
    // Kick a set of users from a group.
    virtual ::grpc::Status KickGroupUsers(::grpc::ClientContext* context, const ::nakama::api::KickGroupUsersRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncKickGroupUsers(::grpc::ClientContext* context, const ::nakama::api::KickGroupUsersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncKickGroupUsersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncKickGroupUsers(::grpc::ClientContext* context, const ::nakama::api::KickGroupUsersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncKickGroupUsersRaw(context, request, cq));
    }
    // Leave a group the user is a member of.
    virtual ::grpc::Status LeaveGroup(::grpc::ClientContext* context, const ::nakama::api::LeaveGroupRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncLeaveGroup(::grpc::ClientContext* context, const ::nakama::api::LeaveGroupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncLeaveGroupRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncLeaveGroup(::grpc::ClientContext* context, const ::nakama::api::LeaveGroupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncLeaveGroupRaw(context, request, cq));
    }
    // Add an Apple ID to the social profiles on the current user's account.
    virtual ::grpc::Status LinkApple(::grpc::ClientContext* context, const ::nakama::api::AccountApple& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncLinkApple(::grpc::ClientContext* context, const ::nakama::api::AccountApple& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncLinkAppleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncLinkApple(::grpc::ClientContext* context, const ::nakama::api::AccountApple& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncLinkAppleRaw(context, request, cq));
    }
    // Add a custom ID to the social profiles on the current user's account.
    virtual ::grpc::Status LinkCustom(::grpc::ClientContext* context, const ::nakama::api::AccountCustom& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncLinkCustom(::grpc::ClientContext* context, const ::nakama::api::AccountCustom& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncLinkCustomRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncLinkCustom(::grpc::ClientContext* context, const ::nakama::api::AccountCustom& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncLinkCustomRaw(context, request, cq));
    }
    // Add a device ID to the social profiles on the current user's account.
    virtual ::grpc::Status LinkDevice(::grpc::ClientContext* context, const ::nakama::api::AccountDevice& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncLinkDevice(::grpc::ClientContext* context, const ::nakama::api::AccountDevice& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncLinkDeviceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncLinkDevice(::grpc::ClientContext* context, const ::nakama::api::AccountDevice& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncLinkDeviceRaw(context, request, cq));
    }
    // Add an email+password to the social profiles on the current user's account.
    virtual ::grpc::Status LinkEmail(::grpc::ClientContext* context, const ::nakama::api::AccountEmail& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncLinkEmail(::grpc::ClientContext* context, const ::nakama::api::AccountEmail& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncLinkEmailRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncLinkEmail(::grpc::ClientContext* context, const ::nakama::api::AccountEmail& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncLinkEmailRaw(context, request, cq));
    }
    // Add Facebook to the social profiles on the current user's account.
    virtual ::grpc::Status LinkFacebook(::grpc::ClientContext* context, const ::nakama::api::LinkFacebookRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncLinkFacebook(::grpc::ClientContext* context, const ::nakama::api::LinkFacebookRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncLinkFacebookRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncLinkFacebook(::grpc::ClientContext* context, const ::nakama::api::LinkFacebookRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncLinkFacebookRaw(context, request, cq));
    }
    // Add Facebook Instant Game to the social profiles on the current user's account.
    virtual ::grpc::Status LinkFacebookInstantGame(::grpc::ClientContext* context, const ::nakama::api::AccountFacebookInstantGame& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncLinkFacebookInstantGame(::grpc::ClientContext* context, const ::nakama::api::AccountFacebookInstantGame& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncLinkFacebookInstantGameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncLinkFacebookInstantGame(::grpc::ClientContext* context, const ::nakama::api::AccountFacebookInstantGame& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncLinkFacebookInstantGameRaw(context, request, cq));
    }
    // Add Apple's GameCenter to the social profiles on the current user's account.
    virtual ::grpc::Status LinkGameCenter(::grpc::ClientContext* context, const ::nakama::api::AccountGameCenter& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncLinkGameCenter(::grpc::ClientContext* context, const ::nakama::api::AccountGameCenter& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncLinkGameCenterRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncLinkGameCenter(::grpc::ClientContext* context, const ::nakama::api::AccountGameCenter& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncLinkGameCenterRaw(context, request, cq));
    }
    // Add Google to the social profiles on the current user's account.
    virtual ::grpc::Status LinkGoogle(::grpc::ClientContext* context, const ::nakama::api::AccountGoogle& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncLinkGoogle(::grpc::ClientContext* context, const ::nakama::api::AccountGoogle& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncLinkGoogleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncLinkGoogle(::grpc::ClientContext* context, const ::nakama::api::AccountGoogle& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncLinkGoogleRaw(context, request, cq));
    }
    // Add Steam to the social profiles on the current user's account.
    virtual ::grpc::Status LinkSteam(::grpc::ClientContext* context, const ::nakama::api::LinkSteamRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncLinkSteam(::grpc::ClientContext* context, const ::nakama::api::LinkSteamRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncLinkSteamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncLinkSteam(::grpc::ClientContext* context, const ::nakama::api::LinkSteamRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncLinkSteamRaw(context, request, cq));
    }
    // List a channel's message history.
    virtual ::grpc::Status ListChannelMessages(::grpc::ClientContext* context, const ::nakama::api::ListChannelMessagesRequest& request, ::nakama::api::ChannelMessageList* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::ChannelMessageList>> AsyncListChannelMessages(::grpc::ClientContext* context, const ::nakama::api::ListChannelMessagesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::ChannelMessageList>>(AsyncListChannelMessagesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::ChannelMessageList>> PrepareAsyncListChannelMessages(::grpc::ClientContext* context, const ::nakama::api::ListChannelMessagesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::ChannelMessageList>>(PrepareAsyncListChannelMessagesRaw(context, request, cq));
    }
    // List all friends for the current user.
    virtual ::grpc::Status ListFriends(::grpc::ClientContext* context, const ::nakama::api::ListFriendsRequest& request, ::nakama::api::FriendList* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::FriendList>> AsyncListFriends(::grpc::ClientContext* context, const ::nakama::api::ListFriendsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::FriendList>>(AsyncListFriendsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::FriendList>> PrepareAsyncListFriends(::grpc::ClientContext* context, const ::nakama::api::ListFriendsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::FriendList>>(PrepareAsyncListFriendsRaw(context, request, cq));
    }
    // List groups based on given filters.
    virtual ::grpc::Status ListGroups(::grpc::ClientContext* context, const ::nakama::api::ListGroupsRequest& request, ::nakama::api::GroupList* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::GroupList>> AsyncListGroups(::grpc::ClientContext* context, const ::nakama::api::ListGroupsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::GroupList>>(AsyncListGroupsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::GroupList>> PrepareAsyncListGroups(::grpc::ClientContext* context, const ::nakama::api::ListGroupsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::GroupList>>(PrepareAsyncListGroupsRaw(context, request, cq));
    }
    // List all users that are part of a group.
    virtual ::grpc::Status ListGroupUsers(::grpc::ClientContext* context, const ::nakama::api::ListGroupUsersRequest& request, ::nakama::api::GroupUserList* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::GroupUserList>> AsyncListGroupUsers(::grpc::ClientContext* context, const ::nakama::api::ListGroupUsersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::GroupUserList>>(AsyncListGroupUsersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::GroupUserList>> PrepareAsyncListGroupUsers(::grpc::ClientContext* context, const ::nakama::api::ListGroupUsersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::GroupUserList>>(PrepareAsyncListGroupUsersRaw(context, request, cq));
    }
    // List leaderboard records.
    virtual ::grpc::Status ListLeaderboardRecords(::grpc::ClientContext* context, const ::nakama::api::ListLeaderboardRecordsRequest& request, ::nakama::api::LeaderboardRecordList* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::LeaderboardRecordList>> AsyncListLeaderboardRecords(::grpc::ClientContext* context, const ::nakama::api::ListLeaderboardRecordsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::LeaderboardRecordList>>(AsyncListLeaderboardRecordsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::LeaderboardRecordList>> PrepareAsyncListLeaderboardRecords(::grpc::ClientContext* context, const ::nakama::api::ListLeaderboardRecordsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::LeaderboardRecordList>>(PrepareAsyncListLeaderboardRecordsRaw(context, request, cq));
    }
    // List leaderboard records that belong to a user.
    virtual ::grpc::Status ListLeaderboardRecordsAroundOwner(::grpc::ClientContext* context, const ::nakama::api::ListLeaderboardRecordsAroundOwnerRequest& request, ::nakama::api::LeaderboardRecordList* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::LeaderboardRecordList>> AsyncListLeaderboardRecordsAroundOwner(::grpc::ClientContext* context, const ::nakama::api::ListLeaderboardRecordsAroundOwnerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::LeaderboardRecordList>>(AsyncListLeaderboardRecordsAroundOwnerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::LeaderboardRecordList>> PrepareAsyncListLeaderboardRecordsAroundOwner(::grpc::ClientContext* context, const ::nakama::api::ListLeaderboardRecordsAroundOwnerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::LeaderboardRecordList>>(PrepareAsyncListLeaderboardRecordsAroundOwnerRaw(context, request, cq));
    }
    // Fetch list of running matches.
    virtual ::grpc::Status ListMatches(::grpc::ClientContext* context, const ::nakama::api::ListMatchesRequest& request, ::nakama::api::MatchList* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::MatchList>> AsyncListMatches(::grpc::ClientContext* context, const ::nakama::api::ListMatchesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::MatchList>>(AsyncListMatchesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::MatchList>> PrepareAsyncListMatches(::grpc::ClientContext* context, const ::nakama::api::ListMatchesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::MatchList>>(PrepareAsyncListMatchesRaw(context, request, cq));
    }
    // Fetch list of notifications.
    virtual ::grpc::Status ListNotifications(::grpc::ClientContext* context, const ::nakama::api::ListNotificationsRequest& request, ::nakama::api::NotificationList* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::NotificationList>> AsyncListNotifications(::grpc::ClientContext* context, const ::nakama::api::ListNotificationsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::NotificationList>>(AsyncListNotificationsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::NotificationList>> PrepareAsyncListNotifications(::grpc::ClientContext* context, const ::nakama::api::ListNotificationsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::NotificationList>>(PrepareAsyncListNotificationsRaw(context, request, cq));
    }
    // List publicly readable storage objects in a given collection.
    virtual ::grpc::Status ListStorageObjects(::grpc::ClientContext* context, const ::nakama::api::ListStorageObjectsRequest& request, ::nakama::api::StorageObjectList* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::StorageObjectList>> AsyncListStorageObjects(::grpc::ClientContext* context, const ::nakama::api::ListStorageObjectsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::StorageObjectList>>(AsyncListStorageObjectsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::StorageObjectList>> PrepareAsyncListStorageObjects(::grpc::ClientContext* context, const ::nakama::api::ListStorageObjectsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::StorageObjectList>>(PrepareAsyncListStorageObjectsRaw(context, request, cq));
    }
    // List current or upcoming tournaments.
    virtual ::grpc::Status ListTournaments(::grpc::ClientContext* context, const ::nakama::api::ListTournamentsRequest& request, ::nakama::api::TournamentList* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::TournamentList>> AsyncListTournaments(::grpc::ClientContext* context, const ::nakama::api::ListTournamentsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::TournamentList>>(AsyncListTournamentsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::TournamentList>> PrepareAsyncListTournaments(::grpc::ClientContext* context, const ::nakama::api::ListTournamentsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::TournamentList>>(PrepareAsyncListTournamentsRaw(context, request, cq));
    }
    // List tournament records.
    virtual ::grpc::Status ListTournamentRecords(::grpc::ClientContext* context, const ::nakama::api::ListTournamentRecordsRequest& request, ::nakama::api::TournamentRecordList* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::TournamentRecordList>> AsyncListTournamentRecords(::grpc::ClientContext* context, const ::nakama::api::ListTournamentRecordsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::TournamentRecordList>>(AsyncListTournamentRecordsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::TournamentRecordList>> PrepareAsyncListTournamentRecords(::grpc::ClientContext* context, const ::nakama::api::ListTournamentRecordsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::TournamentRecordList>>(PrepareAsyncListTournamentRecordsRaw(context, request, cq));
    }
    // List tournament records for a given owner.
    virtual ::grpc::Status ListTournamentRecordsAroundOwner(::grpc::ClientContext* context, const ::nakama::api::ListTournamentRecordsAroundOwnerRequest& request, ::nakama::api::TournamentRecordList* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::TournamentRecordList>> AsyncListTournamentRecordsAroundOwner(::grpc::ClientContext* context, const ::nakama::api::ListTournamentRecordsAroundOwnerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::TournamentRecordList>>(AsyncListTournamentRecordsAroundOwnerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::TournamentRecordList>> PrepareAsyncListTournamentRecordsAroundOwner(::grpc::ClientContext* context, const ::nakama::api::ListTournamentRecordsAroundOwnerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::TournamentRecordList>>(PrepareAsyncListTournamentRecordsAroundOwnerRaw(context, request, cq));
    }
    // List groups the current user belongs to.
    virtual ::grpc::Status ListUserGroups(::grpc::ClientContext* context, const ::nakama::api::ListUserGroupsRequest& request, ::nakama::api::UserGroupList* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::UserGroupList>> AsyncListUserGroups(::grpc::ClientContext* context, const ::nakama::api::ListUserGroupsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::UserGroupList>>(AsyncListUserGroupsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::UserGroupList>> PrepareAsyncListUserGroups(::grpc::ClientContext* context, const ::nakama::api::ListUserGroupsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::UserGroupList>>(PrepareAsyncListUserGroupsRaw(context, request, cq));
    }
    // Promote a set of users in a group to the next role up.
    virtual ::grpc::Status PromoteGroupUsers(::grpc::ClientContext* context, const ::nakama::api::PromoteGroupUsersRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncPromoteGroupUsers(::grpc::ClientContext* context, const ::nakama::api::PromoteGroupUsersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncPromoteGroupUsersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncPromoteGroupUsers(::grpc::ClientContext* context, const ::nakama::api::PromoteGroupUsersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncPromoteGroupUsersRaw(context, request, cq));
    }
    // Demote a set of users in a group to the next role down.
    virtual ::grpc::Status DemoteGroupUsers(::grpc::ClientContext* context, const ::nakama::api::DemoteGroupUsersRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncDemoteGroupUsers(::grpc::ClientContext* context, const ::nakama::api::DemoteGroupUsersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncDemoteGroupUsersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncDemoteGroupUsers(::grpc::ClientContext* context, const ::nakama::api::DemoteGroupUsersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncDemoteGroupUsersRaw(context, request, cq));
    }
    // Get storage objects.
    virtual ::grpc::Status ReadStorageObjects(::grpc::ClientContext* context, const ::nakama::api::ReadStorageObjectsRequest& request, ::nakama::api::StorageObjects* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::StorageObjects>> AsyncReadStorageObjects(::grpc::ClientContext* context, const ::nakama::api::ReadStorageObjectsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::StorageObjects>>(AsyncReadStorageObjectsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::StorageObjects>> PrepareAsyncReadStorageObjects(::grpc::ClientContext* context, const ::nakama::api::ReadStorageObjectsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::StorageObjects>>(PrepareAsyncReadStorageObjectsRaw(context, request, cq));
    }
    // Execute a Lua function on the server.
    virtual ::grpc::Status RpcFunc(::grpc::ClientContext* context, const ::nakama::api::Rpc& request, ::nakama::api::Rpc* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Rpc>> AsyncRpcFunc(::grpc::ClientContext* context, const ::nakama::api::Rpc& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Rpc>>(AsyncRpcFuncRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Rpc>> PrepareAsyncRpcFunc(::grpc::ClientContext* context, const ::nakama::api::Rpc& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Rpc>>(PrepareAsyncRpcFuncRaw(context, request, cq));
    }
    // Remove the Apple ID from the social profiles on the current user's account.
    virtual ::grpc::Status UnlinkApple(::grpc::ClientContext* context, const ::nakama::api::AccountApple& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncUnlinkApple(::grpc::ClientContext* context, const ::nakama::api::AccountApple& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncUnlinkAppleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncUnlinkApple(::grpc::ClientContext* context, const ::nakama::api::AccountApple& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncUnlinkAppleRaw(context, request, cq));
    }
    // Remove the custom ID from the social profiles on the current user's account.
    virtual ::grpc::Status UnlinkCustom(::grpc::ClientContext* context, const ::nakama::api::AccountCustom& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncUnlinkCustom(::grpc::ClientContext* context, const ::nakama::api::AccountCustom& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncUnlinkCustomRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncUnlinkCustom(::grpc::ClientContext* context, const ::nakama::api::AccountCustom& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncUnlinkCustomRaw(context, request, cq));
    }
    // Remove the device ID from the social profiles on the current user's account.
    virtual ::grpc::Status UnlinkDevice(::grpc::ClientContext* context, const ::nakama::api::AccountDevice& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncUnlinkDevice(::grpc::ClientContext* context, const ::nakama::api::AccountDevice& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncUnlinkDeviceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncUnlinkDevice(::grpc::ClientContext* context, const ::nakama::api::AccountDevice& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncUnlinkDeviceRaw(context, request, cq));
    }
    // Remove the email+password from the social profiles on the current user's account.
    virtual ::grpc::Status UnlinkEmail(::grpc::ClientContext* context, const ::nakama::api::AccountEmail& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncUnlinkEmail(::grpc::ClientContext* context, const ::nakama::api::AccountEmail& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncUnlinkEmailRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncUnlinkEmail(::grpc::ClientContext* context, const ::nakama::api::AccountEmail& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncUnlinkEmailRaw(context, request, cq));
    }
    // Remove Facebook from the social profiles on the current user's account.
    virtual ::grpc::Status UnlinkFacebook(::grpc::ClientContext* context, const ::nakama::api::AccountFacebook& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncUnlinkFacebook(::grpc::ClientContext* context, const ::nakama::api::AccountFacebook& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncUnlinkFacebookRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncUnlinkFacebook(::grpc::ClientContext* context, const ::nakama::api::AccountFacebook& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncUnlinkFacebookRaw(context, request, cq));
    }
    // Remove Facebook Instant Game profile from the social profiles on the current user's account.
    virtual ::grpc::Status UnlinkFacebookInstantGame(::grpc::ClientContext* context, const ::nakama::api::AccountFacebookInstantGame& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncUnlinkFacebookInstantGame(::grpc::ClientContext* context, const ::nakama::api::AccountFacebookInstantGame& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncUnlinkFacebookInstantGameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncUnlinkFacebookInstantGame(::grpc::ClientContext* context, const ::nakama::api::AccountFacebookInstantGame& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncUnlinkFacebookInstantGameRaw(context, request, cq));
    }
    // Remove Apple's GameCenter from the social profiles on the current user's account.
    virtual ::grpc::Status UnlinkGameCenter(::grpc::ClientContext* context, const ::nakama::api::AccountGameCenter& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncUnlinkGameCenter(::grpc::ClientContext* context, const ::nakama::api::AccountGameCenter& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncUnlinkGameCenterRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncUnlinkGameCenter(::grpc::ClientContext* context, const ::nakama::api::AccountGameCenter& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncUnlinkGameCenterRaw(context, request, cq));
    }
    // Remove Google from the social profiles on the current user's account.
    virtual ::grpc::Status UnlinkGoogle(::grpc::ClientContext* context, const ::nakama::api::AccountGoogle& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncUnlinkGoogle(::grpc::ClientContext* context, const ::nakama::api::AccountGoogle& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncUnlinkGoogleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncUnlinkGoogle(::grpc::ClientContext* context, const ::nakama::api::AccountGoogle& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncUnlinkGoogleRaw(context, request, cq));
    }
    // Remove Steam from the social profiles on the current user's account.
    virtual ::grpc::Status UnlinkSteam(::grpc::ClientContext* context, const ::nakama::api::AccountSteam& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncUnlinkSteam(::grpc::ClientContext* context, const ::nakama::api::AccountSteam& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncUnlinkSteamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncUnlinkSteam(::grpc::ClientContext* context, const ::nakama::api::AccountSteam& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncUnlinkSteamRaw(context, request, cq));
    }
    // Update fields in the current user's account.
    virtual ::grpc::Status UpdateAccount(::grpc::ClientContext* context, const ::nakama::api::UpdateAccountRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncUpdateAccount(::grpc::ClientContext* context, const ::nakama::api::UpdateAccountRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncUpdateAccountRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncUpdateAccount(::grpc::ClientContext* context, const ::nakama::api::UpdateAccountRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncUpdateAccountRaw(context, request, cq));
    }
    // Update fields in a given group.
    virtual ::grpc::Status UpdateGroup(::grpc::ClientContext* context, const ::nakama::api::UpdateGroupRequest& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncUpdateGroup(::grpc::ClientContext* context, const ::nakama::api::UpdateGroupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncUpdateGroupRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncUpdateGroup(::grpc::ClientContext* context, const ::nakama::api::UpdateGroupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncUpdateGroupRaw(context, request, cq));
    }
    // Validate Apple IAP Receipt
    virtual ::grpc::Status ValidatePurchaseApple(::grpc::ClientContext* context, const ::nakama::api::ValidatePurchaseAppleRequest& request, ::nakama::api::ValidatePurchaseResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::ValidatePurchaseResponse>> AsyncValidatePurchaseApple(::grpc::ClientContext* context, const ::nakama::api::ValidatePurchaseAppleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::ValidatePurchaseResponse>>(AsyncValidatePurchaseAppleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::ValidatePurchaseResponse>> PrepareAsyncValidatePurchaseApple(::grpc::ClientContext* context, const ::nakama::api::ValidatePurchaseAppleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::ValidatePurchaseResponse>>(PrepareAsyncValidatePurchaseAppleRaw(context, request, cq));
    }
    // Validate Google IAP Receipt
    virtual ::grpc::Status ValidatePurchaseGoogle(::grpc::ClientContext* context, const ::nakama::api::ValidatePurchaseGoogleRequest& request, ::nakama::api::ValidatePurchaseResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::ValidatePurchaseResponse>> AsyncValidatePurchaseGoogle(::grpc::ClientContext* context, const ::nakama::api::ValidatePurchaseGoogleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::ValidatePurchaseResponse>>(AsyncValidatePurchaseGoogleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::ValidatePurchaseResponse>> PrepareAsyncValidatePurchaseGoogle(::grpc::ClientContext* context, const ::nakama::api::ValidatePurchaseGoogleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::ValidatePurchaseResponse>>(PrepareAsyncValidatePurchaseGoogleRaw(context, request, cq));
    }
    // Validate Huawei IAP Receipt
    virtual ::grpc::Status ValidatePurchaseHuawei(::grpc::ClientContext* context, const ::nakama::api::ValidatePurchaseHuaweiRequest& request, ::nakama::api::ValidatePurchaseResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::ValidatePurchaseResponse>> AsyncValidatePurchaseHuawei(::grpc::ClientContext* context, const ::nakama::api::ValidatePurchaseHuaweiRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::ValidatePurchaseResponse>>(AsyncValidatePurchaseHuaweiRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::ValidatePurchaseResponse>> PrepareAsyncValidatePurchaseHuawei(::grpc::ClientContext* context, const ::nakama::api::ValidatePurchaseHuaweiRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::ValidatePurchaseResponse>>(PrepareAsyncValidatePurchaseHuaweiRaw(context, request, cq));
    }
    // Write a record to a leaderboard.
    virtual ::grpc::Status WriteLeaderboardRecord(::grpc::ClientContext* context, const ::nakama::api::WriteLeaderboardRecordRequest& request, ::nakama::api::LeaderboardRecord* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::LeaderboardRecord>> AsyncWriteLeaderboardRecord(::grpc::ClientContext* context, const ::nakama::api::WriteLeaderboardRecordRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::LeaderboardRecord>>(AsyncWriteLeaderboardRecordRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::LeaderboardRecord>> PrepareAsyncWriteLeaderboardRecord(::grpc::ClientContext* context, const ::nakama::api::WriteLeaderboardRecordRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::LeaderboardRecord>>(PrepareAsyncWriteLeaderboardRecordRaw(context, request, cq));
    }
    // Write objects into the storage engine.
    virtual ::grpc::Status WriteStorageObjects(::grpc::ClientContext* context, const ::nakama::api::WriteStorageObjectsRequest& request, ::nakama::api::StorageObjectAcks* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::StorageObjectAcks>> AsyncWriteStorageObjects(::grpc::ClientContext* context, const ::nakama::api::WriteStorageObjectsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::StorageObjectAcks>>(AsyncWriteStorageObjectsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::StorageObjectAcks>> PrepareAsyncWriteStorageObjects(::grpc::ClientContext* context, const ::nakama::api::WriteStorageObjectsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::StorageObjectAcks>>(PrepareAsyncWriteStorageObjectsRaw(context, request, cq));
    }
    // Write a record to a tournament.
    virtual ::grpc::Status WriteTournamentRecord(::grpc::ClientContext* context, const ::nakama::api::WriteTournamentRecordRequest& request, ::nakama::api::LeaderboardRecord* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::LeaderboardRecord>> AsyncWriteTournamentRecord(::grpc::ClientContext* context, const ::nakama::api::WriteTournamentRecordRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::LeaderboardRecord>>(AsyncWriteTournamentRecordRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::LeaderboardRecord>> PrepareAsyncWriteTournamentRecord(::grpc::ClientContext* context, const ::nakama::api::WriteTournamentRecordRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::LeaderboardRecord>>(PrepareAsyncWriteTournamentRecordRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      // Add friends by ID or username to a user's account.
      virtual void AddFriends(::grpc::ClientContext* context, const ::nakama::api::AddFriendsRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void AddFriends(::grpc::ClientContext* context, const ::nakama::api::AddFriendsRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void AddFriends(::grpc::ClientContext* context, const ::nakama::api::AddFriendsRequest* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Add users to a group.
      virtual void AddGroupUsers(::grpc::ClientContext* context, const ::nakama::api::AddGroupUsersRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void AddGroupUsers(::grpc::ClientContext* context, const ::nakama::api::AddGroupUsersRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void AddGroupUsers(::grpc::ClientContext* context, const ::nakama::api::AddGroupUsersRequest* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Refresh a user's session using a refresh token retrieved from a previous authentication request.
      virtual void SessionRefresh(::grpc::ClientContext* context, const ::nakama::api::SessionRefreshRequest* request, ::nakama::api::Session* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SessionRefresh(::grpc::ClientContext* context, const ::nakama::api::SessionRefreshRequest* request, ::nakama::api::Session* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SessionRefresh(::grpc::ClientContext* context, const ::nakama::api::SessionRefreshRequest* request, ::nakama::api::Session* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Log out a session, invalidate a refresh token, or log out all sessions/refresh tokens for a user.
      virtual void SessionLogout(::grpc::ClientContext* context, const ::nakama::api::SessionLogoutRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SessionLogout(::grpc::ClientContext* context, const ::nakama::api::SessionLogoutRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SessionLogout(::grpc::ClientContext* context, const ::nakama::api::SessionLogoutRequest* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Authenticate a user with an Apple ID against the server.
      virtual void AuthenticateApple(::grpc::ClientContext* context, const ::nakama::api::AuthenticateAppleRequest* request, ::nakama::api::Session* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void AuthenticateApple(::grpc::ClientContext* context, const ::nakama::api::AuthenticateAppleRequest* request, ::nakama::api::Session* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void AuthenticateApple(::grpc::ClientContext* context, const ::nakama::api::AuthenticateAppleRequest* request, ::nakama::api::Session* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Authenticate a user with a custom id against the server.
      virtual void AuthenticateCustom(::grpc::ClientContext* context, const ::nakama::api::AuthenticateCustomRequest* request, ::nakama::api::Session* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void AuthenticateCustom(::grpc::ClientContext* context, const ::nakama::api::AuthenticateCustomRequest* request, ::nakama::api::Session* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void AuthenticateCustom(::grpc::ClientContext* context, const ::nakama::api::AuthenticateCustomRequest* request, ::nakama::api::Session* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Authenticate a user with a device id against the server.
      virtual void AuthenticateDevice(::grpc::ClientContext* context, const ::nakama::api::AuthenticateDeviceRequest* request, ::nakama::api::Session* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void AuthenticateDevice(::grpc::ClientContext* context, const ::nakama::api::AuthenticateDeviceRequest* request, ::nakama::api::Session* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void AuthenticateDevice(::grpc::ClientContext* context, const ::nakama::api::AuthenticateDeviceRequest* request, ::nakama::api::Session* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Authenticate a user with an email+password against the server.
      virtual void AuthenticateEmail(::grpc::ClientContext* context, const ::nakama::api::AuthenticateEmailRequest* request, ::nakama::api::Session* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void AuthenticateEmail(::grpc::ClientContext* context, const ::nakama::api::AuthenticateEmailRequest* request, ::nakama::api::Session* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void AuthenticateEmail(::grpc::ClientContext* context, const ::nakama::api::AuthenticateEmailRequest* request, ::nakama::api::Session* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Authenticate a user with a Facebook OAuth token against the server.
      virtual void AuthenticateFacebook(::grpc::ClientContext* context, const ::nakama::api::AuthenticateFacebookRequest* request, ::nakama::api::Session* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void AuthenticateFacebook(::grpc::ClientContext* context, const ::nakama::api::AuthenticateFacebookRequest* request, ::nakama::api::Session* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void AuthenticateFacebook(::grpc::ClientContext* context, const ::nakama::api::AuthenticateFacebookRequest* request, ::nakama::api::Session* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Authenticate a user with a Facebook Instant Game token against the server.
      virtual void AuthenticateFacebookInstantGame(::grpc::ClientContext* context, const ::nakama::api::AuthenticateFacebookInstantGameRequest* request, ::nakama::api::Session* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void AuthenticateFacebookInstantGame(::grpc::ClientContext* context, const ::nakama::api::AuthenticateFacebookInstantGameRequest* request, ::nakama::api::Session* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void AuthenticateFacebookInstantGame(::grpc::ClientContext* context, const ::nakama::api::AuthenticateFacebookInstantGameRequest* request, ::nakama::api::Session* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Authenticate a user with Apple's GameCenter against the server.
      virtual void AuthenticateGameCenter(::grpc::ClientContext* context, const ::nakama::api::AuthenticateGameCenterRequest* request, ::nakama::api::Session* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void AuthenticateGameCenter(::grpc::ClientContext* context, const ::nakama::api::AuthenticateGameCenterRequest* request, ::nakama::api::Session* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void AuthenticateGameCenter(::grpc::ClientContext* context, const ::nakama::api::AuthenticateGameCenterRequest* request, ::nakama::api::Session* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Authenticate a user with Google against the server.
      virtual void AuthenticateGoogle(::grpc::ClientContext* context, const ::nakama::api::AuthenticateGoogleRequest* request, ::nakama::api::Session* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void AuthenticateGoogle(::grpc::ClientContext* context, const ::nakama::api::AuthenticateGoogleRequest* request, ::nakama::api::Session* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void AuthenticateGoogle(::grpc::ClientContext* context, const ::nakama::api::AuthenticateGoogleRequest* request, ::nakama::api::Session* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Authenticate a user with Steam against the server.
      virtual void AuthenticateSteam(::grpc::ClientContext* context, const ::nakama::api::AuthenticateSteamRequest* request, ::nakama::api::Session* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void AuthenticateSteam(::grpc::ClientContext* context, const ::nakama::api::AuthenticateSteamRequest* request, ::nakama::api::Session* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void AuthenticateSteam(::grpc::ClientContext* context, const ::nakama::api::AuthenticateSteamRequest* request, ::nakama::api::Session* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Ban a set of users from a group.
      virtual void BanGroupUsers(::grpc::ClientContext* context, const ::nakama::api::BanGroupUsersRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void BanGroupUsers(::grpc::ClientContext* context, const ::nakama::api::BanGroupUsersRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void BanGroupUsers(::grpc::ClientContext* context, const ::nakama::api::BanGroupUsersRequest* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Block one or more users by ID or username.
      virtual void BlockFriends(::grpc::ClientContext* context, const ::nakama::api::BlockFriendsRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void BlockFriends(::grpc::ClientContext* context, const ::nakama::api::BlockFriendsRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void BlockFriends(::grpc::ClientContext* context, const ::nakama::api::BlockFriendsRequest* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Create a new group with the current user as the owner.
      virtual void CreateGroup(::grpc::ClientContext* context, const ::nakama::api::CreateGroupRequest* request, ::nakama::api::Group* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void CreateGroup(::grpc::ClientContext* context, const ::nakama::api::CreateGroupRequest* request, ::nakama::api::Group* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void CreateGroup(::grpc::ClientContext* context, const ::nakama::api::CreateGroupRequest* request, ::nakama::api::Group* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Delete one or more users by ID or username.
      virtual void DeleteFriends(::grpc::ClientContext* context, const ::nakama::api::DeleteFriendsRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteFriends(::grpc::ClientContext* context, const ::nakama::api::DeleteFriendsRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteFriends(::grpc::ClientContext* context, const ::nakama::api::DeleteFriendsRequest* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Delete a group by ID.
      virtual void DeleteGroup(::grpc::ClientContext* context, const ::nakama::api::DeleteGroupRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteGroup(::grpc::ClientContext* context, const ::nakama::api::DeleteGroupRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteGroup(::grpc::ClientContext* context, const ::nakama::api::DeleteGroupRequest* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Delete a leaderboard record.
      virtual void DeleteLeaderboardRecord(::grpc::ClientContext* context, const ::nakama::api::DeleteLeaderboardRecordRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteLeaderboardRecord(::grpc::ClientContext* context, const ::nakama::api::DeleteLeaderboardRecordRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteLeaderboardRecord(::grpc::ClientContext* context, const ::nakama::api::DeleteLeaderboardRecordRequest* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Delete one or more notifications for the current user.
      virtual void DeleteNotifications(::grpc::ClientContext* context, const ::nakama::api::DeleteNotificationsRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteNotifications(::grpc::ClientContext* context, const ::nakama::api::DeleteNotificationsRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteNotifications(::grpc::ClientContext* context, const ::nakama::api::DeleteNotificationsRequest* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Delete one or more objects by ID or username.
      virtual void DeleteStorageObjects(::grpc::ClientContext* context, const ::nakama::api::DeleteStorageObjectsRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteStorageObjects(::grpc::ClientContext* context, const ::nakama::api::DeleteStorageObjectsRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteStorageObjects(::grpc::ClientContext* context, const ::nakama::api::DeleteStorageObjectsRequest* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Submit an event for processing in the server's registered runtime custom events handler.
      virtual void Event(::grpc::ClientContext* context, const ::nakama::api::Event* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Event(::grpc::ClientContext* context, const ::nakama::api::Event* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Event(::grpc::ClientContext* context, const ::nakama::api::Event* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Fetch the current user's account.
      virtual void GetAccount(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::nakama::api::Account* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetAccount(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::nakama::api::Account* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetAccount(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::nakama::api::Account* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Fetch zero or more users by ID and/or username.
      virtual void GetUsers(::grpc::ClientContext* context, const ::nakama::api::GetUsersRequest* request, ::nakama::api::Users* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetUsers(::grpc::ClientContext* context, const ::nakama::api::GetUsersRequest* request, ::nakama::api::Users* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetUsers(::grpc::ClientContext* context, const ::nakama::api::GetUsersRequest* request, ::nakama::api::Users* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // A healthcheck which load balancers can use to check the service.
      virtual void Healthcheck(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Healthcheck(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Healthcheck(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Import Facebook friends and add them to a user's account.
      virtual void ImportFacebookFriends(::grpc::ClientContext* context, const ::nakama::api::ImportFacebookFriendsRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ImportFacebookFriends(::grpc::ClientContext* context, const ::nakama::api::ImportFacebookFriendsRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ImportFacebookFriends(::grpc::ClientContext* context, const ::nakama::api::ImportFacebookFriendsRequest* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Import Steam friends and add them to a user's account.
      virtual void ImportSteamFriends(::grpc::ClientContext* context, const ::nakama::api::ImportSteamFriendsRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ImportSteamFriends(::grpc::ClientContext* context, const ::nakama::api::ImportSteamFriendsRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ImportSteamFriends(::grpc::ClientContext* context, const ::nakama::api::ImportSteamFriendsRequest* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Immediately join an open group, or request to join a closed one.
      virtual void JoinGroup(::grpc::ClientContext* context, const ::nakama::api::JoinGroupRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void JoinGroup(::grpc::ClientContext* context, const ::nakama::api::JoinGroupRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void JoinGroup(::grpc::ClientContext* context, const ::nakama::api::JoinGroupRequest* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Attempt to join an open and running tournament.
      virtual void JoinTournament(::grpc::ClientContext* context, const ::nakama::api::JoinTournamentRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void JoinTournament(::grpc::ClientContext* context, const ::nakama::api::JoinTournamentRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void JoinTournament(::grpc::ClientContext* context, const ::nakama::api::JoinTournamentRequest* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Kick a set of users from a group.
      virtual void KickGroupUsers(::grpc::ClientContext* context, const ::nakama::api::KickGroupUsersRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void KickGroupUsers(::grpc::ClientContext* context, const ::nakama::api::KickGroupUsersRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void KickGroupUsers(::grpc::ClientContext* context, const ::nakama::api::KickGroupUsersRequest* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Leave a group the user is a member of.
      virtual void LeaveGroup(::grpc::ClientContext* context, const ::nakama::api::LeaveGroupRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void LeaveGroup(::grpc::ClientContext* context, const ::nakama::api::LeaveGroupRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void LeaveGroup(::grpc::ClientContext* context, const ::nakama::api::LeaveGroupRequest* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Add an Apple ID to the social profiles on the current user's account.
      virtual void LinkApple(::grpc::ClientContext* context, const ::nakama::api::AccountApple* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void LinkApple(::grpc::ClientContext* context, const ::nakama::api::AccountApple* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void LinkApple(::grpc::ClientContext* context, const ::nakama::api::AccountApple* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Add a custom ID to the social profiles on the current user's account.
      virtual void LinkCustom(::grpc::ClientContext* context, const ::nakama::api::AccountCustom* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void LinkCustom(::grpc::ClientContext* context, const ::nakama::api::AccountCustom* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void LinkCustom(::grpc::ClientContext* context, const ::nakama::api::AccountCustom* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Add a device ID to the social profiles on the current user's account.
      virtual void LinkDevice(::grpc::ClientContext* context, const ::nakama::api::AccountDevice* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void LinkDevice(::grpc::ClientContext* context, const ::nakama::api::AccountDevice* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void LinkDevice(::grpc::ClientContext* context, const ::nakama::api::AccountDevice* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Add an email+password to the social profiles on the current user's account.
      virtual void LinkEmail(::grpc::ClientContext* context, const ::nakama::api::AccountEmail* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void LinkEmail(::grpc::ClientContext* context, const ::nakama::api::AccountEmail* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void LinkEmail(::grpc::ClientContext* context, const ::nakama::api::AccountEmail* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Add Facebook to the social profiles on the current user's account.
      virtual void LinkFacebook(::grpc::ClientContext* context, const ::nakama::api::LinkFacebookRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void LinkFacebook(::grpc::ClientContext* context, const ::nakama::api::LinkFacebookRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void LinkFacebook(::grpc::ClientContext* context, const ::nakama::api::LinkFacebookRequest* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Add Facebook Instant Game to the social profiles on the current user's account.
      virtual void LinkFacebookInstantGame(::grpc::ClientContext* context, const ::nakama::api::AccountFacebookInstantGame* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void LinkFacebookInstantGame(::grpc::ClientContext* context, const ::nakama::api::AccountFacebookInstantGame* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void LinkFacebookInstantGame(::grpc::ClientContext* context, const ::nakama::api::AccountFacebookInstantGame* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Add Apple's GameCenter to the social profiles on the current user's account.
      virtual void LinkGameCenter(::grpc::ClientContext* context, const ::nakama::api::AccountGameCenter* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void LinkGameCenter(::grpc::ClientContext* context, const ::nakama::api::AccountGameCenter* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void LinkGameCenter(::grpc::ClientContext* context, const ::nakama::api::AccountGameCenter* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Add Google to the social profiles on the current user's account.
      virtual void LinkGoogle(::grpc::ClientContext* context, const ::nakama::api::AccountGoogle* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void LinkGoogle(::grpc::ClientContext* context, const ::nakama::api::AccountGoogle* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void LinkGoogle(::grpc::ClientContext* context, const ::nakama::api::AccountGoogle* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Add Steam to the social profiles on the current user's account.
      virtual void LinkSteam(::grpc::ClientContext* context, const ::nakama::api::LinkSteamRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void LinkSteam(::grpc::ClientContext* context, const ::nakama::api::LinkSteamRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void LinkSteam(::grpc::ClientContext* context, const ::nakama::api::LinkSteamRequest* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // List a channel's message history.
      virtual void ListChannelMessages(::grpc::ClientContext* context, const ::nakama::api::ListChannelMessagesRequest* request, ::nakama::api::ChannelMessageList* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListChannelMessages(::grpc::ClientContext* context, const ::nakama::api::ListChannelMessagesRequest* request, ::nakama::api::ChannelMessageList* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListChannelMessages(::grpc::ClientContext* context, const ::nakama::api::ListChannelMessagesRequest* request, ::nakama::api::ChannelMessageList* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // List all friends for the current user.
      virtual void ListFriends(::grpc::ClientContext* context, const ::nakama::api::ListFriendsRequest* request, ::nakama::api::FriendList* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListFriends(::grpc::ClientContext* context, const ::nakama::api::ListFriendsRequest* request, ::nakama::api::FriendList* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListFriends(::grpc::ClientContext* context, const ::nakama::api::ListFriendsRequest* request, ::nakama::api::FriendList* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // List groups based on given filters.
      virtual void ListGroups(::grpc::ClientContext* context, const ::nakama::api::ListGroupsRequest* request, ::nakama::api::GroupList* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListGroups(::grpc::ClientContext* context, const ::nakama::api::ListGroupsRequest* request, ::nakama::api::GroupList* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListGroups(::grpc::ClientContext* context, const ::nakama::api::ListGroupsRequest* request, ::nakama::api::GroupList* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // List all users that are part of a group.
      virtual void ListGroupUsers(::grpc::ClientContext* context, const ::nakama::api::ListGroupUsersRequest* request, ::nakama::api::GroupUserList* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListGroupUsers(::grpc::ClientContext* context, const ::nakama::api::ListGroupUsersRequest* request, ::nakama::api::GroupUserList* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListGroupUsers(::grpc::ClientContext* context, const ::nakama::api::ListGroupUsersRequest* request, ::nakama::api::GroupUserList* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // List leaderboard records.
      virtual void ListLeaderboardRecords(::grpc::ClientContext* context, const ::nakama::api::ListLeaderboardRecordsRequest* request, ::nakama::api::LeaderboardRecordList* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListLeaderboardRecords(::grpc::ClientContext* context, const ::nakama::api::ListLeaderboardRecordsRequest* request, ::nakama::api::LeaderboardRecordList* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListLeaderboardRecords(::grpc::ClientContext* context, const ::nakama::api::ListLeaderboardRecordsRequest* request, ::nakama::api::LeaderboardRecordList* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // List leaderboard records that belong to a user.
      virtual void ListLeaderboardRecordsAroundOwner(::grpc::ClientContext* context, const ::nakama::api::ListLeaderboardRecordsAroundOwnerRequest* request, ::nakama::api::LeaderboardRecordList* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListLeaderboardRecordsAroundOwner(::grpc::ClientContext* context, const ::nakama::api::ListLeaderboardRecordsAroundOwnerRequest* request, ::nakama::api::LeaderboardRecordList* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListLeaderboardRecordsAroundOwner(::grpc::ClientContext* context, const ::nakama::api::ListLeaderboardRecordsAroundOwnerRequest* request, ::nakama::api::LeaderboardRecordList* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Fetch list of running matches.
      virtual void ListMatches(::grpc::ClientContext* context, const ::nakama::api::ListMatchesRequest* request, ::nakama::api::MatchList* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListMatches(::grpc::ClientContext* context, const ::nakama::api::ListMatchesRequest* request, ::nakama::api::MatchList* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListMatches(::grpc::ClientContext* context, const ::nakama::api::ListMatchesRequest* request, ::nakama::api::MatchList* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Fetch list of notifications.
      virtual void ListNotifications(::grpc::ClientContext* context, const ::nakama::api::ListNotificationsRequest* request, ::nakama::api::NotificationList* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListNotifications(::grpc::ClientContext* context, const ::nakama::api::ListNotificationsRequest* request, ::nakama::api::NotificationList* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListNotifications(::grpc::ClientContext* context, const ::nakama::api::ListNotificationsRequest* request, ::nakama::api::NotificationList* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // List publicly readable storage objects in a given collection.
      virtual void ListStorageObjects(::grpc::ClientContext* context, const ::nakama::api::ListStorageObjectsRequest* request, ::nakama::api::StorageObjectList* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListStorageObjects(::grpc::ClientContext* context, const ::nakama::api::ListStorageObjectsRequest* request, ::nakama::api::StorageObjectList* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListStorageObjects(::grpc::ClientContext* context, const ::nakama::api::ListStorageObjectsRequest* request, ::nakama::api::StorageObjectList* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // List current or upcoming tournaments.
      virtual void ListTournaments(::grpc::ClientContext* context, const ::nakama::api::ListTournamentsRequest* request, ::nakama::api::TournamentList* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListTournaments(::grpc::ClientContext* context, const ::nakama::api::ListTournamentsRequest* request, ::nakama::api::TournamentList* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListTournaments(::grpc::ClientContext* context, const ::nakama::api::ListTournamentsRequest* request, ::nakama::api::TournamentList* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // List tournament records.
      virtual void ListTournamentRecords(::grpc::ClientContext* context, const ::nakama::api::ListTournamentRecordsRequest* request, ::nakama::api::TournamentRecordList* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListTournamentRecords(::grpc::ClientContext* context, const ::nakama::api::ListTournamentRecordsRequest* request, ::nakama::api::TournamentRecordList* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListTournamentRecords(::grpc::ClientContext* context, const ::nakama::api::ListTournamentRecordsRequest* request, ::nakama::api::TournamentRecordList* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // List tournament records for a given owner.
      virtual void ListTournamentRecordsAroundOwner(::grpc::ClientContext* context, const ::nakama::api::ListTournamentRecordsAroundOwnerRequest* request, ::nakama::api::TournamentRecordList* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListTournamentRecordsAroundOwner(::grpc::ClientContext* context, const ::nakama::api::ListTournamentRecordsAroundOwnerRequest* request, ::nakama::api::TournamentRecordList* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListTournamentRecordsAroundOwner(::grpc::ClientContext* context, const ::nakama::api::ListTournamentRecordsAroundOwnerRequest* request, ::nakama::api::TournamentRecordList* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // List groups the current user belongs to.
      virtual void ListUserGroups(::grpc::ClientContext* context, const ::nakama::api::ListUserGroupsRequest* request, ::nakama::api::UserGroupList* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListUserGroups(::grpc::ClientContext* context, const ::nakama::api::ListUserGroupsRequest* request, ::nakama::api::UserGroupList* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListUserGroups(::grpc::ClientContext* context, const ::nakama::api::ListUserGroupsRequest* request, ::nakama::api::UserGroupList* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Promote a set of users in a group to the next role up.
      virtual void PromoteGroupUsers(::grpc::ClientContext* context, const ::nakama::api::PromoteGroupUsersRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PromoteGroupUsers(::grpc::ClientContext* context, const ::nakama::api::PromoteGroupUsersRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PromoteGroupUsers(::grpc::ClientContext* context, const ::nakama::api::PromoteGroupUsersRequest* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Demote a set of users in a group to the next role down.
      virtual void DemoteGroupUsers(::grpc::ClientContext* context, const ::nakama::api::DemoteGroupUsersRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DemoteGroupUsers(::grpc::ClientContext* context, const ::nakama::api::DemoteGroupUsersRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DemoteGroupUsers(::grpc::ClientContext* context, const ::nakama::api::DemoteGroupUsersRequest* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Get storage objects.
      virtual void ReadStorageObjects(::grpc::ClientContext* context, const ::nakama::api::ReadStorageObjectsRequest* request, ::nakama::api::StorageObjects* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ReadStorageObjects(::grpc::ClientContext* context, const ::nakama::api::ReadStorageObjectsRequest* request, ::nakama::api::StorageObjects* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ReadStorageObjects(::grpc::ClientContext* context, const ::nakama::api::ReadStorageObjectsRequest* request, ::nakama::api::StorageObjects* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Execute a Lua function on the server.
      virtual void RpcFunc(::grpc::ClientContext* context, const ::nakama::api::Rpc* request, ::nakama::api::Rpc* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void RpcFunc(::grpc::ClientContext* context, const ::nakama::api::Rpc* request, ::nakama::api::Rpc* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void RpcFunc(::grpc::ClientContext* context, const ::nakama::api::Rpc* request, ::nakama::api::Rpc* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Remove the Apple ID from the social profiles on the current user's account.
      virtual void UnlinkApple(::grpc::ClientContext* context, const ::nakama::api::AccountApple* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void UnlinkApple(::grpc::ClientContext* context, const ::nakama::api::AccountApple* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void UnlinkApple(::grpc::ClientContext* context, const ::nakama::api::AccountApple* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Remove the custom ID from the social profiles on the current user's account.
      virtual void UnlinkCustom(::grpc::ClientContext* context, const ::nakama::api::AccountCustom* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void UnlinkCustom(::grpc::ClientContext* context, const ::nakama::api::AccountCustom* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void UnlinkCustom(::grpc::ClientContext* context, const ::nakama::api::AccountCustom* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Remove the device ID from the social profiles on the current user's account.
      virtual void UnlinkDevice(::grpc::ClientContext* context, const ::nakama::api::AccountDevice* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void UnlinkDevice(::grpc::ClientContext* context, const ::nakama::api::AccountDevice* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void UnlinkDevice(::grpc::ClientContext* context, const ::nakama::api::AccountDevice* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Remove the email+password from the social profiles on the current user's account.
      virtual void UnlinkEmail(::grpc::ClientContext* context, const ::nakama::api::AccountEmail* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void UnlinkEmail(::grpc::ClientContext* context, const ::nakama::api::AccountEmail* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void UnlinkEmail(::grpc::ClientContext* context, const ::nakama::api::AccountEmail* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Remove Facebook from the social profiles on the current user's account.
      virtual void UnlinkFacebook(::grpc::ClientContext* context, const ::nakama::api::AccountFacebook* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void UnlinkFacebook(::grpc::ClientContext* context, const ::nakama::api::AccountFacebook* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void UnlinkFacebook(::grpc::ClientContext* context, const ::nakama::api::AccountFacebook* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Remove Facebook Instant Game profile from the social profiles on the current user's account.
      virtual void UnlinkFacebookInstantGame(::grpc::ClientContext* context, const ::nakama::api::AccountFacebookInstantGame* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void UnlinkFacebookInstantGame(::grpc::ClientContext* context, const ::nakama::api::AccountFacebookInstantGame* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void UnlinkFacebookInstantGame(::grpc::ClientContext* context, const ::nakama::api::AccountFacebookInstantGame* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Remove Apple's GameCenter from the social profiles on the current user's account.
      virtual void UnlinkGameCenter(::grpc::ClientContext* context, const ::nakama::api::AccountGameCenter* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void UnlinkGameCenter(::grpc::ClientContext* context, const ::nakama::api::AccountGameCenter* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void UnlinkGameCenter(::grpc::ClientContext* context, const ::nakama::api::AccountGameCenter* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Remove Google from the social profiles on the current user's account.
      virtual void UnlinkGoogle(::grpc::ClientContext* context, const ::nakama::api::AccountGoogle* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void UnlinkGoogle(::grpc::ClientContext* context, const ::nakama::api::AccountGoogle* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void UnlinkGoogle(::grpc::ClientContext* context, const ::nakama::api::AccountGoogle* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Remove Steam from the social profiles on the current user's account.
      virtual void UnlinkSteam(::grpc::ClientContext* context, const ::nakama::api::AccountSteam* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void UnlinkSteam(::grpc::ClientContext* context, const ::nakama::api::AccountSteam* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void UnlinkSteam(::grpc::ClientContext* context, const ::nakama::api::AccountSteam* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Update fields in the current user's account.
      virtual void UpdateAccount(::grpc::ClientContext* context, const ::nakama::api::UpdateAccountRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void UpdateAccount(::grpc::ClientContext* context, const ::nakama::api::UpdateAccountRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void UpdateAccount(::grpc::ClientContext* context, const ::nakama::api::UpdateAccountRequest* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Update fields in a given group.
      virtual void UpdateGroup(::grpc::ClientContext* context, const ::nakama::api::UpdateGroupRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void UpdateGroup(::grpc::ClientContext* context, const ::nakama::api::UpdateGroupRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void UpdateGroup(::grpc::ClientContext* context, const ::nakama::api::UpdateGroupRequest* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Validate Apple IAP Receipt
      virtual void ValidatePurchaseApple(::grpc::ClientContext* context, const ::nakama::api::ValidatePurchaseAppleRequest* request, ::nakama::api::ValidatePurchaseResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ValidatePurchaseApple(::grpc::ClientContext* context, const ::nakama::api::ValidatePurchaseAppleRequest* request, ::nakama::api::ValidatePurchaseResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ValidatePurchaseApple(::grpc::ClientContext* context, const ::nakama::api::ValidatePurchaseAppleRequest* request, ::nakama::api::ValidatePurchaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Validate Google IAP Receipt
      virtual void ValidatePurchaseGoogle(::grpc::ClientContext* context, const ::nakama::api::ValidatePurchaseGoogleRequest* request, ::nakama::api::ValidatePurchaseResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ValidatePurchaseGoogle(::grpc::ClientContext* context, const ::nakama::api::ValidatePurchaseGoogleRequest* request, ::nakama::api::ValidatePurchaseResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ValidatePurchaseGoogle(::grpc::ClientContext* context, const ::nakama::api::ValidatePurchaseGoogleRequest* request, ::nakama::api::ValidatePurchaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Validate Huawei IAP Receipt
      virtual void ValidatePurchaseHuawei(::grpc::ClientContext* context, const ::nakama::api::ValidatePurchaseHuaweiRequest* request, ::nakama::api::ValidatePurchaseResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ValidatePurchaseHuawei(::grpc::ClientContext* context, const ::nakama::api::ValidatePurchaseHuaweiRequest* request, ::nakama::api::ValidatePurchaseResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ValidatePurchaseHuawei(::grpc::ClientContext* context, const ::nakama::api::ValidatePurchaseHuaweiRequest* request, ::nakama::api::ValidatePurchaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Write a record to a leaderboard.
      virtual void WriteLeaderboardRecord(::grpc::ClientContext* context, const ::nakama::api::WriteLeaderboardRecordRequest* request, ::nakama::api::LeaderboardRecord* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void WriteLeaderboardRecord(::grpc::ClientContext* context, const ::nakama::api::WriteLeaderboardRecordRequest* request, ::nakama::api::LeaderboardRecord* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void WriteLeaderboardRecord(::grpc::ClientContext* context, const ::nakama::api::WriteLeaderboardRecordRequest* request, ::nakama::api::LeaderboardRecord* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Write objects into the storage engine.
      virtual void WriteStorageObjects(::grpc::ClientContext* context, const ::nakama::api::WriteStorageObjectsRequest* request, ::nakama::api::StorageObjectAcks* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void WriteStorageObjects(::grpc::ClientContext* context, const ::nakama::api::WriteStorageObjectsRequest* request, ::nakama::api::StorageObjectAcks* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void WriteStorageObjects(::grpc::ClientContext* context, const ::nakama::api::WriteStorageObjectsRequest* request, ::nakama::api::StorageObjectAcks* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Write a record to a tournament.
      virtual void WriteTournamentRecord(::grpc::ClientContext* context, const ::nakama::api::WriteTournamentRecordRequest* request, ::nakama::api::LeaderboardRecord* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void WriteTournamentRecord(::grpc::ClientContext* context, const ::nakama::api::WriteTournamentRecordRequest* request, ::nakama::api::LeaderboardRecord* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void WriteTournamentRecord(::grpc::ClientContext* context, const ::nakama::api::WriteTournamentRecordRequest* request, ::nakama::api::LeaderboardRecord* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncAddFriendsRaw(::grpc::ClientContext* context, const ::nakama::api::AddFriendsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncAddFriendsRaw(::grpc::ClientContext* context, const ::nakama::api::AddFriendsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncAddGroupUsersRaw(::grpc::ClientContext* context, const ::nakama::api::AddGroupUsersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncAddGroupUsersRaw(::grpc::ClientContext* context, const ::nakama::api::AddGroupUsersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Session>* AsyncSessionRefreshRaw(::grpc::ClientContext* context, const ::nakama::api::SessionRefreshRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Session>* PrepareAsyncSessionRefreshRaw(::grpc::ClientContext* context, const ::nakama::api::SessionRefreshRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncSessionLogoutRaw(::grpc::ClientContext* context, const ::nakama::api::SessionLogoutRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncSessionLogoutRaw(::grpc::ClientContext* context, const ::nakama::api::SessionLogoutRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Session>* AsyncAuthenticateAppleRaw(::grpc::ClientContext* context, const ::nakama::api::AuthenticateAppleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Session>* PrepareAsyncAuthenticateAppleRaw(::grpc::ClientContext* context, const ::nakama::api::AuthenticateAppleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Session>* AsyncAuthenticateCustomRaw(::grpc::ClientContext* context, const ::nakama::api::AuthenticateCustomRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Session>* PrepareAsyncAuthenticateCustomRaw(::grpc::ClientContext* context, const ::nakama::api::AuthenticateCustomRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Session>* AsyncAuthenticateDeviceRaw(::grpc::ClientContext* context, const ::nakama::api::AuthenticateDeviceRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Session>* PrepareAsyncAuthenticateDeviceRaw(::grpc::ClientContext* context, const ::nakama::api::AuthenticateDeviceRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Session>* AsyncAuthenticateEmailRaw(::grpc::ClientContext* context, const ::nakama::api::AuthenticateEmailRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Session>* PrepareAsyncAuthenticateEmailRaw(::grpc::ClientContext* context, const ::nakama::api::AuthenticateEmailRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Session>* AsyncAuthenticateFacebookRaw(::grpc::ClientContext* context, const ::nakama::api::AuthenticateFacebookRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Session>* PrepareAsyncAuthenticateFacebookRaw(::grpc::ClientContext* context, const ::nakama::api::AuthenticateFacebookRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Session>* AsyncAuthenticateFacebookInstantGameRaw(::grpc::ClientContext* context, const ::nakama::api::AuthenticateFacebookInstantGameRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Session>* PrepareAsyncAuthenticateFacebookInstantGameRaw(::grpc::ClientContext* context, const ::nakama::api::AuthenticateFacebookInstantGameRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Session>* AsyncAuthenticateGameCenterRaw(::grpc::ClientContext* context, const ::nakama::api::AuthenticateGameCenterRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Session>* PrepareAsyncAuthenticateGameCenterRaw(::grpc::ClientContext* context, const ::nakama::api::AuthenticateGameCenterRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Session>* AsyncAuthenticateGoogleRaw(::grpc::ClientContext* context, const ::nakama::api::AuthenticateGoogleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Session>* PrepareAsyncAuthenticateGoogleRaw(::grpc::ClientContext* context, const ::nakama::api::AuthenticateGoogleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Session>* AsyncAuthenticateSteamRaw(::grpc::ClientContext* context, const ::nakama::api::AuthenticateSteamRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Session>* PrepareAsyncAuthenticateSteamRaw(::grpc::ClientContext* context, const ::nakama::api::AuthenticateSteamRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncBanGroupUsersRaw(::grpc::ClientContext* context, const ::nakama::api::BanGroupUsersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncBanGroupUsersRaw(::grpc::ClientContext* context, const ::nakama::api::BanGroupUsersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncBlockFriendsRaw(::grpc::ClientContext* context, const ::nakama::api::BlockFriendsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncBlockFriendsRaw(::grpc::ClientContext* context, const ::nakama::api::BlockFriendsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Group>* AsyncCreateGroupRaw(::grpc::ClientContext* context, const ::nakama::api::CreateGroupRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Group>* PrepareAsyncCreateGroupRaw(::grpc::ClientContext* context, const ::nakama::api::CreateGroupRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncDeleteFriendsRaw(::grpc::ClientContext* context, const ::nakama::api::DeleteFriendsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncDeleteFriendsRaw(::grpc::ClientContext* context, const ::nakama::api::DeleteFriendsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncDeleteGroupRaw(::grpc::ClientContext* context, const ::nakama::api::DeleteGroupRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncDeleteGroupRaw(::grpc::ClientContext* context, const ::nakama::api::DeleteGroupRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncDeleteLeaderboardRecordRaw(::grpc::ClientContext* context, const ::nakama::api::DeleteLeaderboardRecordRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncDeleteLeaderboardRecordRaw(::grpc::ClientContext* context, const ::nakama::api::DeleteLeaderboardRecordRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncDeleteNotificationsRaw(::grpc::ClientContext* context, const ::nakama::api::DeleteNotificationsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncDeleteNotificationsRaw(::grpc::ClientContext* context, const ::nakama::api::DeleteNotificationsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncDeleteStorageObjectsRaw(::grpc::ClientContext* context, const ::nakama::api::DeleteStorageObjectsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncDeleteStorageObjectsRaw(::grpc::ClientContext* context, const ::nakama::api::DeleteStorageObjectsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncEventRaw(::grpc::ClientContext* context, const ::nakama::api::Event& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncEventRaw(::grpc::ClientContext* context, const ::nakama::api::Event& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Account>* AsyncGetAccountRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Account>* PrepareAsyncGetAccountRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Users>* AsyncGetUsersRaw(::grpc::ClientContext* context, const ::nakama::api::GetUsersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Users>* PrepareAsyncGetUsersRaw(::grpc::ClientContext* context, const ::nakama::api::GetUsersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncHealthcheckRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncHealthcheckRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncImportFacebookFriendsRaw(::grpc::ClientContext* context, const ::nakama::api::ImportFacebookFriendsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncImportFacebookFriendsRaw(::grpc::ClientContext* context, const ::nakama::api::ImportFacebookFriendsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncImportSteamFriendsRaw(::grpc::ClientContext* context, const ::nakama::api::ImportSteamFriendsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncImportSteamFriendsRaw(::grpc::ClientContext* context, const ::nakama::api::ImportSteamFriendsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncJoinGroupRaw(::grpc::ClientContext* context, const ::nakama::api::JoinGroupRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncJoinGroupRaw(::grpc::ClientContext* context, const ::nakama::api::JoinGroupRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncJoinTournamentRaw(::grpc::ClientContext* context, const ::nakama::api::JoinTournamentRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncJoinTournamentRaw(::grpc::ClientContext* context, const ::nakama::api::JoinTournamentRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncKickGroupUsersRaw(::grpc::ClientContext* context, const ::nakama::api::KickGroupUsersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncKickGroupUsersRaw(::grpc::ClientContext* context, const ::nakama::api::KickGroupUsersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncLeaveGroupRaw(::grpc::ClientContext* context, const ::nakama::api::LeaveGroupRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncLeaveGroupRaw(::grpc::ClientContext* context, const ::nakama::api::LeaveGroupRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncLinkAppleRaw(::grpc::ClientContext* context, const ::nakama::api::AccountApple& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncLinkAppleRaw(::grpc::ClientContext* context, const ::nakama::api::AccountApple& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncLinkCustomRaw(::grpc::ClientContext* context, const ::nakama::api::AccountCustom& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncLinkCustomRaw(::grpc::ClientContext* context, const ::nakama::api::AccountCustom& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncLinkDeviceRaw(::grpc::ClientContext* context, const ::nakama::api::AccountDevice& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncLinkDeviceRaw(::grpc::ClientContext* context, const ::nakama::api::AccountDevice& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncLinkEmailRaw(::grpc::ClientContext* context, const ::nakama::api::AccountEmail& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncLinkEmailRaw(::grpc::ClientContext* context, const ::nakama::api::AccountEmail& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncLinkFacebookRaw(::grpc::ClientContext* context, const ::nakama::api::LinkFacebookRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncLinkFacebookRaw(::grpc::ClientContext* context, const ::nakama::api::LinkFacebookRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncLinkFacebookInstantGameRaw(::grpc::ClientContext* context, const ::nakama::api::AccountFacebookInstantGame& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncLinkFacebookInstantGameRaw(::grpc::ClientContext* context, const ::nakama::api::AccountFacebookInstantGame& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncLinkGameCenterRaw(::grpc::ClientContext* context, const ::nakama::api::AccountGameCenter& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncLinkGameCenterRaw(::grpc::ClientContext* context, const ::nakama::api::AccountGameCenter& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncLinkGoogleRaw(::grpc::ClientContext* context, const ::nakama::api::AccountGoogle& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncLinkGoogleRaw(::grpc::ClientContext* context, const ::nakama::api::AccountGoogle& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncLinkSteamRaw(::grpc::ClientContext* context, const ::nakama::api::LinkSteamRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncLinkSteamRaw(::grpc::ClientContext* context, const ::nakama::api::LinkSteamRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::ChannelMessageList>* AsyncListChannelMessagesRaw(::grpc::ClientContext* context, const ::nakama::api::ListChannelMessagesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::ChannelMessageList>* PrepareAsyncListChannelMessagesRaw(::grpc::ClientContext* context, const ::nakama::api::ListChannelMessagesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::FriendList>* AsyncListFriendsRaw(::grpc::ClientContext* context, const ::nakama::api::ListFriendsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::FriendList>* PrepareAsyncListFriendsRaw(::grpc::ClientContext* context, const ::nakama::api::ListFriendsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::GroupList>* AsyncListGroupsRaw(::grpc::ClientContext* context, const ::nakama::api::ListGroupsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::GroupList>* PrepareAsyncListGroupsRaw(::grpc::ClientContext* context, const ::nakama::api::ListGroupsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::GroupUserList>* AsyncListGroupUsersRaw(::grpc::ClientContext* context, const ::nakama::api::ListGroupUsersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::GroupUserList>* PrepareAsyncListGroupUsersRaw(::grpc::ClientContext* context, const ::nakama::api::ListGroupUsersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::LeaderboardRecordList>* AsyncListLeaderboardRecordsRaw(::grpc::ClientContext* context, const ::nakama::api::ListLeaderboardRecordsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::LeaderboardRecordList>* PrepareAsyncListLeaderboardRecordsRaw(::grpc::ClientContext* context, const ::nakama::api::ListLeaderboardRecordsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::LeaderboardRecordList>* AsyncListLeaderboardRecordsAroundOwnerRaw(::grpc::ClientContext* context, const ::nakama::api::ListLeaderboardRecordsAroundOwnerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::LeaderboardRecordList>* PrepareAsyncListLeaderboardRecordsAroundOwnerRaw(::grpc::ClientContext* context, const ::nakama::api::ListLeaderboardRecordsAroundOwnerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::MatchList>* AsyncListMatchesRaw(::grpc::ClientContext* context, const ::nakama::api::ListMatchesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::MatchList>* PrepareAsyncListMatchesRaw(::grpc::ClientContext* context, const ::nakama::api::ListMatchesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::NotificationList>* AsyncListNotificationsRaw(::grpc::ClientContext* context, const ::nakama::api::ListNotificationsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::NotificationList>* PrepareAsyncListNotificationsRaw(::grpc::ClientContext* context, const ::nakama::api::ListNotificationsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::StorageObjectList>* AsyncListStorageObjectsRaw(::grpc::ClientContext* context, const ::nakama::api::ListStorageObjectsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::StorageObjectList>* PrepareAsyncListStorageObjectsRaw(::grpc::ClientContext* context, const ::nakama::api::ListStorageObjectsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::TournamentList>* AsyncListTournamentsRaw(::grpc::ClientContext* context, const ::nakama::api::ListTournamentsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::TournamentList>* PrepareAsyncListTournamentsRaw(::grpc::ClientContext* context, const ::nakama::api::ListTournamentsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::TournamentRecordList>* AsyncListTournamentRecordsRaw(::grpc::ClientContext* context, const ::nakama::api::ListTournamentRecordsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::TournamentRecordList>* PrepareAsyncListTournamentRecordsRaw(::grpc::ClientContext* context, const ::nakama::api::ListTournamentRecordsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::TournamentRecordList>* AsyncListTournamentRecordsAroundOwnerRaw(::grpc::ClientContext* context, const ::nakama::api::ListTournamentRecordsAroundOwnerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::TournamentRecordList>* PrepareAsyncListTournamentRecordsAroundOwnerRaw(::grpc::ClientContext* context, const ::nakama::api::ListTournamentRecordsAroundOwnerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::UserGroupList>* AsyncListUserGroupsRaw(::grpc::ClientContext* context, const ::nakama::api::ListUserGroupsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::UserGroupList>* PrepareAsyncListUserGroupsRaw(::grpc::ClientContext* context, const ::nakama::api::ListUserGroupsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncPromoteGroupUsersRaw(::grpc::ClientContext* context, const ::nakama::api::PromoteGroupUsersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncPromoteGroupUsersRaw(::grpc::ClientContext* context, const ::nakama::api::PromoteGroupUsersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncDemoteGroupUsersRaw(::grpc::ClientContext* context, const ::nakama::api::DemoteGroupUsersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncDemoteGroupUsersRaw(::grpc::ClientContext* context, const ::nakama::api::DemoteGroupUsersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::StorageObjects>* AsyncReadStorageObjectsRaw(::grpc::ClientContext* context, const ::nakama::api::ReadStorageObjectsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::StorageObjects>* PrepareAsyncReadStorageObjectsRaw(::grpc::ClientContext* context, const ::nakama::api::ReadStorageObjectsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Rpc>* AsyncRpcFuncRaw(::grpc::ClientContext* context, const ::nakama::api::Rpc& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::Rpc>* PrepareAsyncRpcFuncRaw(::grpc::ClientContext* context, const ::nakama::api::Rpc& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncUnlinkAppleRaw(::grpc::ClientContext* context, const ::nakama::api::AccountApple& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncUnlinkAppleRaw(::grpc::ClientContext* context, const ::nakama::api::AccountApple& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncUnlinkCustomRaw(::grpc::ClientContext* context, const ::nakama::api::AccountCustom& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncUnlinkCustomRaw(::grpc::ClientContext* context, const ::nakama::api::AccountCustom& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncUnlinkDeviceRaw(::grpc::ClientContext* context, const ::nakama::api::AccountDevice& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncUnlinkDeviceRaw(::grpc::ClientContext* context, const ::nakama::api::AccountDevice& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncUnlinkEmailRaw(::grpc::ClientContext* context, const ::nakama::api::AccountEmail& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncUnlinkEmailRaw(::grpc::ClientContext* context, const ::nakama::api::AccountEmail& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncUnlinkFacebookRaw(::grpc::ClientContext* context, const ::nakama::api::AccountFacebook& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncUnlinkFacebookRaw(::grpc::ClientContext* context, const ::nakama::api::AccountFacebook& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncUnlinkFacebookInstantGameRaw(::grpc::ClientContext* context, const ::nakama::api::AccountFacebookInstantGame& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncUnlinkFacebookInstantGameRaw(::grpc::ClientContext* context, const ::nakama::api::AccountFacebookInstantGame& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncUnlinkGameCenterRaw(::grpc::ClientContext* context, const ::nakama::api::AccountGameCenter& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncUnlinkGameCenterRaw(::grpc::ClientContext* context, const ::nakama::api::AccountGameCenter& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncUnlinkGoogleRaw(::grpc::ClientContext* context, const ::nakama::api::AccountGoogle& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncUnlinkGoogleRaw(::grpc::ClientContext* context, const ::nakama::api::AccountGoogle& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncUnlinkSteamRaw(::grpc::ClientContext* context, const ::nakama::api::AccountSteam& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncUnlinkSteamRaw(::grpc::ClientContext* context, const ::nakama::api::AccountSteam& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncUpdateAccountRaw(::grpc::ClientContext* context, const ::nakama::api::UpdateAccountRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncUpdateAccountRaw(::grpc::ClientContext* context, const ::nakama::api::UpdateAccountRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncUpdateGroupRaw(::grpc::ClientContext* context, const ::nakama::api::UpdateGroupRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncUpdateGroupRaw(::grpc::ClientContext* context, const ::nakama::api::UpdateGroupRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::ValidatePurchaseResponse>* AsyncValidatePurchaseAppleRaw(::grpc::ClientContext* context, const ::nakama::api::ValidatePurchaseAppleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::ValidatePurchaseResponse>* PrepareAsyncValidatePurchaseAppleRaw(::grpc::ClientContext* context, const ::nakama::api::ValidatePurchaseAppleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::ValidatePurchaseResponse>* AsyncValidatePurchaseGoogleRaw(::grpc::ClientContext* context, const ::nakama::api::ValidatePurchaseGoogleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::ValidatePurchaseResponse>* PrepareAsyncValidatePurchaseGoogleRaw(::grpc::ClientContext* context, const ::nakama::api::ValidatePurchaseGoogleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::ValidatePurchaseResponse>* AsyncValidatePurchaseHuaweiRaw(::grpc::ClientContext* context, const ::nakama::api::ValidatePurchaseHuaweiRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::ValidatePurchaseResponse>* PrepareAsyncValidatePurchaseHuaweiRaw(::grpc::ClientContext* context, const ::nakama::api::ValidatePurchaseHuaweiRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::LeaderboardRecord>* AsyncWriteLeaderboardRecordRaw(::grpc::ClientContext* context, const ::nakama::api::WriteLeaderboardRecordRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::LeaderboardRecord>* PrepareAsyncWriteLeaderboardRecordRaw(::grpc::ClientContext* context, const ::nakama::api::WriteLeaderboardRecordRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::StorageObjectAcks>* AsyncWriteStorageObjectsRaw(::grpc::ClientContext* context, const ::nakama::api::WriteStorageObjectsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::StorageObjectAcks>* PrepareAsyncWriteStorageObjectsRaw(::grpc::ClientContext* context, const ::nakama::api::WriteStorageObjectsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::LeaderboardRecord>* AsyncWriteTournamentRecordRaw(::grpc::ClientContext* context, const ::nakama::api::WriteTournamentRecordRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::nakama::api::LeaderboardRecord>* PrepareAsyncWriteTournamentRecordRaw(::grpc::ClientContext* context, const ::nakama::api::WriteTournamentRecordRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status AddFriends(::grpc::ClientContext* context, const ::nakama::api::AddFriendsRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncAddFriends(::grpc::ClientContext* context, const ::nakama::api::AddFriendsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncAddFriendsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncAddFriends(::grpc::ClientContext* context, const ::nakama::api::AddFriendsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncAddFriendsRaw(context, request, cq));
    }
    ::grpc::Status AddGroupUsers(::grpc::ClientContext* context, const ::nakama::api::AddGroupUsersRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncAddGroupUsers(::grpc::ClientContext* context, const ::nakama::api::AddGroupUsersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncAddGroupUsersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncAddGroupUsers(::grpc::ClientContext* context, const ::nakama::api::AddGroupUsersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncAddGroupUsersRaw(context, request, cq));
    }
    ::grpc::Status SessionRefresh(::grpc::ClientContext* context, const ::nakama::api::SessionRefreshRequest& request, ::nakama::api::Session* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::Session>> AsyncSessionRefresh(::grpc::ClientContext* context, const ::nakama::api::SessionRefreshRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::Session>>(AsyncSessionRefreshRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::Session>> PrepareAsyncSessionRefresh(::grpc::ClientContext* context, const ::nakama::api::SessionRefreshRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::Session>>(PrepareAsyncSessionRefreshRaw(context, request, cq));
    }
    ::grpc::Status SessionLogout(::grpc::ClientContext* context, const ::nakama::api::SessionLogoutRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncSessionLogout(::grpc::ClientContext* context, const ::nakama::api::SessionLogoutRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncSessionLogoutRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncSessionLogout(::grpc::ClientContext* context, const ::nakama::api::SessionLogoutRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncSessionLogoutRaw(context, request, cq));
    }
    ::grpc::Status AuthenticateApple(::grpc::ClientContext* context, const ::nakama::api::AuthenticateAppleRequest& request, ::nakama::api::Session* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::Session>> AsyncAuthenticateApple(::grpc::ClientContext* context, const ::nakama::api::AuthenticateAppleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::Session>>(AsyncAuthenticateAppleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::Session>> PrepareAsyncAuthenticateApple(::grpc::ClientContext* context, const ::nakama::api::AuthenticateAppleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::Session>>(PrepareAsyncAuthenticateAppleRaw(context, request, cq));
    }
    ::grpc::Status AuthenticateCustom(::grpc::ClientContext* context, const ::nakama::api::AuthenticateCustomRequest& request, ::nakama::api::Session* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::Session>> AsyncAuthenticateCustom(::grpc::ClientContext* context, const ::nakama::api::AuthenticateCustomRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::Session>>(AsyncAuthenticateCustomRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::Session>> PrepareAsyncAuthenticateCustom(::grpc::ClientContext* context, const ::nakama::api::AuthenticateCustomRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::Session>>(PrepareAsyncAuthenticateCustomRaw(context, request, cq));
    }
    ::grpc::Status AuthenticateDevice(::grpc::ClientContext* context, const ::nakama::api::AuthenticateDeviceRequest& request, ::nakama::api::Session* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::Session>> AsyncAuthenticateDevice(::grpc::ClientContext* context, const ::nakama::api::AuthenticateDeviceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::Session>>(AsyncAuthenticateDeviceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::Session>> PrepareAsyncAuthenticateDevice(::grpc::ClientContext* context, const ::nakama::api::AuthenticateDeviceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::Session>>(PrepareAsyncAuthenticateDeviceRaw(context, request, cq));
    }
    ::grpc::Status AuthenticateEmail(::grpc::ClientContext* context, const ::nakama::api::AuthenticateEmailRequest& request, ::nakama::api::Session* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::Session>> AsyncAuthenticateEmail(::grpc::ClientContext* context, const ::nakama::api::AuthenticateEmailRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::Session>>(AsyncAuthenticateEmailRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::Session>> PrepareAsyncAuthenticateEmail(::grpc::ClientContext* context, const ::nakama::api::AuthenticateEmailRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::Session>>(PrepareAsyncAuthenticateEmailRaw(context, request, cq));
    }
    ::grpc::Status AuthenticateFacebook(::grpc::ClientContext* context, const ::nakama::api::AuthenticateFacebookRequest& request, ::nakama::api::Session* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::Session>> AsyncAuthenticateFacebook(::grpc::ClientContext* context, const ::nakama::api::AuthenticateFacebookRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::Session>>(AsyncAuthenticateFacebookRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::Session>> PrepareAsyncAuthenticateFacebook(::grpc::ClientContext* context, const ::nakama::api::AuthenticateFacebookRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::Session>>(PrepareAsyncAuthenticateFacebookRaw(context, request, cq));
    }
    ::grpc::Status AuthenticateFacebookInstantGame(::grpc::ClientContext* context, const ::nakama::api::AuthenticateFacebookInstantGameRequest& request, ::nakama::api::Session* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::Session>> AsyncAuthenticateFacebookInstantGame(::grpc::ClientContext* context, const ::nakama::api::AuthenticateFacebookInstantGameRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::Session>>(AsyncAuthenticateFacebookInstantGameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::Session>> PrepareAsyncAuthenticateFacebookInstantGame(::grpc::ClientContext* context, const ::nakama::api::AuthenticateFacebookInstantGameRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::Session>>(PrepareAsyncAuthenticateFacebookInstantGameRaw(context, request, cq));
    }
    ::grpc::Status AuthenticateGameCenter(::grpc::ClientContext* context, const ::nakama::api::AuthenticateGameCenterRequest& request, ::nakama::api::Session* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::Session>> AsyncAuthenticateGameCenter(::grpc::ClientContext* context, const ::nakama::api::AuthenticateGameCenterRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::Session>>(AsyncAuthenticateGameCenterRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::Session>> PrepareAsyncAuthenticateGameCenter(::grpc::ClientContext* context, const ::nakama::api::AuthenticateGameCenterRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::Session>>(PrepareAsyncAuthenticateGameCenterRaw(context, request, cq));
    }
    ::grpc::Status AuthenticateGoogle(::grpc::ClientContext* context, const ::nakama::api::AuthenticateGoogleRequest& request, ::nakama::api::Session* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::Session>> AsyncAuthenticateGoogle(::grpc::ClientContext* context, const ::nakama::api::AuthenticateGoogleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::Session>>(AsyncAuthenticateGoogleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::Session>> PrepareAsyncAuthenticateGoogle(::grpc::ClientContext* context, const ::nakama::api::AuthenticateGoogleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::Session>>(PrepareAsyncAuthenticateGoogleRaw(context, request, cq));
    }
    ::grpc::Status AuthenticateSteam(::grpc::ClientContext* context, const ::nakama::api::AuthenticateSteamRequest& request, ::nakama::api::Session* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::Session>> AsyncAuthenticateSteam(::grpc::ClientContext* context, const ::nakama::api::AuthenticateSteamRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::Session>>(AsyncAuthenticateSteamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::Session>> PrepareAsyncAuthenticateSteam(::grpc::ClientContext* context, const ::nakama::api::AuthenticateSteamRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::Session>>(PrepareAsyncAuthenticateSteamRaw(context, request, cq));
    }
    ::grpc::Status BanGroupUsers(::grpc::ClientContext* context, const ::nakama::api::BanGroupUsersRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncBanGroupUsers(::grpc::ClientContext* context, const ::nakama::api::BanGroupUsersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncBanGroupUsersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncBanGroupUsers(::grpc::ClientContext* context, const ::nakama::api::BanGroupUsersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncBanGroupUsersRaw(context, request, cq));
    }
    ::grpc::Status BlockFriends(::grpc::ClientContext* context, const ::nakama::api::BlockFriendsRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncBlockFriends(::grpc::ClientContext* context, const ::nakama::api::BlockFriendsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncBlockFriendsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncBlockFriends(::grpc::ClientContext* context, const ::nakama::api::BlockFriendsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncBlockFriendsRaw(context, request, cq));
    }
    ::grpc::Status CreateGroup(::grpc::ClientContext* context, const ::nakama::api::CreateGroupRequest& request, ::nakama::api::Group* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::Group>> AsyncCreateGroup(::grpc::ClientContext* context, const ::nakama::api::CreateGroupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::Group>>(AsyncCreateGroupRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::Group>> PrepareAsyncCreateGroup(::grpc::ClientContext* context, const ::nakama::api::CreateGroupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::Group>>(PrepareAsyncCreateGroupRaw(context, request, cq));
    }
    ::grpc::Status DeleteFriends(::grpc::ClientContext* context, const ::nakama::api::DeleteFriendsRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncDeleteFriends(::grpc::ClientContext* context, const ::nakama::api::DeleteFriendsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncDeleteFriendsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncDeleteFriends(::grpc::ClientContext* context, const ::nakama::api::DeleteFriendsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncDeleteFriendsRaw(context, request, cq));
    }
    ::grpc::Status DeleteGroup(::grpc::ClientContext* context, const ::nakama::api::DeleteGroupRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncDeleteGroup(::grpc::ClientContext* context, const ::nakama::api::DeleteGroupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncDeleteGroupRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncDeleteGroup(::grpc::ClientContext* context, const ::nakama::api::DeleteGroupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncDeleteGroupRaw(context, request, cq));
    }
    ::grpc::Status DeleteLeaderboardRecord(::grpc::ClientContext* context, const ::nakama::api::DeleteLeaderboardRecordRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncDeleteLeaderboardRecord(::grpc::ClientContext* context, const ::nakama::api::DeleteLeaderboardRecordRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncDeleteLeaderboardRecordRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncDeleteLeaderboardRecord(::grpc::ClientContext* context, const ::nakama::api::DeleteLeaderboardRecordRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncDeleteLeaderboardRecordRaw(context, request, cq));
    }
    ::grpc::Status DeleteNotifications(::grpc::ClientContext* context, const ::nakama::api::DeleteNotificationsRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncDeleteNotifications(::grpc::ClientContext* context, const ::nakama::api::DeleteNotificationsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncDeleteNotificationsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncDeleteNotifications(::grpc::ClientContext* context, const ::nakama::api::DeleteNotificationsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncDeleteNotificationsRaw(context, request, cq));
    }
    ::grpc::Status DeleteStorageObjects(::grpc::ClientContext* context, const ::nakama::api::DeleteStorageObjectsRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncDeleteStorageObjects(::grpc::ClientContext* context, const ::nakama::api::DeleteStorageObjectsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncDeleteStorageObjectsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncDeleteStorageObjects(::grpc::ClientContext* context, const ::nakama::api::DeleteStorageObjectsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncDeleteStorageObjectsRaw(context, request, cq));
    }
    ::grpc::Status Event(::grpc::ClientContext* context, const ::nakama::api::Event& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncEvent(::grpc::ClientContext* context, const ::nakama::api::Event& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncEventRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncEvent(::grpc::ClientContext* context, const ::nakama::api::Event& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncEventRaw(context, request, cq));
    }
    ::grpc::Status GetAccount(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::nakama::api::Account* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::Account>> AsyncGetAccount(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::Account>>(AsyncGetAccountRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::Account>> PrepareAsyncGetAccount(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::Account>>(PrepareAsyncGetAccountRaw(context, request, cq));
    }
    ::grpc::Status GetUsers(::grpc::ClientContext* context, const ::nakama::api::GetUsersRequest& request, ::nakama::api::Users* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::Users>> AsyncGetUsers(::grpc::ClientContext* context, const ::nakama::api::GetUsersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::Users>>(AsyncGetUsersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::Users>> PrepareAsyncGetUsers(::grpc::ClientContext* context, const ::nakama::api::GetUsersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::Users>>(PrepareAsyncGetUsersRaw(context, request, cq));
    }
    ::grpc::Status Healthcheck(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncHealthcheck(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncHealthcheckRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncHealthcheck(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncHealthcheckRaw(context, request, cq));
    }
    ::grpc::Status ImportFacebookFriends(::grpc::ClientContext* context, const ::nakama::api::ImportFacebookFriendsRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncImportFacebookFriends(::grpc::ClientContext* context, const ::nakama::api::ImportFacebookFriendsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncImportFacebookFriendsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncImportFacebookFriends(::grpc::ClientContext* context, const ::nakama::api::ImportFacebookFriendsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncImportFacebookFriendsRaw(context, request, cq));
    }
    ::grpc::Status ImportSteamFriends(::grpc::ClientContext* context, const ::nakama::api::ImportSteamFriendsRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncImportSteamFriends(::grpc::ClientContext* context, const ::nakama::api::ImportSteamFriendsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncImportSteamFriendsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncImportSteamFriends(::grpc::ClientContext* context, const ::nakama::api::ImportSteamFriendsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncImportSteamFriendsRaw(context, request, cq));
    }
    ::grpc::Status JoinGroup(::grpc::ClientContext* context, const ::nakama::api::JoinGroupRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncJoinGroup(::grpc::ClientContext* context, const ::nakama::api::JoinGroupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncJoinGroupRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncJoinGroup(::grpc::ClientContext* context, const ::nakama::api::JoinGroupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncJoinGroupRaw(context, request, cq));
    }
    ::grpc::Status JoinTournament(::grpc::ClientContext* context, const ::nakama::api::JoinTournamentRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncJoinTournament(::grpc::ClientContext* context, const ::nakama::api::JoinTournamentRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncJoinTournamentRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncJoinTournament(::grpc::ClientContext* context, const ::nakama::api::JoinTournamentRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncJoinTournamentRaw(context, request, cq));
    }
    ::grpc::Status KickGroupUsers(::grpc::ClientContext* context, const ::nakama::api::KickGroupUsersRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncKickGroupUsers(::grpc::ClientContext* context, const ::nakama::api::KickGroupUsersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncKickGroupUsersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncKickGroupUsers(::grpc::ClientContext* context, const ::nakama::api::KickGroupUsersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncKickGroupUsersRaw(context, request, cq));
    }
    ::grpc::Status LeaveGroup(::grpc::ClientContext* context, const ::nakama::api::LeaveGroupRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncLeaveGroup(::grpc::ClientContext* context, const ::nakama::api::LeaveGroupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncLeaveGroupRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncLeaveGroup(::grpc::ClientContext* context, const ::nakama::api::LeaveGroupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncLeaveGroupRaw(context, request, cq));
    }
    ::grpc::Status LinkApple(::grpc::ClientContext* context, const ::nakama::api::AccountApple& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncLinkApple(::grpc::ClientContext* context, const ::nakama::api::AccountApple& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncLinkAppleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncLinkApple(::grpc::ClientContext* context, const ::nakama::api::AccountApple& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncLinkAppleRaw(context, request, cq));
    }
    ::grpc::Status LinkCustom(::grpc::ClientContext* context, const ::nakama::api::AccountCustom& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncLinkCustom(::grpc::ClientContext* context, const ::nakama::api::AccountCustom& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncLinkCustomRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncLinkCustom(::grpc::ClientContext* context, const ::nakama::api::AccountCustom& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncLinkCustomRaw(context, request, cq));
    }
    ::grpc::Status LinkDevice(::grpc::ClientContext* context, const ::nakama::api::AccountDevice& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncLinkDevice(::grpc::ClientContext* context, const ::nakama::api::AccountDevice& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncLinkDeviceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncLinkDevice(::grpc::ClientContext* context, const ::nakama::api::AccountDevice& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncLinkDeviceRaw(context, request, cq));
    }
    ::grpc::Status LinkEmail(::grpc::ClientContext* context, const ::nakama::api::AccountEmail& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncLinkEmail(::grpc::ClientContext* context, const ::nakama::api::AccountEmail& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncLinkEmailRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncLinkEmail(::grpc::ClientContext* context, const ::nakama::api::AccountEmail& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncLinkEmailRaw(context, request, cq));
    }
    ::grpc::Status LinkFacebook(::grpc::ClientContext* context, const ::nakama::api::LinkFacebookRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncLinkFacebook(::grpc::ClientContext* context, const ::nakama::api::LinkFacebookRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncLinkFacebookRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncLinkFacebook(::grpc::ClientContext* context, const ::nakama::api::LinkFacebookRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncLinkFacebookRaw(context, request, cq));
    }
    ::grpc::Status LinkFacebookInstantGame(::grpc::ClientContext* context, const ::nakama::api::AccountFacebookInstantGame& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncLinkFacebookInstantGame(::grpc::ClientContext* context, const ::nakama::api::AccountFacebookInstantGame& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncLinkFacebookInstantGameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncLinkFacebookInstantGame(::grpc::ClientContext* context, const ::nakama::api::AccountFacebookInstantGame& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncLinkFacebookInstantGameRaw(context, request, cq));
    }
    ::grpc::Status LinkGameCenter(::grpc::ClientContext* context, const ::nakama::api::AccountGameCenter& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncLinkGameCenter(::grpc::ClientContext* context, const ::nakama::api::AccountGameCenter& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncLinkGameCenterRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncLinkGameCenter(::grpc::ClientContext* context, const ::nakama::api::AccountGameCenter& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncLinkGameCenterRaw(context, request, cq));
    }
    ::grpc::Status LinkGoogle(::grpc::ClientContext* context, const ::nakama::api::AccountGoogle& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncLinkGoogle(::grpc::ClientContext* context, const ::nakama::api::AccountGoogle& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncLinkGoogleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncLinkGoogle(::grpc::ClientContext* context, const ::nakama::api::AccountGoogle& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncLinkGoogleRaw(context, request, cq));
    }
    ::grpc::Status LinkSteam(::grpc::ClientContext* context, const ::nakama::api::LinkSteamRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncLinkSteam(::grpc::ClientContext* context, const ::nakama::api::LinkSteamRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncLinkSteamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncLinkSteam(::grpc::ClientContext* context, const ::nakama::api::LinkSteamRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncLinkSteamRaw(context, request, cq));
    }
    ::grpc::Status ListChannelMessages(::grpc::ClientContext* context, const ::nakama::api::ListChannelMessagesRequest& request, ::nakama::api::ChannelMessageList* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::ChannelMessageList>> AsyncListChannelMessages(::grpc::ClientContext* context, const ::nakama::api::ListChannelMessagesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::ChannelMessageList>>(AsyncListChannelMessagesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::ChannelMessageList>> PrepareAsyncListChannelMessages(::grpc::ClientContext* context, const ::nakama::api::ListChannelMessagesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::ChannelMessageList>>(PrepareAsyncListChannelMessagesRaw(context, request, cq));
    }
    ::grpc::Status ListFriends(::grpc::ClientContext* context, const ::nakama::api::ListFriendsRequest& request, ::nakama::api::FriendList* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::FriendList>> AsyncListFriends(::grpc::ClientContext* context, const ::nakama::api::ListFriendsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::FriendList>>(AsyncListFriendsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::FriendList>> PrepareAsyncListFriends(::grpc::ClientContext* context, const ::nakama::api::ListFriendsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::FriendList>>(PrepareAsyncListFriendsRaw(context, request, cq));
    }
    ::grpc::Status ListGroups(::grpc::ClientContext* context, const ::nakama::api::ListGroupsRequest& request, ::nakama::api::GroupList* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::GroupList>> AsyncListGroups(::grpc::ClientContext* context, const ::nakama::api::ListGroupsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::GroupList>>(AsyncListGroupsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::GroupList>> PrepareAsyncListGroups(::grpc::ClientContext* context, const ::nakama::api::ListGroupsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::GroupList>>(PrepareAsyncListGroupsRaw(context, request, cq));
    }
    ::grpc::Status ListGroupUsers(::grpc::ClientContext* context, const ::nakama::api::ListGroupUsersRequest& request, ::nakama::api::GroupUserList* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::GroupUserList>> AsyncListGroupUsers(::grpc::ClientContext* context, const ::nakama::api::ListGroupUsersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::GroupUserList>>(AsyncListGroupUsersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::GroupUserList>> PrepareAsyncListGroupUsers(::grpc::ClientContext* context, const ::nakama::api::ListGroupUsersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::GroupUserList>>(PrepareAsyncListGroupUsersRaw(context, request, cq));
    }
    ::grpc::Status ListLeaderboardRecords(::grpc::ClientContext* context, const ::nakama::api::ListLeaderboardRecordsRequest& request, ::nakama::api::LeaderboardRecordList* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::LeaderboardRecordList>> AsyncListLeaderboardRecords(::grpc::ClientContext* context, const ::nakama::api::ListLeaderboardRecordsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::LeaderboardRecordList>>(AsyncListLeaderboardRecordsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::LeaderboardRecordList>> PrepareAsyncListLeaderboardRecords(::grpc::ClientContext* context, const ::nakama::api::ListLeaderboardRecordsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::LeaderboardRecordList>>(PrepareAsyncListLeaderboardRecordsRaw(context, request, cq));
    }
    ::grpc::Status ListLeaderboardRecordsAroundOwner(::grpc::ClientContext* context, const ::nakama::api::ListLeaderboardRecordsAroundOwnerRequest& request, ::nakama::api::LeaderboardRecordList* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::LeaderboardRecordList>> AsyncListLeaderboardRecordsAroundOwner(::grpc::ClientContext* context, const ::nakama::api::ListLeaderboardRecordsAroundOwnerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::LeaderboardRecordList>>(AsyncListLeaderboardRecordsAroundOwnerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::LeaderboardRecordList>> PrepareAsyncListLeaderboardRecordsAroundOwner(::grpc::ClientContext* context, const ::nakama::api::ListLeaderboardRecordsAroundOwnerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::LeaderboardRecordList>>(PrepareAsyncListLeaderboardRecordsAroundOwnerRaw(context, request, cq));
    }
    ::grpc::Status ListMatches(::grpc::ClientContext* context, const ::nakama::api::ListMatchesRequest& request, ::nakama::api::MatchList* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::MatchList>> AsyncListMatches(::grpc::ClientContext* context, const ::nakama::api::ListMatchesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::MatchList>>(AsyncListMatchesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::MatchList>> PrepareAsyncListMatches(::grpc::ClientContext* context, const ::nakama::api::ListMatchesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::MatchList>>(PrepareAsyncListMatchesRaw(context, request, cq));
    }
    ::grpc::Status ListNotifications(::grpc::ClientContext* context, const ::nakama::api::ListNotificationsRequest& request, ::nakama::api::NotificationList* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::NotificationList>> AsyncListNotifications(::grpc::ClientContext* context, const ::nakama::api::ListNotificationsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::NotificationList>>(AsyncListNotificationsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::NotificationList>> PrepareAsyncListNotifications(::grpc::ClientContext* context, const ::nakama::api::ListNotificationsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::NotificationList>>(PrepareAsyncListNotificationsRaw(context, request, cq));
    }
    ::grpc::Status ListStorageObjects(::grpc::ClientContext* context, const ::nakama::api::ListStorageObjectsRequest& request, ::nakama::api::StorageObjectList* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::StorageObjectList>> AsyncListStorageObjects(::grpc::ClientContext* context, const ::nakama::api::ListStorageObjectsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::StorageObjectList>>(AsyncListStorageObjectsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::StorageObjectList>> PrepareAsyncListStorageObjects(::grpc::ClientContext* context, const ::nakama::api::ListStorageObjectsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::StorageObjectList>>(PrepareAsyncListStorageObjectsRaw(context, request, cq));
    }
    ::grpc::Status ListTournaments(::grpc::ClientContext* context, const ::nakama::api::ListTournamentsRequest& request, ::nakama::api::TournamentList* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::TournamentList>> AsyncListTournaments(::grpc::ClientContext* context, const ::nakama::api::ListTournamentsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::TournamentList>>(AsyncListTournamentsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::TournamentList>> PrepareAsyncListTournaments(::grpc::ClientContext* context, const ::nakama::api::ListTournamentsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::TournamentList>>(PrepareAsyncListTournamentsRaw(context, request, cq));
    }
    ::grpc::Status ListTournamentRecords(::grpc::ClientContext* context, const ::nakama::api::ListTournamentRecordsRequest& request, ::nakama::api::TournamentRecordList* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::TournamentRecordList>> AsyncListTournamentRecords(::grpc::ClientContext* context, const ::nakama::api::ListTournamentRecordsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::TournamentRecordList>>(AsyncListTournamentRecordsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::TournamentRecordList>> PrepareAsyncListTournamentRecords(::grpc::ClientContext* context, const ::nakama::api::ListTournamentRecordsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::TournamentRecordList>>(PrepareAsyncListTournamentRecordsRaw(context, request, cq));
    }
    ::grpc::Status ListTournamentRecordsAroundOwner(::grpc::ClientContext* context, const ::nakama::api::ListTournamentRecordsAroundOwnerRequest& request, ::nakama::api::TournamentRecordList* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::TournamentRecordList>> AsyncListTournamentRecordsAroundOwner(::grpc::ClientContext* context, const ::nakama::api::ListTournamentRecordsAroundOwnerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::TournamentRecordList>>(AsyncListTournamentRecordsAroundOwnerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::TournamentRecordList>> PrepareAsyncListTournamentRecordsAroundOwner(::grpc::ClientContext* context, const ::nakama::api::ListTournamentRecordsAroundOwnerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::TournamentRecordList>>(PrepareAsyncListTournamentRecordsAroundOwnerRaw(context, request, cq));
    }
    ::grpc::Status ListUserGroups(::grpc::ClientContext* context, const ::nakama::api::ListUserGroupsRequest& request, ::nakama::api::UserGroupList* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::UserGroupList>> AsyncListUserGroups(::grpc::ClientContext* context, const ::nakama::api::ListUserGroupsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::UserGroupList>>(AsyncListUserGroupsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::UserGroupList>> PrepareAsyncListUserGroups(::grpc::ClientContext* context, const ::nakama::api::ListUserGroupsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::UserGroupList>>(PrepareAsyncListUserGroupsRaw(context, request, cq));
    }
    ::grpc::Status PromoteGroupUsers(::grpc::ClientContext* context, const ::nakama::api::PromoteGroupUsersRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncPromoteGroupUsers(::grpc::ClientContext* context, const ::nakama::api::PromoteGroupUsersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncPromoteGroupUsersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncPromoteGroupUsers(::grpc::ClientContext* context, const ::nakama::api::PromoteGroupUsersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncPromoteGroupUsersRaw(context, request, cq));
    }
    ::grpc::Status DemoteGroupUsers(::grpc::ClientContext* context, const ::nakama::api::DemoteGroupUsersRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncDemoteGroupUsers(::grpc::ClientContext* context, const ::nakama::api::DemoteGroupUsersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncDemoteGroupUsersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncDemoteGroupUsers(::grpc::ClientContext* context, const ::nakama::api::DemoteGroupUsersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncDemoteGroupUsersRaw(context, request, cq));
    }
    ::grpc::Status ReadStorageObjects(::grpc::ClientContext* context, const ::nakama::api::ReadStorageObjectsRequest& request, ::nakama::api::StorageObjects* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::StorageObjects>> AsyncReadStorageObjects(::grpc::ClientContext* context, const ::nakama::api::ReadStorageObjectsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::StorageObjects>>(AsyncReadStorageObjectsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::StorageObjects>> PrepareAsyncReadStorageObjects(::grpc::ClientContext* context, const ::nakama::api::ReadStorageObjectsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::StorageObjects>>(PrepareAsyncReadStorageObjectsRaw(context, request, cq));
    }
    ::grpc::Status RpcFunc(::grpc::ClientContext* context, const ::nakama::api::Rpc& request, ::nakama::api::Rpc* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::Rpc>> AsyncRpcFunc(::grpc::ClientContext* context, const ::nakama::api::Rpc& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::Rpc>>(AsyncRpcFuncRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::Rpc>> PrepareAsyncRpcFunc(::grpc::ClientContext* context, const ::nakama::api::Rpc& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::Rpc>>(PrepareAsyncRpcFuncRaw(context, request, cq));
    }
    ::grpc::Status UnlinkApple(::grpc::ClientContext* context, const ::nakama::api::AccountApple& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncUnlinkApple(::grpc::ClientContext* context, const ::nakama::api::AccountApple& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncUnlinkAppleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncUnlinkApple(::grpc::ClientContext* context, const ::nakama::api::AccountApple& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncUnlinkAppleRaw(context, request, cq));
    }
    ::grpc::Status UnlinkCustom(::grpc::ClientContext* context, const ::nakama::api::AccountCustom& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncUnlinkCustom(::grpc::ClientContext* context, const ::nakama::api::AccountCustom& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncUnlinkCustomRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncUnlinkCustom(::grpc::ClientContext* context, const ::nakama::api::AccountCustom& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncUnlinkCustomRaw(context, request, cq));
    }
    ::grpc::Status UnlinkDevice(::grpc::ClientContext* context, const ::nakama::api::AccountDevice& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncUnlinkDevice(::grpc::ClientContext* context, const ::nakama::api::AccountDevice& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncUnlinkDeviceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncUnlinkDevice(::grpc::ClientContext* context, const ::nakama::api::AccountDevice& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncUnlinkDeviceRaw(context, request, cq));
    }
    ::grpc::Status UnlinkEmail(::grpc::ClientContext* context, const ::nakama::api::AccountEmail& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncUnlinkEmail(::grpc::ClientContext* context, const ::nakama::api::AccountEmail& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncUnlinkEmailRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncUnlinkEmail(::grpc::ClientContext* context, const ::nakama::api::AccountEmail& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncUnlinkEmailRaw(context, request, cq));
    }
    ::grpc::Status UnlinkFacebook(::grpc::ClientContext* context, const ::nakama::api::AccountFacebook& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncUnlinkFacebook(::grpc::ClientContext* context, const ::nakama::api::AccountFacebook& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncUnlinkFacebookRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncUnlinkFacebook(::grpc::ClientContext* context, const ::nakama::api::AccountFacebook& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncUnlinkFacebookRaw(context, request, cq));
    }
    ::grpc::Status UnlinkFacebookInstantGame(::grpc::ClientContext* context, const ::nakama::api::AccountFacebookInstantGame& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncUnlinkFacebookInstantGame(::grpc::ClientContext* context, const ::nakama::api::AccountFacebookInstantGame& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncUnlinkFacebookInstantGameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncUnlinkFacebookInstantGame(::grpc::ClientContext* context, const ::nakama::api::AccountFacebookInstantGame& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncUnlinkFacebookInstantGameRaw(context, request, cq));
    }
    ::grpc::Status UnlinkGameCenter(::grpc::ClientContext* context, const ::nakama::api::AccountGameCenter& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncUnlinkGameCenter(::grpc::ClientContext* context, const ::nakama::api::AccountGameCenter& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncUnlinkGameCenterRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncUnlinkGameCenter(::grpc::ClientContext* context, const ::nakama::api::AccountGameCenter& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncUnlinkGameCenterRaw(context, request, cq));
    }
    ::grpc::Status UnlinkGoogle(::grpc::ClientContext* context, const ::nakama::api::AccountGoogle& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncUnlinkGoogle(::grpc::ClientContext* context, const ::nakama::api::AccountGoogle& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncUnlinkGoogleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncUnlinkGoogle(::grpc::ClientContext* context, const ::nakama::api::AccountGoogle& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncUnlinkGoogleRaw(context, request, cq));
    }
    ::grpc::Status UnlinkSteam(::grpc::ClientContext* context, const ::nakama::api::AccountSteam& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncUnlinkSteam(::grpc::ClientContext* context, const ::nakama::api::AccountSteam& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncUnlinkSteamRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncUnlinkSteam(::grpc::ClientContext* context, const ::nakama::api::AccountSteam& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncUnlinkSteamRaw(context, request, cq));
    }
    ::grpc::Status UpdateAccount(::grpc::ClientContext* context, const ::nakama::api::UpdateAccountRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncUpdateAccount(::grpc::ClientContext* context, const ::nakama::api::UpdateAccountRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncUpdateAccountRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncUpdateAccount(::grpc::ClientContext* context, const ::nakama::api::UpdateAccountRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncUpdateAccountRaw(context, request, cq));
    }
    ::grpc::Status UpdateGroup(::grpc::ClientContext* context, const ::nakama::api::UpdateGroupRequest& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncUpdateGroup(::grpc::ClientContext* context, const ::nakama::api::UpdateGroupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncUpdateGroupRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncUpdateGroup(::grpc::ClientContext* context, const ::nakama::api::UpdateGroupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncUpdateGroupRaw(context, request, cq));
    }
    ::grpc::Status ValidatePurchaseApple(::grpc::ClientContext* context, const ::nakama::api::ValidatePurchaseAppleRequest& request, ::nakama::api::ValidatePurchaseResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::ValidatePurchaseResponse>> AsyncValidatePurchaseApple(::grpc::ClientContext* context, const ::nakama::api::ValidatePurchaseAppleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::ValidatePurchaseResponse>>(AsyncValidatePurchaseAppleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::ValidatePurchaseResponse>> PrepareAsyncValidatePurchaseApple(::grpc::ClientContext* context, const ::nakama::api::ValidatePurchaseAppleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::ValidatePurchaseResponse>>(PrepareAsyncValidatePurchaseAppleRaw(context, request, cq));
    }
    ::grpc::Status ValidatePurchaseGoogle(::grpc::ClientContext* context, const ::nakama::api::ValidatePurchaseGoogleRequest& request, ::nakama::api::ValidatePurchaseResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::ValidatePurchaseResponse>> AsyncValidatePurchaseGoogle(::grpc::ClientContext* context, const ::nakama::api::ValidatePurchaseGoogleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::ValidatePurchaseResponse>>(AsyncValidatePurchaseGoogleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::ValidatePurchaseResponse>> PrepareAsyncValidatePurchaseGoogle(::grpc::ClientContext* context, const ::nakama::api::ValidatePurchaseGoogleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::ValidatePurchaseResponse>>(PrepareAsyncValidatePurchaseGoogleRaw(context, request, cq));
    }
    ::grpc::Status ValidatePurchaseHuawei(::grpc::ClientContext* context, const ::nakama::api::ValidatePurchaseHuaweiRequest& request, ::nakama::api::ValidatePurchaseResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::ValidatePurchaseResponse>> AsyncValidatePurchaseHuawei(::grpc::ClientContext* context, const ::nakama::api::ValidatePurchaseHuaweiRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::ValidatePurchaseResponse>>(AsyncValidatePurchaseHuaweiRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::ValidatePurchaseResponse>> PrepareAsyncValidatePurchaseHuawei(::grpc::ClientContext* context, const ::nakama::api::ValidatePurchaseHuaweiRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::ValidatePurchaseResponse>>(PrepareAsyncValidatePurchaseHuaweiRaw(context, request, cq));
    }
    ::grpc::Status WriteLeaderboardRecord(::grpc::ClientContext* context, const ::nakama::api::WriteLeaderboardRecordRequest& request, ::nakama::api::LeaderboardRecord* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::LeaderboardRecord>> AsyncWriteLeaderboardRecord(::grpc::ClientContext* context, const ::nakama::api::WriteLeaderboardRecordRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::LeaderboardRecord>>(AsyncWriteLeaderboardRecordRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::LeaderboardRecord>> PrepareAsyncWriteLeaderboardRecord(::grpc::ClientContext* context, const ::nakama::api::WriteLeaderboardRecordRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::LeaderboardRecord>>(PrepareAsyncWriteLeaderboardRecordRaw(context, request, cq));
    }
    ::grpc::Status WriteStorageObjects(::grpc::ClientContext* context, const ::nakama::api::WriteStorageObjectsRequest& request, ::nakama::api::StorageObjectAcks* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::StorageObjectAcks>> AsyncWriteStorageObjects(::grpc::ClientContext* context, const ::nakama::api::WriteStorageObjectsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::StorageObjectAcks>>(AsyncWriteStorageObjectsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::StorageObjectAcks>> PrepareAsyncWriteStorageObjects(::grpc::ClientContext* context, const ::nakama::api::WriteStorageObjectsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::StorageObjectAcks>>(PrepareAsyncWriteStorageObjectsRaw(context, request, cq));
    }
    ::grpc::Status WriteTournamentRecord(::grpc::ClientContext* context, const ::nakama::api::WriteTournamentRecordRequest& request, ::nakama::api::LeaderboardRecord* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::LeaderboardRecord>> AsyncWriteTournamentRecord(::grpc::ClientContext* context, const ::nakama::api::WriteTournamentRecordRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::LeaderboardRecord>>(AsyncWriteTournamentRecordRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::LeaderboardRecord>> PrepareAsyncWriteTournamentRecord(::grpc::ClientContext* context, const ::nakama::api::WriteTournamentRecordRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::nakama::api::LeaderboardRecord>>(PrepareAsyncWriteTournamentRecordRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void AddFriends(::grpc::ClientContext* context, const ::nakama::api::AddFriendsRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void AddFriends(::grpc::ClientContext* context, const ::nakama::api::AddFriendsRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void AddFriends(::grpc::ClientContext* context, const ::nakama::api::AddFriendsRequest* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void AddGroupUsers(::grpc::ClientContext* context, const ::nakama::api::AddGroupUsersRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void AddGroupUsers(::grpc::ClientContext* context, const ::nakama::api::AddGroupUsersRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void AddGroupUsers(::grpc::ClientContext* context, const ::nakama::api::AddGroupUsersRequest* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void SessionRefresh(::grpc::ClientContext* context, const ::nakama::api::SessionRefreshRequest* request, ::nakama::api::Session* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SessionRefresh(::grpc::ClientContext* context, const ::nakama::api::SessionRefreshRequest* request, ::nakama::api::Session* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SessionRefresh(::grpc::ClientContext* context, const ::nakama::api::SessionRefreshRequest* request, ::nakama::api::Session* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void SessionLogout(::grpc::ClientContext* context, const ::nakama::api::SessionLogoutRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SessionLogout(::grpc::ClientContext* context, const ::nakama::api::SessionLogoutRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SessionLogout(::grpc::ClientContext* context, const ::nakama::api::SessionLogoutRequest* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void AuthenticateApple(::grpc::ClientContext* context, const ::nakama::api::AuthenticateAppleRequest* request, ::nakama::api::Session* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void AuthenticateApple(::grpc::ClientContext* context, const ::nakama::api::AuthenticateAppleRequest* request, ::nakama::api::Session* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void AuthenticateApple(::grpc::ClientContext* context, const ::nakama::api::AuthenticateAppleRequest* request, ::nakama::api::Session* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void AuthenticateCustom(::grpc::ClientContext* context, const ::nakama::api::AuthenticateCustomRequest* request, ::nakama::api::Session* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void AuthenticateCustom(::grpc::ClientContext* context, const ::nakama::api::AuthenticateCustomRequest* request, ::nakama::api::Session* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void AuthenticateCustom(::grpc::ClientContext* context, const ::nakama::api::AuthenticateCustomRequest* request, ::nakama::api::Session* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void AuthenticateDevice(::grpc::ClientContext* context, const ::nakama::api::AuthenticateDeviceRequest* request, ::nakama::api::Session* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void AuthenticateDevice(::grpc::ClientContext* context, const ::nakama::api::AuthenticateDeviceRequest* request, ::nakama::api::Session* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void AuthenticateDevice(::grpc::ClientContext* context, const ::nakama::api::AuthenticateDeviceRequest* request, ::nakama::api::Session* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void AuthenticateEmail(::grpc::ClientContext* context, const ::nakama::api::AuthenticateEmailRequest* request, ::nakama::api::Session* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void AuthenticateEmail(::grpc::ClientContext* context, const ::nakama::api::AuthenticateEmailRequest* request, ::nakama::api::Session* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void AuthenticateEmail(::grpc::ClientContext* context, const ::nakama::api::AuthenticateEmailRequest* request, ::nakama::api::Session* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void AuthenticateFacebook(::grpc::ClientContext* context, const ::nakama::api::AuthenticateFacebookRequest* request, ::nakama::api::Session* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void AuthenticateFacebook(::grpc::ClientContext* context, const ::nakama::api::AuthenticateFacebookRequest* request, ::nakama::api::Session* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void AuthenticateFacebook(::grpc::ClientContext* context, const ::nakama::api::AuthenticateFacebookRequest* request, ::nakama::api::Session* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void AuthenticateFacebookInstantGame(::grpc::ClientContext* context, const ::nakama::api::AuthenticateFacebookInstantGameRequest* request, ::nakama::api::Session* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void AuthenticateFacebookInstantGame(::grpc::ClientContext* context, const ::nakama::api::AuthenticateFacebookInstantGameRequest* request, ::nakama::api::Session* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void AuthenticateFacebookInstantGame(::grpc::ClientContext* context, const ::nakama::api::AuthenticateFacebookInstantGameRequest* request, ::nakama::api::Session* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void AuthenticateGameCenter(::grpc::ClientContext* context, const ::nakama::api::AuthenticateGameCenterRequest* request, ::nakama::api::Session* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void AuthenticateGameCenter(::grpc::ClientContext* context, const ::nakama::api::AuthenticateGameCenterRequest* request, ::nakama::api::Session* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void AuthenticateGameCenter(::grpc::ClientContext* context, const ::nakama::api::AuthenticateGameCenterRequest* request, ::nakama::api::Session* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void AuthenticateGoogle(::grpc::ClientContext* context, const ::nakama::api::AuthenticateGoogleRequest* request, ::nakama::api::Session* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void AuthenticateGoogle(::grpc::ClientContext* context, const ::nakama::api::AuthenticateGoogleRequest* request, ::nakama::api::Session* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void AuthenticateGoogle(::grpc::ClientContext* context, const ::nakama::api::AuthenticateGoogleRequest* request, ::nakama::api::Session* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void AuthenticateSteam(::grpc::ClientContext* context, const ::nakama::api::AuthenticateSteamRequest* request, ::nakama::api::Session* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void AuthenticateSteam(::grpc::ClientContext* context, const ::nakama::api::AuthenticateSteamRequest* request, ::nakama::api::Session* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void AuthenticateSteam(::grpc::ClientContext* context, const ::nakama::api::AuthenticateSteamRequest* request, ::nakama::api::Session* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void BanGroupUsers(::grpc::ClientContext* context, const ::nakama::api::BanGroupUsersRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void BanGroupUsers(::grpc::ClientContext* context, const ::nakama::api::BanGroupUsersRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void BanGroupUsers(::grpc::ClientContext* context, const ::nakama::api::BanGroupUsersRequest* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void BlockFriends(::grpc::ClientContext* context, const ::nakama::api::BlockFriendsRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void BlockFriends(::grpc::ClientContext* context, const ::nakama::api::BlockFriendsRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void BlockFriends(::grpc::ClientContext* context, const ::nakama::api::BlockFriendsRequest* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void CreateGroup(::grpc::ClientContext* context, const ::nakama::api::CreateGroupRequest* request, ::nakama::api::Group* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void CreateGroup(::grpc::ClientContext* context, const ::nakama::api::CreateGroupRequest* request, ::nakama::api::Group* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void CreateGroup(::grpc::ClientContext* context, const ::nakama::api::CreateGroupRequest* request, ::nakama::api::Group* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DeleteFriends(::grpc::ClientContext* context, const ::nakama::api::DeleteFriendsRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteFriends(::grpc::ClientContext* context, const ::nakama::api::DeleteFriendsRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteFriends(::grpc::ClientContext* context, const ::nakama::api::DeleteFriendsRequest* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DeleteGroup(::grpc::ClientContext* context, const ::nakama::api::DeleteGroupRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteGroup(::grpc::ClientContext* context, const ::nakama::api::DeleteGroupRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteGroup(::grpc::ClientContext* context, const ::nakama::api::DeleteGroupRequest* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DeleteLeaderboardRecord(::grpc::ClientContext* context, const ::nakama::api::DeleteLeaderboardRecordRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteLeaderboardRecord(::grpc::ClientContext* context, const ::nakama::api::DeleteLeaderboardRecordRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteLeaderboardRecord(::grpc::ClientContext* context, const ::nakama::api::DeleteLeaderboardRecordRequest* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DeleteNotifications(::grpc::ClientContext* context, const ::nakama::api::DeleteNotificationsRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteNotifications(::grpc::ClientContext* context, const ::nakama::api::DeleteNotificationsRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteNotifications(::grpc::ClientContext* context, const ::nakama::api::DeleteNotificationsRequest* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DeleteStorageObjects(::grpc::ClientContext* context, const ::nakama::api::DeleteStorageObjectsRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteStorageObjects(::grpc::ClientContext* context, const ::nakama::api::DeleteStorageObjectsRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteStorageObjects(::grpc::ClientContext* context, const ::nakama::api::DeleteStorageObjectsRequest* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void Event(::grpc::ClientContext* context, const ::nakama::api::Event* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Event(::grpc::ClientContext* context, const ::nakama::api::Event* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Event(::grpc::ClientContext* context, const ::nakama::api::Event* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetAccount(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::nakama::api::Account* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetAccount(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::nakama::api::Account* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetAccount(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::nakama::api::Account* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetUsers(::grpc::ClientContext* context, const ::nakama::api::GetUsersRequest* request, ::nakama::api::Users* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetUsers(::grpc::ClientContext* context, const ::nakama::api::GetUsersRequest* request, ::nakama::api::Users* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetUsers(::grpc::ClientContext* context, const ::nakama::api::GetUsersRequest* request, ::nakama::api::Users* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void Healthcheck(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Healthcheck(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Healthcheck(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ImportFacebookFriends(::grpc::ClientContext* context, const ::nakama::api::ImportFacebookFriendsRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ImportFacebookFriends(::grpc::ClientContext* context, const ::nakama::api::ImportFacebookFriendsRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ImportFacebookFriends(::grpc::ClientContext* context, const ::nakama::api::ImportFacebookFriendsRequest* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ImportSteamFriends(::grpc::ClientContext* context, const ::nakama::api::ImportSteamFriendsRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ImportSteamFriends(::grpc::ClientContext* context, const ::nakama::api::ImportSteamFriendsRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ImportSteamFriends(::grpc::ClientContext* context, const ::nakama::api::ImportSteamFriendsRequest* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void JoinGroup(::grpc::ClientContext* context, const ::nakama::api::JoinGroupRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void JoinGroup(::grpc::ClientContext* context, const ::nakama::api::JoinGroupRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void JoinGroup(::grpc::ClientContext* context, const ::nakama::api::JoinGroupRequest* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void JoinTournament(::grpc::ClientContext* context, const ::nakama::api::JoinTournamentRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void JoinTournament(::grpc::ClientContext* context, const ::nakama::api::JoinTournamentRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void JoinTournament(::grpc::ClientContext* context, const ::nakama::api::JoinTournamentRequest* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void KickGroupUsers(::grpc::ClientContext* context, const ::nakama::api::KickGroupUsersRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void KickGroupUsers(::grpc::ClientContext* context, const ::nakama::api::KickGroupUsersRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void KickGroupUsers(::grpc::ClientContext* context, const ::nakama::api::KickGroupUsersRequest* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void LeaveGroup(::grpc::ClientContext* context, const ::nakama::api::LeaveGroupRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void LeaveGroup(::grpc::ClientContext* context, const ::nakama::api::LeaveGroupRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void LeaveGroup(::grpc::ClientContext* context, const ::nakama::api::LeaveGroupRequest* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void LinkApple(::grpc::ClientContext* context, const ::nakama::api::AccountApple* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void LinkApple(::grpc::ClientContext* context, const ::nakama::api::AccountApple* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void LinkApple(::grpc::ClientContext* context, const ::nakama::api::AccountApple* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void LinkCustom(::grpc::ClientContext* context, const ::nakama::api::AccountCustom* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void LinkCustom(::grpc::ClientContext* context, const ::nakama::api::AccountCustom* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void LinkCustom(::grpc::ClientContext* context, const ::nakama::api::AccountCustom* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void LinkDevice(::grpc::ClientContext* context, const ::nakama::api::AccountDevice* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void LinkDevice(::grpc::ClientContext* context, const ::nakama::api::AccountDevice* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void LinkDevice(::grpc::ClientContext* context, const ::nakama::api::AccountDevice* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void LinkEmail(::grpc::ClientContext* context, const ::nakama::api::AccountEmail* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void LinkEmail(::grpc::ClientContext* context, const ::nakama::api::AccountEmail* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void LinkEmail(::grpc::ClientContext* context, const ::nakama::api::AccountEmail* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void LinkFacebook(::grpc::ClientContext* context, const ::nakama::api::LinkFacebookRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void LinkFacebook(::grpc::ClientContext* context, const ::nakama::api::LinkFacebookRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void LinkFacebook(::grpc::ClientContext* context, const ::nakama::api::LinkFacebookRequest* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void LinkFacebookInstantGame(::grpc::ClientContext* context, const ::nakama::api::AccountFacebookInstantGame* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void LinkFacebookInstantGame(::grpc::ClientContext* context, const ::nakama::api::AccountFacebookInstantGame* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void LinkFacebookInstantGame(::grpc::ClientContext* context, const ::nakama::api::AccountFacebookInstantGame* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void LinkGameCenter(::grpc::ClientContext* context, const ::nakama::api::AccountGameCenter* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void LinkGameCenter(::grpc::ClientContext* context, const ::nakama::api::AccountGameCenter* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void LinkGameCenter(::grpc::ClientContext* context, const ::nakama::api::AccountGameCenter* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void LinkGoogle(::grpc::ClientContext* context, const ::nakama::api::AccountGoogle* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void LinkGoogle(::grpc::ClientContext* context, const ::nakama::api::AccountGoogle* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void LinkGoogle(::grpc::ClientContext* context, const ::nakama::api::AccountGoogle* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void LinkSteam(::grpc::ClientContext* context, const ::nakama::api::LinkSteamRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void LinkSteam(::grpc::ClientContext* context, const ::nakama::api::LinkSteamRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void LinkSteam(::grpc::ClientContext* context, const ::nakama::api::LinkSteamRequest* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListChannelMessages(::grpc::ClientContext* context, const ::nakama::api::ListChannelMessagesRequest* request, ::nakama::api::ChannelMessageList* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListChannelMessages(::grpc::ClientContext* context, const ::nakama::api::ListChannelMessagesRequest* request, ::nakama::api::ChannelMessageList* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListChannelMessages(::grpc::ClientContext* context, const ::nakama::api::ListChannelMessagesRequest* request, ::nakama::api::ChannelMessageList* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListFriends(::grpc::ClientContext* context, const ::nakama::api::ListFriendsRequest* request, ::nakama::api::FriendList* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListFriends(::grpc::ClientContext* context, const ::nakama::api::ListFriendsRequest* request, ::nakama::api::FriendList* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListFriends(::grpc::ClientContext* context, const ::nakama::api::ListFriendsRequest* request, ::nakama::api::FriendList* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListGroups(::grpc::ClientContext* context, const ::nakama::api::ListGroupsRequest* request, ::nakama::api::GroupList* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListGroups(::grpc::ClientContext* context, const ::nakama::api::ListGroupsRequest* request, ::nakama::api::GroupList* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListGroups(::grpc::ClientContext* context, const ::nakama::api::ListGroupsRequest* request, ::nakama::api::GroupList* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListGroupUsers(::grpc::ClientContext* context, const ::nakama::api::ListGroupUsersRequest* request, ::nakama::api::GroupUserList* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListGroupUsers(::grpc::ClientContext* context, const ::nakama::api::ListGroupUsersRequest* request, ::nakama::api::GroupUserList* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListGroupUsers(::grpc::ClientContext* context, const ::nakama::api::ListGroupUsersRequest* request, ::nakama::api::GroupUserList* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListLeaderboardRecords(::grpc::ClientContext* context, const ::nakama::api::ListLeaderboardRecordsRequest* request, ::nakama::api::LeaderboardRecordList* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListLeaderboardRecords(::grpc::ClientContext* context, const ::nakama::api::ListLeaderboardRecordsRequest* request, ::nakama::api::LeaderboardRecordList* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListLeaderboardRecords(::grpc::ClientContext* context, const ::nakama::api::ListLeaderboardRecordsRequest* request, ::nakama::api::LeaderboardRecordList* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListLeaderboardRecordsAroundOwner(::grpc::ClientContext* context, const ::nakama::api::ListLeaderboardRecordsAroundOwnerRequest* request, ::nakama::api::LeaderboardRecordList* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListLeaderboardRecordsAroundOwner(::grpc::ClientContext* context, const ::nakama::api::ListLeaderboardRecordsAroundOwnerRequest* request, ::nakama::api::LeaderboardRecordList* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListLeaderboardRecordsAroundOwner(::grpc::ClientContext* context, const ::nakama::api::ListLeaderboardRecordsAroundOwnerRequest* request, ::nakama::api::LeaderboardRecordList* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListMatches(::grpc::ClientContext* context, const ::nakama::api::ListMatchesRequest* request, ::nakama::api::MatchList* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListMatches(::grpc::ClientContext* context, const ::nakama::api::ListMatchesRequest* request, ::nakama::api::MatchList* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListMatches(::grpc::ClientContext* context, const ::nakama::api::ListMatchesRequest* request, ::nakama::api::MatchList* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListNotifications(::grpc::ClientContext* context, const ::nakama::api::ListNotificationsRequest* request, ::nakama::api::NotificationList* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListNotifications(::grpc::ClientContext* context, const ::nakama::api::ListNotificationsRequest* request, ::nakama::api::NotificationList* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListNotifications(::grpc::ClientContext* context, const ::nakama::api::ListNotificationsRequest* request, ::nakama::api::NotificationList* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListStorageObjects(::grpc::ClientContext* context, const ::nakama::api::ListStorageObjectsRequest* request, ::nakama::api::StorageObjectList* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListStorageObjects(::grpc::ClientContext* context, const ::nakama::api::ListStorageObjectsRequest* request, ::nakama::api::StorageObjectList* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListStorageObjects(::grpc::ClientContext* context, const ::nakama::api::ListStorageObjectsRequest* request, ::nakama::api::StorageObjectList* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListTournaments(::grpc::ClientContext* context, const ::nakama::api::ListTournamentsRequest* request, ::nakama::api::TournamentList* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListTournaments(::grpc::ClientContext* context, const ::nakama::api::ListTournamentsRequest* request, ::nakama::api::TournamentList* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListTournaments(::grpc::ClientContext* context, const ::nakama::api::ListTournamentsRequest* request, ::nakama::api::TournamentList* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListTournamentRecords(::grpc::ClientContext* context, const ::nakama::api::ListTournamentRecordsRequest* request, ::nakama::api::TournamentRecordList* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListTournamentRecords(::grpc::ClientContext* context, const ::nakama::api::ListTournamentRecordsRequest* request, ::nakama::api::TournamentRecordList* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListTournamentRecords(::grpc::ClientContext* context, const ::nakama::api::ListTournamentRecordsRequest* request, ::nakama::api::TournamentRecordList* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListTournamentRecordsAroundOwner(::grpc::ClientContext* context, const ::nakama::api::ListTournamentRecordsAroundOwnerRequest* request, ::nakama::api::TournamentRecordList* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListTournamentRecordsAroundOwner(::grpc::ClientContext* context, const ::nakama::api::ListTournamentRecordsAroundOwnerRequest* request, ::nakama::api::TournamentRecordList* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListTournamentRecordsAroundOwner(::grpc::ClientContext* context, const ::nakama::api::ListTournamentRecordsAroundOwnerRequest* request, ::nakama::api::TournamentRecordList* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListUserGroups(::grpc::ClientContext* context, const ::nakama::api::ListUserGroupsRequest* request, ::nakama::api::UserGroupList* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListUserGroups(::grpc::ClientContext* context, const ::nakama::api::ListUserGroupsRequest* request, ::nakama::api::UserGroupList* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListUserGroups(::grpc::ClientContext* context, const ::nakama::api::ListUserGroupsRequest* request, ::nakama::api::UserGroupList* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void PromoteGroupUsers(::grpc::ClientContext* context, const ::nakama::api::PromoteGroupUsersRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PromoteGroupUsers(::grpc::ClientContext* context, const ::nakama::api::PromoteGroupUsersRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PromoteGroupUsers(::grpc::ClientContext* context, const ::nakama::api::PromoteGroupUsersRequest* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DemoteGroupUsers(::grpc::ClientContext* context, const ::nakama::api::DemoteGroupUsersRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DemoteGroupUsers(::grpc::ClientContext* context, const ::nakama::api::DemoteGroupUsersRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DemoteGroupUsers(::grpc::ClientContext* context, const ::nakama::api::DemoteGroupUsersRequest* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ReadStorageObjects(::grpc::ClientContext* context, const ::nakama::api::ReadStorageObjectsRequest* request, ::nakama::api::StorageObjects* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ReadStorageObjects(::grpc::ClientContext* context, const ::nakama::api::ReadStorageObjectsRequest* request, ::nakama::api::StorageObjects* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ReadStorageObjects(::grpc::ClientContext* context, const ::nakama::api::ReadStorageObjectsRequest* request, ::nakama::api::StorageObjects* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void RpcFunc(::grpc::ClientContext* context, const ::nakama::api::Rpc* request, ::nakama::api::Rpc* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void RpcFunc(::grpc::ClientContext* context, const ::nakama::api::Rpc* request, ::nakama::api::Rpc* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void RpcFunc(::grpc::ClientContext* context, const ::nakama::api::Rpc* request, ::nakama::api::Rpc* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void UnlinkApple(::grpc::ClientContext* context, const ::nakama::api::AccountApple* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void UnlinkApple(::grpc::ClientContext* context, const ::nakama::api::AccountApple* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void UnlinkApple(::grpc::ClientContext* context, const ::nakama::api::AccountApple* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void UnlinkCustom(::grpc::ClientContext* context, const ::nakama::api::AccountCustom* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void UnlinkCustom(::grpc::ClientContext* context, const ::nakama::api::AccountCustom* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void UnlinkCustom(::grpc::ClientContext* context, const ::nakama::api::AccountCustom* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void UnlinkDevice(::grpc::ClientContext* context, const ::nakama::api::AccountDevice* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void UnlinkDevice(::grpc::ClientContext* context, const ::nakama::api::AccountDevice* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void UnlinkDevice(::grpc::ClientContext* context, const ::nakama::api::AccountDevice* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void UnlinkEmail(::grpc::ClientContext* context, const ::nakama::api::AccountEmail* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void UnlinkEmail(::grpc::ClientContext* context, const ::nakama::api::AccountEmail* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void UnlinkEmail(::grpc::ClientContext* context, const ::nakama::api::AccountEmail* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void UnlinkFacebook(::grpc::ClientContext* context, const ::nakama::api::AccountFacebook* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void UnlinkFacebook(::grpc::ClientContext* context, const ::nakama::api::AccountFacebook* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void UnlinkFacebook(::grpc::ClientContext* context, const ::nakama::api::AccountFacebook* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void UnlinkFacebookInstantGame(::grpc::ClientContext* context, const ::nakama::api::AccountFacebookInstantGame* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void UnlinkFacebookInstantGame(::grpc::ClientContext* context, const ::nakama::api::AccountFacebookInstantGame* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void UnlinkFacebookInstantGame(::grpc::ClientContext* context, const ::nakama::api::AccountFacebookInstantGame* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void UnlinkGameCenter(::grpc::ClientContext* context, const ::nakama::api::AccountGameCenter* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void UnlinkGameCenter(::grpc::ClientContext* context, const ::nakama::api::AccountGameCenter* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void UnlinkGameCenter(::grpc::ClientContext* context, const ::nakama::api::AccountGameCenter* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void UnlinkGoogle(::grpc::ClientContext* context, const ::nakama::api::AccountGoogle* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void UnlinkGoogle(::grpc::ClientContext* context, const ::nakama::api::AccountGoogle* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void UnlinkGoogle(::grpc::ClientContext* context, const ::nakama::api::AccountGoogle* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void UnlinkSteam(::grpc::ClientContext* context, const ::nakama::api::AccountSteam* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void UnlinkSteam(::grpc::ClientContext* context, const ::nakama::api::AccountSteam* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void UnlinkSteam(::grpc::ClientContext* context, const ::nakama::api::AccountSteam* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void UpdateAccount(::grpc::ClientContext* context, const ::nakama::api::UpdateAccountRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void UpdateAccount(::grpc::ClientContext* context, const ::nakama::api::UpdateAccountRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void UpdateAccount(::grpc::ClientContext* context, const ::nakama::api::UpdateAccountRequest* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void UpdateGroup(::grpc::ClientContext* context, const ::nakama::api::UpdateGroupRequest* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void UpdateGroup(::grpc::ClientContext* context, const ::nakama::api::UpdateGroupRequest* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void UpdateGroup(::grpc::ClientContext* context, const ::nakama::api::UpdateGroupRequest* request, ::google::protobuf::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ValidatePurchaseApple(::grpc::ClientContext* context, const ::nakama::api::ValidatePurchaseAppleRequest* request, ::nakama::api::ValidatePurchaseResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ValidatePurchaseApple(::grpc::ClientContext* context, const ::nakama::api::ValidatePurchaseAppleRequest* request, ::nakama::api::ValidatePurchaseResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ValidatePurchaseApple(::grpc::ClientContext* context, const ::nakama::api::ValidatePurchaseAppleRequest* request, ::nakama::api::ValidatePurchaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ValidatePurchaseGoogle(::grpc::ClientContext* context, const ::nakama::api::ValidatePurchaseGoogleRequest* request, ::nakama::api::ValidatePurchaseResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ValidatePurchaseGoogle(::grpc::ClientContext* context, const ::nakama::api::ValidatePurchaseGoogleRequest* request, ::nakama::api::ValidatePurchaseResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ValidatePurchaseGoogle(::grpc::ClientContext* context, const ::nakama::api::ValidatePurchaseGoogleRequest* request, ::nakama::api::ValidatePurchaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ValidatePurchaseHuawei(::grpc::ClientContext* context, const ::nakama::api::ValidatePurchaseHuaweiRequest* request, ::nakama::api::ValidatePurchaseResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ValidatePurchaseHuawei(::grpc::ClientContext* context, const ::nakama::api::ValidatePurchaseHuaweiRequest* request, ::nakama::api::ValidatePurchaseResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ValidatePurchaseHuawei(::grpc::ClientContext* context, const ::nakama::api::ValidatePurchaseHuaweiRequest* request, ::nakama::api::ValidatePurchaseResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void WriteLeaderboardRecord(::grpc::ClientContext* context, const ::nakama::api::WriteLeaderboardRecordRequest* request, ::nakama::api::LeaderboardRecord* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void WriteLeaderboardRecord(::grpc::ClientContext* context, const ::nakama::api::WriteLeaderboardRecordRequest* request, ::nakama::api::LeaderboardRecord* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void WriteLeaderboardRecord(::grpc::ClientContext* context, const ::nakama::api::WriteLeaderboardRecordRequest* request, ::nakama::api::LeaderboardRecord* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void WriteStorageObjects(::grpc::ClientContext* context, const ::nakama::api::WriteStorageObjectsRequest* request, ::nakama::api::StorageObjectAcks* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void WriteStorageObjects(::grpc::ClientContext* context, const ::nakama::api::WriteStorageObjectsRequest* request, ::nakama::api::StorageObjectAcks* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void WriteStorageObjects(::grpc::ClientContext* context, const ::nakama::api::WriteStorageObjectsRequest* request, ::nakama::api::StorageObjectAcks* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void WriteTournamentRecord(::grpc::ClientContext* context, const ::nakama::api::WriteTournamentRecordRequest* request, ::nakama::api::LeaderboardRecord* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void WriteTournamentRecord(::grpc::ClientContext* context, const ::nakama::api::WriteTournamentRecordRequest* request, ::nakama::api::LeaderboardRecord* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void WriteTournamentRecord(::grpc::ClientContext* context, const ::nakama::api::WriteTournamentRecordRequest* request, ::nakama::api::LeaderboardRecord* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncAddFriendsRaw(::grpc::ClientContext* context, const ::nakama::api::AddFriendsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncAddFriendsRaw(::grpc::ClientContext* context, const ::nakama::api::AddFriendsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncAddGroupUsersRaw(::grpc::ClientContext* context, const ::nakama::api::AddGroupUsersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncAddGroupUsersRaw(::grpc::ClientContext* context, const ::nakama::api::AddGroupUsersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nakama::api::Session>* AsyncSessionRefreshRaw(::grpc::ClientContext* context, const ::nakama::api::SessionRefreshRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nakama::api::Session>* PrepareAsyncSessionRefreshRaw(::grpc::ClientContext* context, const ::nakama::api::SessionRefreshRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncSessionLogoutRaw(::grpc::ClientContext* context, const ::nakama::api::SessionLogoutRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncSessionLogoutRaw(::grpc::ClientContext* context, const ::nakama::api::SessionLogoutRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nakama::api::Session>* AsyncAuthenticateAppleRaw(::grpc::ClientContext* context, const ::nakama::api::AuthenticateAppleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nakama::api::Session>* PrepareAsyncAuthenticateAppleRaw(::grpc::ClientContext* context, const ::nakama::api::AuthenticateAppleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nakama::api::Session>* AsyncAuthenticateCustomRaw(::grpc::ClientContext* context, const ::nakama::api::AuthenticateCustomRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nakama::api::Session>* PrepareAsyncAuthenticateCustomRaw(::grpc::ClientContext* context, const ::nakama::api::AuthenticateCustomRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nakama::api::Session>* AsyncAuthenticateDeviceRaw(::grpc::ClientContext* context, const ::nakama::api::AuthenticateDeviceRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nakama::api::Session>* PrepareAsyncAuthenticateDeviceRaw(::grpc::ClientContext* context, const ::nakama::api::AuthenticateDeviceRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nakama::api::Session>* AsyncAuthenticateEmailRaw(::grpc::ClientContext* context, const ::nakama::api::AuthenticateEmailRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nakama::api::Session>* PrepareAsyncAuthenticateEmailRaw(::grpc::ClientContext* context, const ::nakama::api::AuthenticateEmailRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nakama::api::Session>* AsyncAuthenticateFacebookRaw(::grpc::ClientContext* context, const ::nakama::api::AuthenticateFacebookRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nakama::api::Session>* PrepareAsyncAuthenticateFacebookRaw(::grpc::ClientContext* context, const ::nakama::api::AuthenticateFacebookRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nakama::api::Session>* AsyncAuthenticateFacebookInstantGameRaw(::grpc::ClientContext* context, const ::nakama::api::AuthenticateFacebookInstantGameRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nakama::api::Session>* PrepareAsyncAuthenticateFacebookInstantGameRaw(::grpc::ClientContext* context, const ::nakama::api::AuthenticateFacebookInstantGameRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nakama::api::Session>* AsyncAuthenticateGameCenterRaw(::grpc::ClientContext* context, const ::nakama::api::AuthenticateGameCenterRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nakama::api::Session>* PrepareAsyncAuthenticateGameCenterRaw(::grpc::ClientContext* context, const ::nakama::api::AuthenticateGameCenterRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nakama::api::Session>* AsyncAuthenticateGoogleRaw(::grpc::ClientContext* context, const ::nakama::api::AuthenticateGoogleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nakama::api::Session>* PrepareAsyncAuthenticateGoogleRaw(::grpc::ClientContext* context, const ::nakama::api::AuthenticateGoogleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nakama::api::Session>* AsyncAuthenticateSteamRaw(::grpc::ClientContext* context, const ::nakama::api::AuthenticateSteamRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nakama::api::Session>* PrepareAsyncAuthenticateSteamRaw(::grpc::ClientContext* context, const ::nakama::api::AuthenticateSteamRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncBanGroupUsersRaw(::grpc::ClientContext* context, const ::nakama::api::BanGroupUsersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncBanGroupUsersRaw(::grpc::ClientContext* context, const ::nakama::api::BanGroupUsersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncBlockFriendsRaw(::grpc::ClientContext* context, const ::nakama::api::BlockFriendsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncBlockFriendsRaw(::grpc::ClientContext* context, const ::nakama::api::BlockFriendsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nakama::api::Group>* AsyncCreateGroupRaw(::grpc::ClientContext* context, const ::nakama::api::CreateGroupRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nakama::api::Group>* PrepareAsyncCreateGroupRaw(::grpc::ClientContext* context, const ::nakama::api::CreateGroupRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncDeleteFriendsRaw(::grpc::ClientContext* context, const ::nakama::api::DeleteFriendsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncDeleteFriendsRaw(::grpc::ClientContext* context, const ::nakama::api::DeleteFriendsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncDeleteGroupRaw(::grpc::ClientContext* context, const ::nakama::api::DeleteGroupRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncDeleteGroupRaw(::grpc::ClientContext* context, const ::nakama::api::DeleteGroupRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncDeleteLeaderboardRecordRaw(::grpc::ClientContext* context, const ::nakama::api::DeleteLeaderboardRecordRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncDeleteLeaderboardRecordRaw(::grpc::ClientContext* context, const ::nakama::api::DeleteLeaderboardRecordRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncDeleteNotificationsRaw(::grpc::ClientContext* context, const ::nakama::api::DeleteNotificationsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncDeleteNotificationsRaw(::grpc::ClientContext* context, const ::nakama::api::DeleteNotificationsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncDeleteStorageObjectsRaw(::grpc::ClientContext* context, const ::nakama::api::DeleteStorageObjectsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncDeleteStorageObjectsRaw(::grpc::ClientContext* context, const ::nakama::api::DeleteStorageObjectsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncEventRaw(::grpc::ClientContext* context, const ::nakama::api::Event& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncEventRaw(::grpc::ClientContext* context, const ::nakama::api::Event& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nakama::api::Account>* AsyncGetAccountRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nakama::api::Account>* PrepareAsyncGetAccountRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nakama::api::Users>* AsyncGetUsersRaw(::grpc::ClientContext* context, const ::nakama::api::GetUsersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nakama::api::Users>* PrepareAsyncGetUsersRaw(::grpc::ClientContext* context, const ::nakama::api::GetUsersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncHealthcheckRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncHealthcheckRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncImportFacebookFriendsRaw(::grpc::ClientContext* context, const ::nakama::api::ImportFacebookFriendsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncImportFacebookFriendsRaw(::grpc::ClientContext* context, const ::nakama::api::ImportFacebookFriendsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncImportSteamFriendsRaw(::grpc::ClientContext* context, const ::nakama::api::ImportSteamFriendsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncImportSteamFriendsRaw(::grpc::ClientContext* context, const ::nakama::api::ImportSteamFriendsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncJoinGroupRaw(::grpc::ClientContext* context, const ::nakama::api::JoinGroupRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncJoinGroupRaw(::grpc::ClientContext* context, const ::nakama::api::JoinGroupRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncJoinTournamentRaw(::grpc::ClientContext* context, const ::nakama::api::JoinTournamentRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncJoinTournamentRaw(::grpc::ClientContext* context, const ::nakama::api::JoinTournamentRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncKickGroupUsersRaw(::grpc::ClientContext* context, const ::nakama::api::KickGroupUsersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncKickGroupUsersRaw(::grpc::ClientContext* context, const ::nakama::api::KickGroupUsersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncLeaveGroupRaw(::grpc::ClientContext* context, const ::nakama::api::LeaveGroupRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncLeaveGroupRaw(::grpc::ClientContext* context, const ::nakama::api::LeaveGroupRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncLinkAppleRaw(::grpc::ClientContext* context, const ::nakama::api::AccountApple& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncLinkAppleRaw(::grpc::ClientContext* context, const ::nakama::api::AccountApple& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncLinkCustomRaw(::grpc::ClientContext* context, const ::nakama::api::AccountCustom& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncLinkCustomRaw(::grpc::ClientContext* context, const ::nakama::api::AccountCustom& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncLinkDeviceRaw(::grpc::ClientContext* context, const ::nakama::api::AccountDevice& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncLinkDeviceRaw(::grpc::ClientContext* context, const ::nakama::api::AccountDevice& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncLinkEmailRaw(::grpc::ClientContext* context, const ::nakama::api::AccountEmail& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncLinkEmailRaw(::grpc::ClientContext* context, const ::nakama::api::AccountEmail& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncLinkFacebookRaw(::grpc::ClientContext* context, const ::nakama::api::LinkFacebookRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncLinkFacebookRaw(::grpc::ClientContext* context, const ::nakama::api::LinkFacebookRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncLinkFacebookInstantGameRaw(::grpc::ClientContext* context, const ::nakama::api::AccountFacebookInstantGame& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncLinkFacebookInstantGameRaw(::grpc::ClientContext* context, const ::nakama::api::AccountFacebookInstantGame& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncLinkGameCenterRaw(::grpc::ClientContext* context, const ::nakama::api::AccountGameCenter& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncLinkGameCenterRaw(::grpc::ClientContext* context, const ::nakama::api::AccountGameCenter& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncLinkGoogleRaw(::grpc::ClientContext* context, const ::nakama::api::AccountGoogle& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncLinkGoogleRaw(::grpc::ClientContext* context, const ::nakama::api::AccountGoogle& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncLinkSteamRaw(::grpc::ClientContext* context, const ::nakama::api::LinkSteamRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncLinkSteamRaw(::grpc::ClientContext* context, const ::nakama::api::LinkSteamRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nakama::api::ChannelMessageList>* AsyncListChannelMessagesRaw(::grpc::ClientContext* context, const ::nakama::api::ListChannelMessagesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nakama::api::ChannelMessageList>* PrepareAsyncListChannelMessagesRaw(::grpc::ClientContext* context, const ::nakama::api::ListChannelMessagesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nakama::api::FriendList>* AsyncListFriendsRaw(::grpc::ClientContext* context, const ::nakama::api::ListFriendsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nakama::api::FriendList>* PrepareAsyncListFriendsRaw(::grpc::ClientContext* context, const ::nakama::api::ListFriendsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nakama::api::GroupList>* AsyncListGroupsRaw(::grpc::ClientContext* context, const ::nakama::api::ListGroupsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nakama::api::GroupList>* PrepareAsyncListGroupsRaw(::grpc::ClientContext* context, const ::nakama::api::ListGroupsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nakama::api::GroupUserList>* AsyncListGroupUsersRaw(::grpc::ClientContext* context, const ::nakama::api::ListGroupUsersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nakama::api::GroupUserList>* PrepareAsyncListGroupUsersRaw(::grpc::ClientContext* context, const ::nakama::api::ListGroupUsersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nakama::api::LeaderboardRecordList>* AsyncListLeaderboardRecordsRaw(::grpc::ClientContext* context, const ::nakama::api::ListLeaderboardRecordsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nakama::api::LeaderboardRecordList>* PrepareAsyncListLeaderboardRecordsRaw(::grpc::ClientContext* context, const ::nakama::api::ListLeaderboardRecordsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nakama::api::LeaderboardRecordList>* AsyncListLeaderboardRecordsAroundOwnerRaw(::grpc::ClientContext* context, const ::nakama::api::ListLeaderboardRecordsAroundOwnerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nakama::api::LeaderboardRecordList>* PrepareAsyncListLeaderboardRecordsAroundOwnerRaw(::grpc::ClientContext* context, const ::nakama::api::ListLeaderboardRecordsAroundOwnerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nakama::api::MatchList>* AsyncListMatchesRaw(::grpc::ClientContext* context, const ::nakama::api::ListMatchesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nakama::api::MatchList>* PrepareAsyncListMatchesRaw(::grpc::ClientContext* context, const ::nakama::api::ListMatchesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nakama::api::NotificationList>* AsyncListNotificationsRaw(::grpc::ClientContext* context, const ::nakama::api::ListNotificationsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nakama::api::NotificationList>* PrepareAsyncListNotificationsRaw(::grpc::ClientContext* context, const ::nakama::api::ListNotificationsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nakama::api::StorageObjectList>* AsyncListStorageObjectsRaw(::grpc::ClientContext* context, const ::nakama::api::ListStorageObjectsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nakama::api::StorageObjectList>* PrepareAsyncListStorageObjectsRaw(::grpc::ClientContext* context, const ::nakama::api::ListStorageObjectsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nakama::api::TournamentList>* AsyncListTournamentsRaw(::grpc::ClientContext* context, const ::nakama::api::ListTournamentsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nakama::api::TournamentList>* PrepareAsyncListTournamentsRaw(::grpc::ClientContext* context, const ::nakama::api::ListTournamentsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nakama::api::TournamentRecordList>* AsyncListTournamentRecordsRaw(::grpc::ClientContext* context, const ::nakama::api::ListTournamentRecordsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nakama::api::TournamentRecordList>* PrepareAsyncListTournamentRecordsRaw(::grpc::ClientContext* context, const ::nakama::api::ListTournamentRecordsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nakama::api::TournamentRecordList>* AsyncListTournamentRecordsAroundOwnerRaw(::grpc::ClientContext* context, const ::nakama::api::ListTournamentRecordsAroundOwnerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nakama::api::TournamentRecordList>* PrepareAsyncListTournamentRecordsAroundOwnerRaw(::grpc::ClientContext* context, const ::nakama::api::ListTournamentRecordsAroundOwnerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nakama::api::UserGroupList>* AsyncListUserGroupsRaw(::grpc::ClientContext* context, const ::nakama::api::ListUserGroupsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nakama::api::UserGroupList>* PrepareAsyncListUserGroupsRaw(::grpc::ClientContext* context, const ::nakama::api::ListUserGroupsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncPromoteGroupUsersRaw(::grpc::ClientContext* context, const ::nakama::api::PromoteGroupUsersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncPromoteGroupUsersRaw(::grpc::ClientContext* context, const ::nakama::api::PromoteGroupUsersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncDemoteGroupUsersRaw(::grpc::ClientContext* context, const ::nakama::api::DemoteGroupUsersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncDemoteGroupUsersRaw(::grpc::ClientContext* context, const ::nakama::api::DemoteGroupUsersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nakama::api::StorageObjects>* AsyncReadStorageObjectsRaw(::grpc::ClientContext* context, const ::nakama::api::ReadStorageObjectsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nakama::api::StorageObjects>* PrepareAsyncReadStorageObjectsRaw(::grpc::ClientContext* context, const ::nakama::api::ReadStorageObjectsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nakama::api::Rpc>* AsyncRpcFuncRaw(::grpc::ClientContext* context, const ::nakama::api::Rpc& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nakama::api::Rpc>* PrepareAsyncRpcFuncRaw(::grpc::ClientContext* context, const ::nakama::api::Rpc& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncUnlinkAppleRaw(::grpc::ClientContext* context, const ::nakama::api::AccountApple& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncUnlinkAppleRaw(::grpc::ClientContext* context, const ::nakama::api::AccountApple& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncUnlinkCustomRaw(::grpc::ClientContext* context, const ::nakama::api::AccountCustom& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncUnlinkCustomRaw(::grpc::ClientContext* context, const ::nakama::api::AccountCustom& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncUnlinkDeviceRaw(::grpc::ClientContext* context, const ::nakama::api::AccountDevice& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncUnlinkDeviceRaw(::grpc::ClientContext* context, const ::nakama::api::AccountDevice& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncUnlinkEmailRaw(::grpc::ClientContext* context, const ::nakama::api::AccountEmail& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncUnlinkEmailRaw(::grpc::ClientContext* context, const ::nakama::api::AccountEmail& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncUnlinkFacebookRaw(::grpc::ClientContext* context, const ::nakama::api::AccountFacebook& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncUnlinkFacebookRaw(::grpc::ClientContext* context, const ::nakama::api::AccountFacebook& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncUnlinkFacebookInstantGameRaw(::grpc::ClientContext* context, const ::nakama::api::AccountFacebookInstantGame& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncUnlinkFacebookInstantGameRaw(::grpc::ClientContext* context, const ::nakama::api::AccountFacebookInstantGame& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncUnlinkGameCenterRaw(::grpc::ClientContext* context, const ::nakama::api::AccountGameCenter& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncUnlinkGameCenterRaw(::grpc::ClientContext* context, const ::nakama::api::AccountGameCenter& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncUnlinkGoogleRaw(::grpc::ClientContext* context, const ::nakama::api::AccountGoogle& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncUnlinkGoogleRaw(::grpc::ClientContext* context, const ::nakama::api::AccountGoogle& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncUnlinkSteamRaw(::grpc::ClientContext* context, const ::nakama::api::AccountSteam& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncUnlinkSteamRaw(::grpc::ClientContext* context, const ::nakama::api::AccountSteam& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncUpdateAccountRaw(::grpc::ClientContext* context, const ::nakama::api::UpdateAccountRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncUpdateAccountRaw(::grpc::ClientContext* context, const ::nakama::api::UpdateAccountRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncUpdateGroupRaw(::grpc::ClientContext* context, const ::nakama::api::UpdateGroupRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncUpdateGroupRaw(::grpc::ClientContext* context, const ::nakama::api::UpdateGroupRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nakama::api::ValidatePurchaseResponse>* AsyncValidatePurchaseAppleRaw(::grpc::ClientContext* context, const ::nakama::api::ValidatePurchaseAppleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nakama::api::ValidatePurchaseResponse>* PrepareAsyncValidatePurchaseAppleRaw(::grpc::ClientContext* context, const ::nakama::api::ValidatePurchaseAppleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nakama::api::ValidatePurchaseResponse>* AsyncValidatePurchaseGoogleRaw(::grpc::ClientContext* context, const ::nakama::api::ValidatePurchaseGoogleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nakama::api::ValidatePurchaseResponse>* PrepareAsyncValidatePurchaseGoogleRaw(::grpc::ClientContext* context, const ::nakama::api::ValidatePurchaseGoogleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nakama::api::ValidatePurchaseResponse>* AsyncValidatePurchaseHuaweiRaw(::grpc::ClientContext* context, const ::nakama::api::ValidatePurchaseHuaweiRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nakama::api::ValidatePurchaseResponse>* PrepareAsyncValidatePurchaseHuaweiRaw(::grpc::ClientContext* context, const ::nakama::api::ValidatePurchaseHuaweiRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nakama::api::LeaderboardRecord>* AsyncWriteLeaderboardRecordRaw(::grpc::ClientContext* context, const ::nakama::api::WriteLeaderboardRecordRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nakama::api::LeaderboardRecord>* PrepareAsyncWriteLeaderboardRecordRaw(::grpc::ClientContext* context, const ::nakama::api::WriteLeaderboardRecordRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nakama::api::StorageObjectAcks>* AsyncWriteStorageObjectsRaw(::grpc::ClientContext* context, const ::nakama::api::WriteStorageObjectsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nakama::api::StorageObjectAcks>* PrepareAsyncWriteStorageObjectsRaw(::grpc::ClientContext* context, const ::nakama::api::WriteStorageObjectsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nakama::api::LeaderboardRecord>* AsyncWriteTournamentRecordRaw(::grpc::ClientContext* context, const ::nakama::api::WriteTournamentRecordRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::nakama::api::LeaderboardRecord>* PrepareAsyncWriteTournamentRecordRaw(::grpc::ClientContext* context, const ::nakama::api::WriteTournamentRecordRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_AddFriends_;
    const ::grpc::internal::RpcMethod rpcmethod_AddGroupUsers_;
    const ::grpc::internal::RpcMethod rpcmethod_SessionRefresh_;
    const ::grpc::internal::RpcMethod rpcmethod_SessionLogout_;
    const ::grpc::internal::RpcMethod rpcmethod_AuthenticateApple_;
    const ::grpc::internal::RpcMethod rpcmethod_AuthenticateCustom_;
    const ::grpc::internal::RpcMethod rpcmethod_AuthenticateDevice_;
    const ::grpc::internal::RpcMethod rpcmethod_AuthenticateEmail_;
    const ::grpc::internal::RpcMethod rpcmethod_AuthenticateFacebook_;
    const ::grpc::internal::RpcMethod rpcmethod_AuthenticateFacebookInstantGame_;
    const ::grpc::internal::RpcMethod rpcmethod_AuthenticateGameCenter_;
    const ::grpc::internal::RpcMethod rpcmethod_AuthenticateGoogle_;
    const ::grpc::internal::RpcMethod rpcmethod_AuthenticateSteam_;
    const ::grpc::internal::RpcMethod rpcmethod_BanGroupUsers_;
    const ::grpc::internal::RpcMethod rpcmethod_BlockFriends_;
    const ::grpc::internal::RpcMethod rpcmethod_CreateGroup_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteFriends_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteGroup_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteLeaderboardRecord_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteNotifications_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteStorageObjects_;
    const ::grpc::internal::RpcMethod rpcmethod_Event_;
    const ::grpc::internal::RpcMethod rpcmethod_GetAccount_;
    const ::grpc::internal::RpcMethod rpcmethod_GetUsers_;
    const ::grpc::internal::RpcMethod rpcmethod_Healthcheck_;
    const ::grpc::internal::RpcMethod rpcmethod_ImportFacebookFriends_;
    const ::grpc::internal::RpcMethod rpcmethod_ImportSteamFriends_;
    const ::grpc::internal::RpcMethod rpcmethod_JoinGroup_;
    const ::grpc::internal::RpcMethod rpcmethod_JoinTournament_;
    const ::grpc::internal::RpcMethod rpcmethod_KickGroupUsers_;
    const ::grpc::internal::RpcMethod rpcmethod_LeaveGroup_;
    const ::grpc::internal::RpcMethod rpcmethod_LinkApple_;
    const ::grpc::internal::RpcMethod rpcmethod_LinkCustom_;
    const ::grpc::internal::RpcMethod rpcmethod_LinkDevice_;
    const ::grpc::internal::RpcMethod rpcmethod_LinkEmail_;
    const ::grpc::internal::RpcMethod rpcmethod_LinkFacebook_;
    const ::grpc::internal::RpcMethod rpcmethod_LinkFacebookInstantGame_;
    const ::grpc::internal::RpcMethod rpcmethod_LinkGameCenter_;
    const ::grpc::internal::RpcMethod rpcmethod_LinkGoogle_;
    const ::grpc::internal::RpcMethod rpcmethod_LinkSteam_;
    const ::grpc::internal::RpcMethod rpcmethod_ListChannelMessages_;
    const ::grpc::internal::RpcMethod rpcmethod_ListFriends_;
    const ::grpc::internal::RpcMethod rpcmethod_ListGroups_;
    const ::grpc::internal::RpcMethod rpcmethod_ListGroupUsers_;
    const ::grpc::internal::RpcMethod rpcmethod_ListLeaderboardRecords_;
    const ::grpc::internal::RpcMethod rpcmethod_ListLeaderboardRecordsAroundOwner_;
    const ::grpc::internal::RpcMethod rpcmethod_ListMatches_;
    const ::grpc::internal::RpcMethod rpcmethod_ListNotifications_;
    const ::grpc::internal::RpcMethod rpcmethod_ListStorageObjects_;
    const ::grpc::internal::RpcMethod rpcmethod_ListTournaments_;
    const ::grpc::internal::RpcMethod rpcmethod_ListTournamentRecords_;
    const ::grpc::internal::RpcMethod rpcmethod_ListTournamentRecordsAroundOwner_;
    const ::grpc::internal::RpcMethod rpcmethod_ListUserGroups_;
    const ::grpc::internal::RpcMethod rpcmethod_PromoteGroupUsers_;
    const ::grpc::internal::RpcMethod rpcmethod_DemoteGroupUsers_;
    const ::grpc::internal::RpcMethod rpcmethod_ReadStorageObjects_;
    const ::grpc::internal::RpcMethod rpcmethod_RpcFunc_;
    const ::grpc::internal::RpcMethod rpcmethod_UnlinkApple_;
    const ::grpc::internal::RpcMethod rpcmethod_UnlinkCustom_;
    const ::grpc::internal::RpcMethod rpcmethod_UnlinkDevice_;
    const ::grpc::internal::RpcMethod rpcmethod_UnlinkEmail_;
    const ::grpc::internal::RpcMethod rpcmethod_UnlinkFacebook_;
    const ::grpc::internal::RpcMethod rpcmethod_UnlinkFacebookInstantGame_;
    const ::grpc::internal::RpcMethod rpcmethod_UnlinkGameCenter_;
    const ::grpc::internal::RpcMethod rpcmethod_UnlinkGoogle_;
    const ::grpc::internal::RpcMethod rpcmethod_UnlinkSteam_;
    const ::grpc::internal::RpcMethod rpcmethod_UpdateAccount_;
    const ::grpc::internal::RpcMethod rpcmethod_UpdateGroup_;
    const ::grpc::internal::RpcMethod rpcmethod_ValidatePurchaseApple_;
    const ::grpc::internal::RpcMethod rpcmethod_ValidatePurchaseGoogle_;
    const ::grpc::internal::RpcMethod rpcmethod_ValidatePurchaseHuawei_;
    const ::grpc::internal::RpcMethod rpcmethod_WriteLeaderboardRecord_;
    const ::grpc::internal::RpcMethod rpcmethod_WriteStorageObjects_;
    const ::grpc::internal::RpcMethod rpcmethod_WriteTournamentRecord_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Add friends by ID or username to a user's account.
    virtual ::grpc::Status AddFriends(::grpc::ServerContext* context, const ::nakama::api::AddFriendsRequest* request, ::google::protobuf::Empty* response);
    // Add users to a group.
    virtual ::grpc::Status AddGroupUsers(::grpc::ServerContext* context, const ::nakama::api::AddGroupUsersRequest* request, ::google::protobuf::Empty* response);
    // Refresh a user's session using a refresh token retrieved from a previous authentication request.
    virtual ::grpc::Status SessionRefresh(::grpc::ServerContext* context, const ::nakama::api::SessionRefreshRequest* request, ::nakama::api::Session* response);
    // Log out a session, invalidate a refresh token, or log out all sessions/refresh tokens for a user.
    virtual ::grpc::Status SessionLogout(::grpc::ServerContext* context, const ::nakama::api::SessionLogoutRequest* request, ::google::protobuf::Empty* response);
    // Authenticate a user with an Apple ID against the server.
    virtual ::grpc::Status AuthenticateApple(::grpc::ServerContext* context, const ::nakama::api::AuthenticateAppleRequest* request, ::nakama::api::Session* response);
    // Authenticate a user with a custom id against the server.
    virtual ::grpc::Status AuthenticateCustom(::grpc::ServerContext* context, const ::nakama::api::AuthenticateCustomRequest* request, ::nakama::api::Session* response);
    // Authenticate a user with a device id against the server.
    virtual ::grpc::Status AuthenticateDevice(::grpc::ServerContext* context, const ::nakama::api::AuthenticateDeviceRequest* request, ::nakama::api::Session* response);
    // Authenticate a user with an email+password against the server.
    virtual ::grpc::Status AuthenticateEmail(::grpc::ServerContext* context, const ::nakama::api::AuthenticateEmailRequest* request, ::nakama::api::Session* response);
    // Authenticate a user with a Facebook OAuth token against the server.
    virtual ::grpc::Status AuthenticateFacebook(::grpc::ServerContext* context, const ::nakama::api::AuthenticateFacebookRequest* request, ::nakama::api::Session* response);
    // Authenticate a user with a Facebook Instant Game token against the server.
    virtual ::grpc::Status AuthenticateFacebookInstantGame(::grpc::ServerContext* context, const ::nakama::api::AuthenticateFacebookInstantGameRequest* request, ::nakama::api::Session* response);
    // Authenticate a user with Apple's GameCenter against the server.
    virtual ::grpc::Status AuthenticateGameCenter(::grpc::ServerContext* context, const ::nakama::api::AuthenticateGameCenterRequest* request, ::nakama::api::Session* response);
    // Authenticate a user with Google against the server.
    virtual ::grpc::Status AuthenticateGoogle(::grpc::ServerContext* context, const ::nakama::api::AuthenticateGoogleRequest* request, ::nakama::api::Session* response);
    // Authenticate a user with Steam against the server.
    virtual ::grpc::Status AuthenticateSteam(::grpc::ServerContext* context, const ::nakama::api::AuthenticateSteamRequest* request, ::nakama::api::Session* response);
    // Ban a set of users from a group.
    virtual ::grpc::Status BanGroupUsers(::grpc::ServerContext* context, const ::nakama::api::BanGroupUsersRequest* request, ::google::protobuf::Empty* response);
    // Block one or more users by ID or username.
    virtual ::grpc::Status BlockFriends(::grpc::ServerContext* context, const ::nakama::api::BlockFriendsRequest* request, ::google::protobuf::Empty* response);
    // Create a new group with the current user as the owner.
    virtual ::grpc::Status CreateGroup(::grpc::ServerContext* context, const ::nakama::api::CreateGroupRequest* request, ::nakama::api::Group* response);
    // Delete one or more users by ID or username.
    virtual ::grpc::Status DeleteFriends(::grpc::ServerContext* context, const ::nakama::api::DeleteFriendsRequest* request, ::google::protobuf::Empty* response);
    // Delete a group by ID.
    virtual ::grpc::Status DeleteGroup(::grpc::ServerContext* context, const ::nakama::api::DeleteGroupRequest* request, ::google::protobuf::Empty* response);
    // Delete a leaderboard record.
    virtual ::grpc::Status DeleteLeaderboardRecord(::grpc::ServerContext* context, const ::nakama::api::DeleteLeaderboardRecordRequest* request, ::google::protobuf::Empty* response);
    // Delete one or more notifications for the current user.
    virtual ::grpc::Status DeleteNotifications(::grpc::ServerContext* context, const ::nakama::api::DeleteNotificationsRequest* request, ::google::protobuf::Empty* response);
    // Delete one or more objects by ID or username.
    virtual ::grpc::Status DeleteStorageObjects(::grpc::ServerContext* context, const ::nakama::api::DeleteStorageObjectsRequest* request, ::google::protobuf::Empty* response);
    // Submit an event for processing in the server's registered runtime custom events handler.
    virtual ::grpc::Status Event(::grpc::ServerContext* context, const ::nakama::api::Event* request, ::google::protobuf::Empty* response);
    // Fetch the current user's account.
    virtual ::grpc::Status GetAccount(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::nakama::api::Account* response);
    // Fetch zero or more users by ID and/or username.
    virtual ::grpc::Status GetUsers(::grpc::ServerContext* context, const ::nakama::api::GetUsersRequest* request, ::nakama::api::Users* response);
    // A healthcheck which load balancers can use to check the service.
    virtual ::grpc::Status Healthcheck(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response);
    // Import Facebook friends and add them to a user's account.
    virtual ::grpc::Status ImportFacebookFriends(::grpc::ServerContext* context, const ::nakama::api::ImportFacebookFriendsRequest* request, ::google::protobuf::Empty* response);
    // Import Steam friends and add them to a user's account.
    virtual ::grpc::Status ImportSteamFriends(::grpc::ServerContext* context, const ::nakama::api::ImportSteamFriendsRequest* request, ::google::protobuf::Empty* response);
    // Immediately join an open group, or request to join a closed one.
    virtual ::grpc::Status JoinGroup(::grpc::ServerContext* context, const ::nakama::api::JoinGroupRequest* request, ::google::protobuf::Empty* response);
    // Attempt to join an open and running tournament.
    virtual ::grpc::Status JoinTournament(::grpc::ServerContext* context, const ::nakama::api::JoinTournamentRequest* request, ::google::protobuf::Empty* response);
    // Kick a set of users from a group.
    virtual ::grpc::Status KickGroupUsers(::grpc::ServerContext* context, const ::nakama::api::KickGroupUsersRequest* request, ::google::protobuf::Empty* response);
    // Leave a group the user is a member of.
    virtual ::grpc::Status LeaveGroup(::grpc::ServerContext* context, const ::nakama::api::LeaveGroupRequest* request, ::google::protobuf::Empty* response);
    // Add an Apple ID to the social profiles on the current user's account.
    virtual ::grpc::Status LinkApple(::grpc::ServerContext* context, const ::nakama::api::AccountApple* request, ::google::protobuf::Empty* response);
    // Add a custom ID to the social profiles on the current user's account.
    virtual ::grpc::Status LinkCustom(::grpc::ServerContext* context, const ::nakama::api::AccountCustom* request, ::google::protobuf::Empty* response);
    // Add a device ID to the social profiles on the current user's account.
    virtual ::grpc::Status LinkDevice(::grpc::ServerContext* context, const ::nakama::api::AccountDevice* request, ::google::protobuf::Empty* response);
    // Add an email+password to the social profiles on the current user's account.
    virtual ::grpc::Status LinkEmail(::grpc::ServerContext* context, const ::nakama::api::AccountEmail* request, ::google::protobuf::Empty* response);
    // Add Facebook to the social profiles on the current user's account.
    virtual ::grpc::Status LinkFacebook(::grpc::ServerContext* context, const ::nakama::api::LinkFacebookRequest* request, ::google::protobuf::Empty* response);
    // Add Facebook Instant Game to the social profiles on the current user's account.
    virtual ::grpc::Status LinkFacebookInstantGame(::grpc::ServerContext* context, const ::nakama::api::AccountFacebookInstantGame* request, ::google::protobuf::Empty* response);
    // Add Apple's GameCenter to the social profiles on the current user's account.
    virtual ::grpc::Status LinkGameCenter(::grpc::ServerContext* context, const ::nakama::api::AccountGameCenter* request, ::google::protobuf::Empty* response);
    // Add Google to the social profiles on the current user's account.
    virtual ::grpc::Status LinkGoogle(::grpc::ServerContext* context, const ::nakama::api::AccountGoogle* request, ::google::protobuf::Empty* response);
    // Add Steam to the social profiles on the current user's account.
    virtual ::grpc::Status LinkSteam(::grpc::ServerContext* context, const ::nakama::api::LinkSteamRequest* request, ::google::protobuf::Empty* response);
    // List a channel's message history.
    virtual ::grpc::Status ListChannelMessages(::grpc::ServerContext* context, const ::nakama::api::ListChannelMessagesRequest* request, ::nakama::api::ChannelMessageList* response);
    // List all friends for the current user.
    virtual ::grpc::Status ListFriends(::grpc::ServerContext* context, const ::nakama::api::ListFriendsRequest* request, ::nakama::api::FriendList* response);
    // List groups based on given filters.
    virtual ::grpc::Status ListGroups(::grpc::ServerContext* context, const ::nakama::api::ListGroupsRequest* request, ::nakama::api::GroupList* response);
    // List all users that are part of a group.
    virtual ::grpc::Status ListGroupUsers(::grpc::ServerContext* context, const ::nakama::api::ListGroupUsersRequest* request, ::nakama::api::GroupUserList* response);
    // List leaderboard records.
    virtual ::grpc::Status ListLeaderboardRecords(::grpc::ServerContext* context, const ::nakama::api::ListLeaderboardRecordsRequest* request, ::nakama::api::LeaderboardRecordList* response);
    // List leaderboard records that belong to a user.
    virtual ::grpc::Status ListLeaderboardRecordsAroundOwner(::grpc::ServerContext* context, const ::nakama::api::ListLeaderboardRecordsAroundOwnerRequest* request, ::nakama::api::LeaderboardRecordList* response);
    // Fetch list of running matches.
    virtual ::grpc::Status ListMatches(::grpc::ServerContext* context, const ::nakama::api::ListMatchesRequest* request, ::nakama::api::MatchList* response);
    // Fetch list of notifications.
    virtual ::grpc::Status ListNotifications(::grpc::ServerContext* context, const ::nakama::api::ListNotificationsRequest* request, ::nakama::api::NotificationList* response);
    // List publicly readable storage objects in a given collection.
    virtual ::grpc::Status ListStorageObjects(::grpc::ServerContext* context, const ::nakama::api::ListStorageObjectsRequest* request, ::nakama::api::StorageObjectList* response);
    // List current or upcoming tournaments.
    virtual ::grpc::Status ListTournaments(::grpc::ServerContext* context, const ::nakama::api::ListTournamentsRequest* request, ::nakama::api::TournamentList* response);
    // List tournament records.
    virtual ::grpc::Status ListTournamentRecords(::grpc::ServerContext* context, const ::nakama::api::ListTournamentRecordsRequest* request, ::nakama::api::TournamentRecordList* response);
    // List tournament records for a given owner.
    virtual ::grpc::Status ListTournamentRecordsAroundOwner(::grpc::ServerContext* context, const ::nakama::api::ListTournamentRecordsAroundOwnerRequest* request, ::nakama::api::TournamentRecordList* response);
    // List groups the current user belongs to.
    virtual ::grpc::Status ListUserGroups(::grpc::ServerContext* context, const ::nakama::api::ListUserGroupsRequest* request, ::nakama::api::UserGroupList* response);
    // Promote a set of users in a group to the next role up.
    virtual ::grpc::Status PromoteGroupUsers(::grpc::ServerContext* context, const ::nakama::api::PromoteGroupUsersRequest* request, ::google::protobuf::Empty* response);
    // Demote a set of users in a group to the next role down.
    virtual ::grpc::Status DemoteGroupUsers(::grpc::ServerContext* context, const ::nakama::api::DemoteGroupUsersRequest* request, ::google::protobuf::Empty* response);
    // Get storage objects.
    virtual ::grpc::Status ReadStorageObjects(::grpc::ServerContext* context, const ::nakama::api::ReadStorageObjectsRequest* request, ::nakama::api::StorageObjects* response);
    // Execute a Lua function on the server.
    virtual ::grpc::Status RpcFunc(::grpc::ServerContext* context, const ::nakama::api::Rpc* request, ::nakama::api::Rpc* response);
    // Remove the Apple ID from the social profiles on the current user's account.
    virtual ::grpc::Status UnlinkApple(::grpc::ServerContext* context, const ::nakama::api::AccountApple* request, ::google::protobuf::Empty* response);
    // Remove the custom ID from the social profiles on the current user's account.
    virtual ::grpc::Status UnlinkCustom(::grpc::ServerContext* context, const ::nakama::api::AccountCustom* request, ::google::protobuf::Empty* response);
    // Remove the device ID from the social profiles on the current user's account.
    virtual ::grpc::Status UnlinkDevice(::grpc::ServerContext* context, const ::nakama::api::AccountDevice* request, ::google::protobuf::Empty* response);
    // Remove the email+password from the social profiles on the current user's account.
    virtual ::grpc::Status UnlinkEmail(::grpc::ServerContext* context, const ::nakama::api::AccountEmail* request, ::google::protobuf::Empty* response);
    // Remove Facebook from the social profiles on the current user's account.
    virtual ::grpc::Status UnlinkFacebook(::grpc::ServerContext* context, const ::nakama::api::AccountFacebook* request, ::google::protobuf::Empty* response);
    // Remove Facebook Instant Game profile from the social profiles on the current user's account.
    virtual ::grpc::Status UnlinkFacebookInstantGame(::grpc::ServerContext* context, const ::nakama::api::AccountFacebookInstantGame* request, ::google::protobuf::Empty* response);
    // Remove Apple's GameCenter from the social profiles on the current user's account.
    virtual ::grpc::Status UnlinkGameCenter(::grpc::ServerContext* context, const ::nakama::api::AccountGameCenter* request, ::google::protobuf::Empty* response);
    // Remove Google from the social profiles on the current user's account.
    virtual ::grpc::Status UnlinkGoogle(::grpc::ServerContext* context, const ::nakama::api::AccountGoogle* request, ::google::protobuf::Empty* response);
    // Remove Steam from the social profiles on the current user's account.
    virtual ::grpc::Status UnlinkSteam(::grpc::ServerContext* context, const ::nakama::api::AccountSteam* request, ::google::protobuf::Empty* response);
    // Update fields in the current user's account.
    virtual ::grpc::Status UpdateAccount(::grpc::ServerContext* context, const ::nakama::api::UpdateAccountRequest* request, ::google::protobuf::Empty* response);
    // Update fields in a given group.
    virtual ::grpc::Status UpdateGroup(::grpc::ServerContext* context, const ::nakama::api::UpdateGroupRequest* request, ::google::protobuf::Empty* response);
    // Validate Apple IAP Receipt
    virtual ::grpc::Status ValidatePurchaseApple(::grpc::ServerContext* context, const ::nakama::api::ValidatePurchaseAppleRequest* request, ::nakama::api::ValidatePurchaseResponse* response);
    // Validate Google IAP Receipt
    virtual ::grpc::Status ValidatePurchaseGoogle(::grpc::ServerContext* context, const ::nakama::api::ValidatePurchaseGoogleRequest* request, ::nakama::api::ValidatePurchaseResponse* response);
    // Validate Huawei IAP Receipt
    virtual ::grpc::Status ValidatePurchaseHuawei(::grpc::ServerContext* context, const ::nakama::api::ValidatePurchaseHuaweiRequest* request, ::nakama::api::ValidatePurchaseResponse* response);
    // Write a record to a leaderboard.
    virtual ::grpc::Status WriteLeaderboardRecord(::grpc::ServerContext* context, const ::nakama::api::WriteLeaderboardRecordRequest* request, ::nakama::api::LeaderboardRecord* response);
    // Write objects into the storage engine.
    virtual ::grpc::Status WriteStorageObjects(::grpc::ServerContext* context, const ::nakama::api::WriteStorageObjectsRequest* request, ::nakama::api::StorageObjectAcks* response);
    // Write a record to a tournament.
    virtual ::grpc::Status WriteTournamentRecord(::grpc::ServerContext* context, const ::nakama::api::WriteTournamentRecordRequest* request, ::nakama::api::LeaderboardRecord* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_AddFriends : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AddFriends() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_AddFriends() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddFriends(::grpc::ServerContext* /*context*/, const ::nakama::api::AddFriendsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAddFriends(::grpc::ServerContext* context, ::nakama::api::AddFriendsRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AddGroupUsers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AddGroupUsers() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_AddGroupUsers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddGroupUsers(::grpc::ServerContext* /*context*/, const ::nakama::api::AddGroupUsersRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAddGroupUsers(::grpc::ServerContext* context, ::nakama::api::AddGroupUsersRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SessionRefresh : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SessionRefresh() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_SessionRefresh() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SessionRefresh(::grpc::ServerContext* /*context*/, const ::nakama::api::SessionRefreshRequest* /*request*/, ::nakama::api::Session* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSessionRefresh(::grpc::ServerContext* context, ::nakama::api::SessionRefreshRequest* request, ::grpc::ServerAsyncResponseWriter< ::nakama::api::Session>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SessionLogout : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SessionLogout() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_SessionLogout() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SessionLogout(::grpc::ServerContext* /*context*/, const ::nakama::api::SessionLogoutRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSessionLogout(::grpc::ServerContext* context, ::nakama::api::SessionLogoutRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AuthenticateApple : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AuthenticateApple() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_AuthenticateApple() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AuthenticateApple(::grpc::ServerContext* /*context*/, const ::nakama::api::AuthenticateAppleRequest* /*request*/, ::nakama::api::Session* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAuthenticateApple(::grpc::ServerContext* context, ::nakama::api::AuthenticateAppleRequest* request, ::grpc::ServerAsyncResponseWriter< ::nakama::api::Session>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AuthenticateCustom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AuthenticateCustom() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_AuthenticateCustom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AuthenticateCustom(::grpc::ServerContext* /*context*/, const ::nakama::api::AuthenticateCustomRequest* /*request*/, ::nakama::api::Session* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAuthenticateCustom(::grpc::ServerContext* context, ::nakama::api::AuthenticateCustomRequest* request, ::grpc::ServerAsyncResponseWriter< ::nakama::api::Session>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AuthenticateDevice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AuthenticateDevice() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_AuthenticateDevice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AuthenticateDevice(::grpc::ServerContext* /*context*/, const ::nakama::api::AuthenticateDeviceRequest* /*request*/, ::nakama::api::Session* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAuthenticateDevice(::grpc::ServerContext* context, ::nakama::api::AuthenticateDeviceRequest* request, ::grpc::ServerAsyncResponseWriter< ::nakama::api::Session>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AuthenticateEmail : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AuthenticateEmail() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_AuthenticateEmail() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AuthenticateEmail(::grpc::ServerContext* /*context*/, const ::nakama::api::AuthenticateEmailRequest* /*request*/, ::nakama::api::Session* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAuthenticateEmail(::grpc::ServerContext* context, ::nakama::api::AuthenticateEmailRequest* request, ::grpc::ServerAsyncResponseWriter< ::nakama::api::Session>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AuthenticateFacebook : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AuthenticateFacebook() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_AuthenticateFacebook() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AuthenticateFacebook(::grpc::ServerContext* /*context*/, const ::nakama::api::AuthenticateFacebookRequest* /*request*/, ::nakama::api::Session* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAuthenticateFacebook(::grpc::ServerContext* context, ::nakama::api::AuthenticateFacebookRequest* request, ::grpc::ServerAsyncResponseWriter< ::nakama::api::Session>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AuthenticateFacebookInstantGame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AuthenticateFacebookInstantGame() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_AuthenticateFacebookInstantGame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AuthenticateFacebookInstantGame(::grpc::ServerContext* /*context*/, const ::nakama::api::AuthenticateFacebookInstantGameRequest* /*request*/, ::nakama::api::Session* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAuthenticateFacebookInstantGame(::grpc::ServerContext* context, ::nakama::api::AuthenticateFacebookInstantGameRequest* request, ::grpc::ServerAsyncResponseWriter< ::nakama::api::Session>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AuthenticateGameCenter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AuthenticateGameCenter() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_AuthenticateGameCenter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AuthenticateGameCenter(::grpc::ServerContext* /*context*/, const ::nakama::api::AuthenticateGameCenterRequest* /*request*/, ::nakama::api::Session* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAuthenticateGameCenter(::grpc::ServerContext* context, ::nakama::api::AuthenticateGameCenterRequest* request, ::grpc::ServerAsyncResponseWriter< ::nakama::api::Session>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AuthenticateGoogle : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AuthenticateGoogle() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_AuthenticateGoogle() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AuthenticateGoogle(::grpc::ServerContext* /*context*/, const ::nakama::api::AuthenticateGoogleRequest* /*request*/, ::nakama::api::Session* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAuthenticateGoogle(::grpc::ServerContext* context, ::nakama::api::AuthenticateGoogleRequest* request, ::grpc::ServerAsyncResponseWriter< ::nakama::api::Session>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AuthenticateSteam : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AuthenticateSteam() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_AuthenticateSteam() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AuthenticateSteam(::grpc::ServerContext* /*context*/, const ::nakama::api::AuthenticateSteamRequest* /*request*/, ::nakama::api::Session* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAuthenticateSteam(::grpc::ServerContext* context, ::nakama::api::AuthenticateSteamRequest* request, ::grpc::ServerAsyncResponseWriter< ::nakama::api::Session>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_BanGroupUsers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_BanGroupUsers() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_BanGroupUsers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BanGroupUsers(::grpc::ServerContext* /*context*/, const ::nakama::api::BanGroupUsersRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBanGroupUsers(::grpc::ServerContext* context, ::nakama::api::BanGroupUsersRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_BlockFriends : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_BlockFriends() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_BlockFriends() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BlockFriends(::grpc::ServerContext* /*context*/, const ::nakama::api::BlockFriendsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBlockFriends(::grpc::ServerContext* context, ::nakama::api::BlockFriendsRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CreateGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CreateGroup() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_CreateGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateGroup(::grpc::ServerContext* /*context*/, const ::nakama::api::CreateGroupRequest* /*request*/, ::nakama::api::Group* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateGroup(::grpc::ServerContext* context, ::nakama::api::CreateGroupRequest* request, ::grpc::ServerAsyncResponseWriter< ::nakama::api::Group>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteFriends : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteFriends() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_DeleteFriends() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteFriends(::grpc::ServerContext* /*context*/, const ::nakama::api::DeleteFriendsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteFriends(::grpc::ServerContext* context, ::nakama::api::DeleteFriendsRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteGroup() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_DeleteGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteGroup(::grpc::ServerContext* /*context*/, const ::nakama::api::DeleteGroupRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteGroup(::grpc::ServerContext* context, ::nakama::api::DeleteGroupRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteLeaderboardRecord : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteLeaderboardRecord() {
      ::grpc::Service::MarkMethodAsync(18);
    }
    ~WithAsyncMethod_DeleteLeaderboardRecord() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteLeaderboardRecord(::grpc::ServerContext* /*context*/, const ::nakama::api::DeleteLeaderboardRecordRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteLeaderboardRecord(::grpc::ServerContext* context, ::nakama::api::DeleteLeaderboardRecordRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteNotifications : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteNotifications() {
      ::grpc::Service::MarkMethodAsync(19);
    }
    ~WithAsyncMethod_DeleteNotifications() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteNotifications(::grpc::ServerContext* /*context*/, const ::nakama::api::DeleteNotificationsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteNotifications(::grpc::ServerContext* context, ::nakama::api::DeleteNotificationsRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteStorageObjects : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteStorageObjects() {
      ::grpc::Service::MarkMethodAsync(20);
    }
    ~WithAsyncMethod_DeleteStorageObjects() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteStorageObjects(::grpc::ServerContext* /*context*/, const ::nakama::api::DeleteStorageObjectsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteStorageObjects(::grpc::ServerContext* context, ::nakama::api::DeleteStorageObjectsRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Event : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Event() {
      ::grpc::Service::MarkMethodAsync(21);
    }
    ~WithAsyncMethod_Event() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Event(::grpc::ServerContext* /*context*/, const ::nakama::api::Event* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEvent(::grpc::ServerContext* context, ::nakama::api::Event* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetAccount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetAccount() {
      ::grpc::Service::MarkMethodAsync(22);
    }
    ~WithAsyncMethod_GetAccount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAccount(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::nakama::api::Account* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAccount(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::nakama::api::Account>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetUsers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetUsers() {
      ::grpc::Service::MarkMethodAsync(23);
    }
    ~WithAsyncMethod_GetUsers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetUsers(::grpc::ServerContext* /*context*/, const ::nakama::api::GetUsersRequest* /*request*/, ::nakama::api::Users* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetUsers(::grpc::ServerContext* context, ::nakama::api::GetUsersRequest* request, ::grpc::ServerAsyncResponseWriter< ::nakama::api::Users>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Healthcheck : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Healthcheck() {
      ::grpc::Service::MarkMethodAsync(24);
    }
    ~WithAsyncMethod_Healthcheck() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Healthcheck(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHealthcheck(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(24, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ImportFacebookFriends : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ImportFacebookFriends() {
      ::grpc::Service::MarkMethodAsync(25);
    }
    ~WithAsyncMethod_ImportFacebookFriends() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportFacebookFriends(::grpc::ServerContext* /*context*/, const ::nakama::api::ImportFacebookFriendsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestImportFacebookFriends(::grpc::ServerContext* context, ::nakama::api::ImportFacebookFriendsRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(25, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ImportSteamFriends : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ImportSteamFriends() {
      ::grpc::Service::MarkMethodAsync(26);
    }
    ~WithAsyncMethod_ImportSteamFriends() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportSteamFriends(::grpc::ServerContext* /*context*/, const ::nakama::api::ImportSteamFriendsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestImportSteamFriends(::grpc::ServerContext* context, ::nakama::api::ImportSteamFriendsRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(26, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_JoinGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_JoinGroup() {
      ::grpc::Service::MarkMethodAsync(27);
    }
    ~WithAsyncMethod_JoinGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status JoinGroup(::grpc::ServerContext* /*context*/, const ::nakama::api::JoinGroupRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestJoinGroup(::grpc::ServerContext* context, ::nakama::api::JoinGroupRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(27, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_JoinTournament : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_JoinTournament() {
      ::grpc::Service::MarkMethodAsync(28);
    }
    ~WithAsyncMethod_JoinTournament() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status JoinTournament(::grpc::ServerContext* /*context*/, const ::nakama::api::JoinTournamentRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestJoinTournament(::grpc::ServerContext* context, ::nakama::api::JoinTournamentRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(28, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_KickGroupUsers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_KickGroupUsers() {
      ::grpc::Service::MarkMethodAsync(29);
    }
    ~WithAsyncMethod_KickGroupUsers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KickGroupUsers(::grpc::ServerContext* /*context*/, const ::nakama::api::KickGroupUsersRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestKickGroupUsers(::grpc::ServerContext* context, ::nakama::api::KickGroupUsersRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(29, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_LeaveGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_LeaveGroup() {
      ::grpc::Service::MarkMethodAsync(30);
    }
    ~WithAsyncMethod_LeaveGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LeaveGroup(::grpc::ServerContext* /*context*/, const ::nakama::api::LeaveGroupRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLeaveGroup(::grpc::ServerContext* context, ::nakama::api::LeaveGroupRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(30, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_LinkApple : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_LinkApple() {
      ::grpc::Service::MarkMethodAsync(31);
    }
    ~WithAsyncMethod_LinkApple() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LinkApple(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountApple* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLinkApple(::grpc::ServerContext* context, ::nakama::api::AccountApple* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(31, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_LinkCustom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_LinkCustom() {
      ::grpc::Service::MarkMethodAsync(32);
    }
    ~WithAsyncMethod_LinkCustom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LinkCustom(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountCustom* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLinkCustom(::grpc::ServerContext* context, ::nakama::api::AccountCustom* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(32, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_LinkDevice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_LinkDevice() {
      ::grpc::Service::MarkMethodAsync(33);
    }
    ~WithAsyncMethod_LinkDevice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LinkDevice(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountDevice* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLinkDevice(::grpc::ServerContext* context, ::nakama::api::AccountDevice* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(33, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_LinkEmail : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_LinkEmail() {
      ::grpc::Service::MarkMethodAsync(34);
    }
    ~WithAsyncMethod_LinkEmail() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LinkEmail(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountEmail* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLinkEmail(::grpc::ServerContext* context, ::nakama::api::AccountEmail* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(34, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_LinkFacebook : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_LinkFacebook() {
      ::grpc::Service::MarkMethodAsync(35);
    }
    ~WithAsyncMethod_LinkFacebook() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LinkFacebook(::grpc::ServerContext* /*context*/, const ::nakama::api::LinkFacebookRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLinkFacebook(::grpc::ServerContext* context, ::nakama::api::LinkFacebookRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(35, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_LinkFacebookInstantGame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_LinkFacebookInstantGame() {
      ::grpc::Service::MarkMethodAsync(36);
    }
    ~WithAsyncMethod_LinkFacebookInstantGame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LinkFacebookInstantGame(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountFacebookInstantGame* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLinkFacebookInstantGame(::grpc::ServerContext* context, ::nakama::api::AccountFacebookInstantGame* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(36, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_LinkGameCenter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_LinkGameCenter() {
      ::grpc::Service::MarkMethodAsync(37);
    }
    ~WithAsyncMethod_LinkGameCenter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LinkGameCenter(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountGameCenter* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLinkGameCenter(::grpc::ServerContext* context, ::nakama::api::AccountGameCenter* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(37, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_LinkGoogle : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_LinkGoogle() {
      ::grpc::Service::MarkMethodAsync(38);
    }
    ~WithAsyncMethod_LinkGoogle() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LinkGoogle(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountGoogle* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLinkGoogle(::grpc::ServerContext* context, ::nakama::api::AccountGoogle* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(38, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_LinkSteam : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_LinkSteam() {
      ::grpc::Service::MarkMethodAsync(39);
    }
    ~WithAsyncMethod_LinkSteam() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LinkSteam(::grpc::ServerContext* /*context*/, const ::nakama::api::LinkSteamRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLinkSteam(::grpc::ServerContext* context, ::nakama::api::LinkSteamRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(39, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListChannelMessages : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListChannelMessages() {
      ::grpc::Service::MarkMethodAsync(40);
    }
    ~WithAsyncMethod_ListChannelMessages() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListChannelMessages(::grpc::ServerContext* /*context*/, const ::nakama::api::ListChannelMessagesRequest* /*request*/, ::nakama::api::ChannelMessageList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListChannelMessages(::grpc::ServerContext* context, ::nakama::api::ListChannelMessagesRequest* request, ::grpc::ServerAsyncResponseWriter< ::nakama::api::ChannelMessageList>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(40, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListFriends : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListFriends() {
      ::grpc::Service::MarkMethodAsync(41);
    }
    ~WithAsyncMethod_ListFriends() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListFriends(::grpc::ServerContext* /*context*/, const ::nakama::api::ListFriendsRequest* /*request*/, ::nakama::api::FriendList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListFriends(::grpc::ServerContext* context, ::nakama::api::ListFriendsRequest* request, ::grpc::ServerAsyncResponseWriter< ::nakama::api::FriendList>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(41, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListGroups : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListGroups() {
      ::grpc::Service::MarkMethodAsync(42);
    }
    ~WithAsyncMethod_ListGroups() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListGroups(::grpc::ServerContext* /*context*/, const ::nakama::api::ListGroupsRequest* /*request*/, ::nakama::api::GroupList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListGroups(::grpc::ServerContext* context, ::nakama::api::ListGroupsRequest* request, ::grpc::ServerAsyncResponseWriter< ::nakama::api::GroupList>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(42, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListGroupUsers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListGroupUsers() {
      ::grpc::Service::MarkMethodAsync(43);
    }
    ~WithAsyncMethod_ListGroupUsers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListGroupUsers(::grpc::ServerContext* /*context*/, const ::nakama::api::ListGroupUsersRequest* /*request*/, ::nakama::api::GroupUserList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListGroupUsers(::grpc::ServerContext* context, ::nakama::api::ListGroupUsersRequest* request, ::grpc::ServerAsyncResponseWriter< ::nakama::api::GroupUserList>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(43, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListLeaderboardRecords : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListLeaderboardRecords() {
      ::grpc::Service::MarkMethodAsync(44);
    }
    ~WithAsyncMethod_ListLeaderboardRecords() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListLeaderboardRecords(::grpc::ServerContext* /*context*/, const ::nakama::api::ListLeaderboardRecordsRequest* /*request*/, ::nakama::api::LeaderboardRecordList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListLeaderboardRecords(::grpc::ServerContext* context, ::nakama::api::ListLeaderboardRecordsRequest* request, ::grpc::ServerAsyncResponseWriter< ::nakama::api::LeaderboardRecordList>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(44, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListLeaderboardRecordsAroundOwner : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListLeaderboardRecordsAroundOwner() {
      ::grpc::Service::MarkMethodAsync(45);
    }
    ~WithAsyncMethod_ListLeaderboardRecordsAroundOwner() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListLeaderboardRecordsAroundOwner(::grpc::ServerContext* /*context*/, const ::nakama::api::ListLeaderboardRecordsAroundOwnerRequest* /*request*/, ::nakama::api::LeaderboardRecordList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListLeaderboardRecordsAroundOwner(::grpc::ServerContext* context, ::nakama::api::ListLeaderboardRecordsAroundOwnerRequest* request, ::grpc::ServerAsyncResponseWriter< ::nakama::api::LeaderboardRecordList>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(45, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListMatches : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListMatches() {
      ::grpc::Service::MarkMethodAsync(46);
    }
    ~WithAsyncMethod_ListMatches() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListMatches(::grpc::ServerContext* /*context*/, const ::nakama::api::ListMatchesRequest* /*request*/, ::nakama::api::MatchList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListMatches(::grpc::ServerContext* context, ::nakama::api::ListMatchesRequest* request, ::grpc::ServerAsyncResponseWriter< ::nakama::api::MatchList>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(46, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListNotifications : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListNotifications() {
      ::grpc::Service::MarkMethodAsync(47);
    }
    ~WithAsyncMethod_ListNotifications() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListNotifications(::grpc::ServerContext* /*context*/, const ::nakama::api::ListNotificationsRequest* /*request*/, ::nakama::api::NotificationList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListNotifications(::grpc::ServerContext* context, ::nakama::api::ListNotificationsRequest* request, ::grpc::ServerAsyncResponseWriter< ::nakama::api::NotificationList>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(47, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListStorageObjects : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListStorageObjects() {
      ::grpc::Service::MarkMethodAsync(48);
    }
    ~WithAsyncMethod_ListStorageObjects() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListStorageObjects(::grpc::ServerContext* /*context*/, const ::nakama::api::ListStorageObjectsRequest* /*request*/, ::nakama::api::StorageObjectList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListStorageObjects(::grpc::ServerContext* context, ::nakama::api::ListStorageObjectsRequest* request, ::grpc::ServerAsyncResponseWriter< ::nakama::api::StorageObjectList>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(48, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListTournaments : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListTournaments() {
      ::grpc::Service::MarkMethodAsync(49);
    }
    ~WithAsyncMethod_ListTournaments() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListTournaments(::grpc::ServerContext* /*context*/, const ::nakama::api::ListTournamentsRequest* /*request*/, ::nakama::api::TournamentList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListTournaments(::grpc::ServerContext* context, ::nakama::api::ListTournamentsRequest* request, ::grpc::ServerAsyncResponseWriter< ::nakama::api::TournamentList>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(49, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListTournamentRecords : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListTournamentRecords() {
      ::grpc::Service::MarkMethodAsync(50);
    }
    ~WithAsyncMethod_ListTournamentRecords() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListTournamentRecords(::grpc::ServerContext* /*context*/, const ::nakama::api::ListTournamentRecordsRequest* /*request*/, ::nakama::api::TournamentRecordList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListTournamentRecords(::grpc::ServerContext* context, ::nakama::api::ListTournamentRecordsRequest* request, ::grpc::ServerAsyncResponseWriter< ::nakama::api::TournamentRecordList>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(50, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListTournamentRecordsAroundOwner : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListTournamentRecordsAroundOwner() {
      ::grpc::Service::MarkMethodAsync(51);
    }
    ~WithAsyncMethod_ListTournamentRecordsAroundOwner() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListTournamentRecordsAroundOwner(::grpc::ServerContext* /*context*/, const ::nakama::api::ListTournamentRecordsAroundOwnerRequest* /*request*/, ::nakama::api::TournamentRecordList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListTournamentRecordsAroundOwner(::grpc::ServerContext* context, ::nakama::api::ListTournamentRecordsAroundOwnerRequest* request, ::grpc::ServerAsyncResponseWriter< ::nakama::api::TournamentRecordList>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(51, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListUserGroups : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListUserGroups() {
      ::grpc::Service::MarkMethodAsync(52);
    }
    ~WithAsyncMethod_ListUserGroups() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListUserGroups(::grpc::ServerContext* /*context*/, const ::nakama::api::ListUserGroupsRequest* /*request*/, ::nakama::api::UserGroupList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListUserGroups(::grpc::ServerContext* context, ::nakama::api::ListUserGroupsRequest* request, ::grpc::ServerAsyncResponseWriter< ::nakama::api::UserGroupList>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(52, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PromoteGroupUsers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PromoteGroupUsers() {
      ::grpc::Service::MarkMethodAsync(53);
    }
    ~WithAsyncMethod_PromoteGroupUsers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PromoteGroupUsers(::grpc::ServerContext* /*context*/, const ::nakama::api::PromoteGroupUsersRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPromoteGroupUsers(::grpc::ServerContext* context, ::nakama::api::PromoteGroupUsersRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(53, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DemoteGroupUsers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DemoteGroupUsers() {
      ::grpc::Service::MarkMethodAsync(54);
    }
    ~WithAsyncMethod_DemoteGroupUsers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DemoteGroupUsers(::grpc::ServerContext* /*context*/, const ::nakama::api::DemoteGroupUsersRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDemoteGroupUsers(::grpc::ServerContext* context, ::nakama::api::DemoteGroupUsersRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(54, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ReadStorageObjects : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ReadStorageObjects() {
      ::grpc::Service::MarkMethodAsync(55);
    }
    ~WithAsyncMethod_ReadStorageObjects() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadStorageObjects(::grpc::ServerContext* /*context*/, const ::nakama::api::ReadStorageObjectsRequest* /*request*/, ::nakama::api::StorageObjects* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestReadStorageObjects(::grpc::ServerContext* context, ::nakama::api::ReadStorageObjectsRequest* request, ::grpc::ServerAsyncResponseWriter< ::nakama::api::StorageObjects>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(55, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RpcFunc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RpcFunc() {
      ::grpc::Service::MarkMethodAsync(56);
    }
    ~WithAsyncMethod_RpcFunc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RpcFunc(::grpc::ServerContext* /*context*/, const ::nakama::api::Rpc* /*request*/, ::nakama::api::Rpc* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRpcFunc(::grpc::ServerContext* context, ::nakama::api::Rpc* request, ::grpc::ServerAsyncResponseWriter< ::nakama::api::Rpc>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(56, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UnlinkApple : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UnlinkApple() {
      ::grpc::Service::MarkMethodAsync(57);
    }
    ~WithAsyncMethod_UnlinkApple() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnlinkApple(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountApple* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUnlinkApple(::grpc::ServerContext* context, ::nakama::api::AccountApple* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(57, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UnlinkCustom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UnlinkCustom() {
      ::grpc::Service::MarkMethodAsync(58);
    }
    ~WithAsyncMethod_UnlinkCustom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnlinkCustom(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountCustom* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUnlinkCustom(::grpc::ServerContext* context, ::nakama::api::AccountCustom* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(58, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UnlinkDevice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UnlinkDevice() {
      ::grpc::Service::MarkMethodAsync(59);
    }
    ~WithAsyncMethod_UnlinkDevice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnlinkDevice(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountDevice* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUnlinkDevice(::grpc::ServerContext* context, ::nakama::api::AccountDevice* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(59, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UnlinkEmail : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UnlinkEmail() {
      ::grpc::Service::MarkMethodAsync(60);
    }
    ~WithAsyncMethod_UnlinkEmail() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnlinkEmail(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountEmail* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUnlinkEmail(::grpc::ServerContext* context, ::nakama::api::AccountEmail* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(60, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UnlinkFacebook : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UnlinkFacebook() {
      ::grpc::Service::MarkMethodAsync(61);
    }
    ~WithAsyncMethod_UnlinkFacebook() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnlinkFacebook(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountFacebook* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUnlinkFacebook(::grpc::ServerContext* context, ::nakama::api::AccountFacebook* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(61, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UnlinkFacebookInstantGame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UnlinkFacebookInstantGame() {
      ::grpc::Service::MarkMethodAsync(62);
    }
    ~WithAsyncMethod_UnlinkFacebookInstantGame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnlinkFacebookInstantGame(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountFacebookInstantGame* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUnlinkFacebookInstantGame(::grpc::ServerContext* context, ::nakama::api::AccountFacebookInstantGame* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(62, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UnlinkGameCenter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UnlinkGameCenter() {
      ::grpc::Service::MarkMethodAsync(63);
    }
    ~WithAsyncMethod_UnlinkGameCenter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnlinkGameCenter(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountGameCenter* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUnlinkGameCenter(::grpc::ServerContext* context, ::nakama::api::AccountGameCenter* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(63, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UnlinkGoogle : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UnlinkGoogle() {
      ::grpc::Service::MarkMethodAsync(64);
    }
    ~WithAsyncMethod_UnlinkGoogle() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnlinkGoogle(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountGoogle* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUnlinkGoogle(::grpc::ServerContext* context, ::nakama::api::AccountGoogle* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(64, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UnlinkSteam : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UnlinkSteam() {
      ::grpc::Service::MarkMethodAsync(65);
    }
    ~WithAsyncMethod_UnlinkSteam() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnlinkSteam(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountSteam* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUnlinkSteam(::grpc::ServerContext* context, ::nakama::api::AccountSteam* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(65, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UpdateAccount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UpdateAccount() {
      ::grpc::Service::MarkMethodAsync(66);
    }
    ~WithAsyncMethod_UpdateAccount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateAccount(::grpc::ServerContext* /*context*/, const ::nakama::api::UpdateAccountRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateAccount(::grpc::ServerContext* context, ::nakama::api::UpdateAccountRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(66, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UpdateGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UpdateGroup() {
      ::grpc::Service::MarkMethodAsync(67);
    }
    ~WithAsyncMethod_UpdateGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateGroup(::grpc::ServerContext* /*context*/, const ::nakama::api::UpdateGroupRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateGroup(::grpc::ServerContext* context, ::nakama::api::UpdateGroupRequest* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(67, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ValidatePurchaseApple : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ValidatePurchaseApple() {
      ::grpc::Service::MarkMethodAsync(68);
    }
    ~WithAsyncMethod_ValidatePurchaseApple() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ValidatePurchaseApple(::grpc::ServerContext* /*context*/, const ::nakama::api::ValidatePurchaseAppleRequest* /*request*/, ::nakama::api::ValidatePurchaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestValidatePurchaseApple(::grpc::ServerContext* context, ::nakama::api::ValidatePurchaseAppleRequest* request, ::grpc::ServerAsyncResponseWriter< ::nakama::api::ValidatePurchaseResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(68, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ValidatePurchaseGoogle : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ValidatePurchaseGoogle() {
      ::grpc::Service::MarkMethodAsync(69);
    }
    ~WithAsyncMethod_ValidatePurchaseGoogle() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ValidatePurchaseGoogle(::grpc::ServerContext* /*context*/, const ::nakama::api::ValidatePurchaseGoogleRequest* /*request*/, ::nakama::api::ValidatePurchaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestValidatePurchaseGoogle(::grpc::ServerContext* context, ::nakama::api::ValidatePurchaseGoogleRequest* request, ::grpc::ServerAsyncResponseWriter< ::nakama::api::ValidatePurchaseResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(69, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ValidatePurchaseHuawei : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ValidatePurchaseHuawei() {
      ::grpc::Service::MarkMethodAsync(70);
    }
    ~WithAsyncMethod_ValidatePurchaseHuawei() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ValidatePurchaseHuawei(::grpc::ServerContext* /*context*/, const ::nakama::api::ValidatePurchaseHuaweiRequest* /*request*/, ::nakama::api::ValidatePurchaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestValidatePurchaseHuawei(::grpc::ServerContext* context, ::nakama::api::ValidatePurchaseHuaweiRequest* request, ::grpc::ServerAsyncResponseWriter< ::nakama::api::ValidatePurchaseResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(70, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_WriteLeaderboardRecord : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_WriteLeaderboardRecord() {
      ::grpc::Service::MarkMethodAsync(71);
    }
    ~WithAsyncMethod_WriteLeaderboardRecord() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WriteLeaderboardRecord(::grpc::ServerContext* /*context*/, const ::nakama::api::WriteLeaderboardRecordRequest* /*request*/, ::nakama::api::LeaderboardRecord* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWriteLeaderboardRecord(::grpc::ServerContext* context, ::nakama::api::WriteLeaderboardRecordRequest* request, ::grpc::ServerAsyncResponseWriter< ::nakama::api::LeaderboardRecord>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(71, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_WriteStorageObjects : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_WriteStorageObjects() {
      ::grpc::Service::MarkMethodAsync(72);
    }
    ~WithAsyncMethod_WriteStorageObjects() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WriteStorageObjects(::grpc::ServerContext* /*context*/, const ::nakama::api::WriteStorageObjectsRequest* /*request*/, ::nakama::api::StorageObjectAcks* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWriteStorageObjects(::grpc::ServerContext* context, ::nakama::api::WriteStorageObjectsRequest* request, ::grpc::ServerAsyncResponseWriter< ::nakama::api::StorageObjectAcks>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(72, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_WriteTournamentRecord : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_WriteTournamentRecord() {
      ::grpc::Service::MarkMethodAsync(73);
    }
    ~WithAsyncMethod_WriteTournamentRecord() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WriteTournamentRecord(::grpc::ServerContext* /*context*/, const ::nakama::api::WriteTournamentRecordRequest* /*request*/, ::nakama::api::LeaderboardRecord* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWriteTournamentRecord(::grpc::ServerContext* context, ::nakama::api::WriteTournamentRecordRequest* request, ::grpc::ServerAsyncResponseWriter< ::nakama::api::LeaderboardRecord>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(73, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_AddFriends<WithAsyncMethod_AddGroupUsers<WithAsyncMethod_SessionRefresh<WithAsyncMethod_SessionLogout<WithAsyncMethod_AuthenticateApple<WithAsyncMethod_AuthenticateCustom<WithAsyncMethod_AuthenticateDevice<WithAsyncMethod_AuthenticateEmail<WithAsyncMethod_AuthenticateFacebook<WithAsyncMethod_AuthenticateFacebookInstantGame<WithAsyncMethod_AuthenticateGameCenter<WithAsyncMethod_AuthenticateGoogle<WithAsyncMethod_AuthenticateSteam<WithAsyncMethod_BanGroupUsers<WithAsyncMethod_BlockFriends<WithAsyncMethod_CreateGroup<WithAsyncMethod_DeleteFriends<WithAsyncMethod_DeleteGroup<WithAsyncMethod_DeleteLeaderboardRecord<WithAsyncMethod_DeleteNotifications<WithAsyncMethod_DeleteStorageObjects<WithAsyncMethod_Event<WithAsyncMethod_GetAccount<WithAsyncMethod_GetUsers<WithAsyncMethod_Healthcheck<WithAsyncMethod_ImportFacebookFriends<WithAsyncMethod_ImportSteamFriends<WithAsyncMethod_JoinGroup<WithAsyncMethod_JoinTournament<WithAsyncMethod_KickGroupUsers<WithAsyncMethod_LeaveGroup<WithAsyncMethod_LinkApple<WithAsyncMethod_LinkCustom<WithAsyncMethod_LinkDevice<WithAsyncMethod_LinkEmail<WithAsyncMethod_LinkFacebook<WithAsyncMethod_LinkFacebookInstantGame<WithAsyncMethod_LinkGameCenter<WithAsyncMethod_LinkGoogle<WithAsyncMethod_LinkSteam<WithAsyncMethod_ListChannelMessages<WithAsyncMethod_ListFriends<WithAsyncMethod_ListGroups<WithAsyncMethod_ListGroupUsers<WithAsyncMethod_ListLeaderboardRecords<WithAsyncMethod_ListLeaderboardRecordsAroundOwner<WithAsyncMethod_ListMatches<WithAsyncMethod_ListNotifications<WithAsyncMethod_ListStorageObjects<WithAsyncMethod_ListTournaments<WithAsyncMethod_ListTournamentRecords<WithAsyncMethod_ListTournamentRecordsAroundOwner<WithAsyncMethod_ListUserGroups<WithAsyncMethod_PromoteGroupUsers<WithAsyncMethod_DemoteGroupUsers<WithAsyncMethod_ReadStorageObjects<WithAsyncMethod_RpcFunc<WithAsyncMethod_UnlinkApple<WithAsyncMethod_UnlinkCustom<WithAsyncMethod_UnlinkDevice<WithAsyncMethod_UnlinkEmail<WithAsyncMethod_UnlinkFacebook<WithAsyncMethod_UnlinkFacebookInstantGame<WithAsyncMethod_UnlinkGameCenter<WithAsyncMethod_UnlinkGoogle<WithAsyncMethod_UnlinkSteam<WithAsyncMethod_UpdateAccount<WithAsyncMethod_UpdateGroup<WithAsyncMethod_ValidatePurchaseApple<WithAsyncMethod_ValidatePurchaseGoogle<WithAsyncMethod_ValidatePurchaseHuawei<WithAsyncMethod_WriteLeaderboardRecord<WithAsyncMethod_WriteStorageObjects<WithAsyncMethod_WriteTournamentRecord<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_AddFriends : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_AddFriends() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::AddFriendsRequest, ::google::protobuf::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::AddFriendsRequest* request, ::google::protobuf::Empty* response) { return this->AddFriends(context, request, response); }));}
    void SetMessageAllocatorFor_AddFriends(
        ::grpc::experimental::MessageAllocator< ::nakama::api::AddFriendsRequest, ::google::protobuf::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::AddFriendsRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_AddFriends() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddFriends(::grpc::ServerContext* /*context*/, const ::nakama::api::AddFriendsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AddFriends(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::AddFriendsRequest* /*request*/, ::google::protobuf::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AddFriends(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::AddFriendsRequest* /*request*/, ::google::protobuf::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_AddGroupUsers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_AddGroupUsers() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::AddGroupUsersRequest, ::google::protobuf::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::AddGroupUsersRequest* request, ::google::protobuf::Empty* response) { return this->AddGroupUsers(context, request, response); }));}
    void SetMessageAllocatorFor_AddGroupUsers(
        ::grpc::experimental::MessageAllocator< ::nakama::api::AddGroupUsersRequest, ::google::protobuf::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::AddGroupUsersRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_AddGroupUsers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddGroupUsers(::grpc::ServerContext* /*context*/, const ::nakama::api::AddGroupUsersRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AddGroupUsers(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::AddGroupUsersRequest* /*request*/, ::google::protobuf::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AddGroupUsers(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::AddGroupUsersRequest* /*request*/, ::google::protobuf::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SessionRefresh : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SessionRefresh() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::SessionRefreshRequest, ::nakama::api::Session>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::SessionRefreshRequest* request, ::nakama::api::Session* response) { return this->SessionRefresh(context, request, response); }));}
    void SetMessageAllocatorFor_SessionRefresh(
        ::grpc::experimental::MessageAllocator< ::nakama::api::SessionRefreshRequest, ::nakama::api::Session>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(2);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::SessionRefreshRequest, ::nakama::api::Session>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SessionRefresh() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SessionRefresh(::grpc::ServerContext* /*context*/, const ::nakama::api::SessionRefreshRequest* /*request*/, ::nakama::api::Session* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SessionRefresh(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::SessionRefreshRequest* /*request*/, ::nakama::api::Session* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SessionRefresh(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::SessionRefreshRequest* /*request*/, ::nakama::api::Session* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SessionLogout : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SessionLogout() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::SessionLogoutRequest, ::google::protobuf::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::SessionLogoutRequest* request, ::google::protobuf::Empty* response) { return this->SessionLogout(context, request, response); }));}
    void SetMessageAllocatorFor_SessionLogout(
        ::grpc::experimental::MessageAllocator< ::nakama::api::SessionLogoutRequest, ::google::protobuf::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(3);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::SessionLogoutRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SessionLogout() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SessionLogout(::grpc::ServerContext* /*context*/, const ::nakama::api::SessionLogoutRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SessionLogout(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::SessionLogoutRequest* /*request*/, ::google::protobuf::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SessionLogout(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::SessionLogoutRequest* /*request*/, ::google::protobuf::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_AuthenticateApple : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_AuthenticateApple() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::AuthenticateAppleRequest, ::nakama::api::Session>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::AuthenticateAppleRequest* request, ::nakama::api::Session* response) { return this->AuthenticateApple(context, request, response); }));}
    void SetMessageAllocatorFor_AuthenticateApple(
        ::grpc::experimental::MessageAllocator< ::nakama::api::AuthenticateAppleRequest, ::nakama::api::Session>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(4);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::AuthenticateAppleRequest, ::nakama::api::Session>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_AuthenticateApple() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AuthenticateApple(::grpc::ServerContext* /*context*/, const ::nakama::api::AuthenticateAppleRequest* /*request*/, ::nakama::api::Session* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AuthenticateApple(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::AuthenticateAppleRequest* /*request*/, ::nakama::api::Session* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AuthenticateApple(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::AuthenticateAppleRequest* /*request*/, ::nakama::api::Session* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_AuthenticateCustom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_AuthenticateCustom() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::AuthenticateCustomRequest, ::nakama::api::Session>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::AuthenticateCustomRequest* request, ::nakama::api::Session* response) { return this->AuthenticateCustom(context, request, response); }));}
    void SetMessageAllocatorFor_AuthenticateCustom(
        ::grpc::experimental::MessageAllocator< ::nakama::api::AuthenticateCustomRequest, ::nakama::api::Session>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(5);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::AuthenticateCustomRequest, ::nakama::api::Session>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_AuthenticateCustom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AuthenticateCustom(::grpc::ServerContext* /*context*/, const ::nakama::api::AuthenticateCustomRequest* /*request*/, ::nakama::api::Session* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AuthenticateCustom(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::AuthenticateCustomRequest* /*request*/, ::nakama::api::Session* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AuthenticateCustom(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::AuthenticateCustomRequest* /*request*/, ::nakama::api::Session* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_AuthenticateDevice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_AuthenticateDevice() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::AuthenticateDeviceRequest, ::nakama::api::Session>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::AuthenticateDeviceRequest* request, ::nakama::api::Session* response) { return this->AuthenticateDevice(context, request, response); }));}
    void SetMessageAllocatorFor_AuthenticateDevice(
        ::grpc::experimental::MessageAllocator< ::nakama::api::AuthenticateDeviceRequest, ::nakama::api::Session>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(6);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::AuthenticateDeviceRequest, ::nakama::api::Session>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_AuthenticateDevice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AuthenticateDevice(::grpc::ServerContext* /*context*/, const ::nakama::api::AuthenticateDeviceRequest* /*request*/, ::nakama::api::Session* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AuthenticateDevice(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::AuthenticateDeviceRequest* /*request*/, ::nakama::api::Session* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AuthenticateDevice(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::AuthenticateDeviceRequest* /*request*/, ::nakama::api::Session* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_AuthenticateEmail : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_AuthenticateEmail() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::AuthenticateEmailRequest, ::nakama::api::Session>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::AuthenticateEmailRequest* request, ::nakama::api::Session* response) { return this->AuthenticateEmail(context, request, response); }));}
    void SetMessageAllocatorFor_AuthenticateEmail(
        ::grpc::experimental::MessageAllocator< ::nakama::api::AuthenticateEmailRequest, ::nakama::api::Session>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(7);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::AuthenticateEmailRequest, ::nakama::api::Session>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_AuthenticateEmail() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AuthenticateEmail(::grpc::ServerContext* /*context*/, const ::nakama::api::AuthenticateEmailRequest* /*request*/, ::nakama::api::Session* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AuthenticateEmail(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::AuthenticateEmailRequest* /*request*/, ::nakama::api::Session* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AuthenticateEmail(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::AuthenticateEmailRequest* /*request*/, ::nakama::api::Session* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_AuthenticateFacebook : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_AuthenticateFacebook() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::AuthenticateFacebookRequest, ::nakama::api::Session>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::AuthenticateFacebookRequest* request, ::nakama::api::Session* response) { return this->AuthenticateFacebook(context, request, response); }));}
    void SetMessageAllocatorFor_AuthenticateFacebook(
        ::grpc::experimental::MessageAllocator< ::nakama::api::AuthenticateFacebookRequest, ::nakama::api::Session>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(8);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::AuthenticateFacebookRequest, ::nakama::api::Session>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_AuthenticateFacebook() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AuthenticateFacebook(::grpc::ServerContext* /*context*/, const ::nakama::api::AuthenticateFacebookRequest* /*request*/, ::nakama::api::Session* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AuthenticateFacebook(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::AuthenticateFacebookRequest* /*request*/, ::nakama::api::Session* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AuthenticateFacebook(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::AuthenticateFacebookRequest* /*request*/, ::nakama::api::Session* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_AuthenticateFacebookInstantGame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_AuthenticateFacebookInstantGame() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::AuthenticateFacebookInstantGameRequest, ::nakama::api::Session>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::AuthenticateFacebookInstantGameRequest* request, ::nakama::api::Session* response) { return this->AuthenticateFacebookInstantGame(context, request, response); }));}
    void SetMessageAllocatorFor_AuthenticateFacebookInstantGame(
        ::grpc::experimental::MessageAllocator< ::nakama::api::AuthenticateFacebookInstantGameRequest, ::nakama::api::Session>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(9);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::AuthenticateFacebookInstantGameRequest, ::nakama::api::Session>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_AuthenticateFacebookInstantGame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AuthenticateFacebookInstantGame(::grpc::ServerContext* /*context*/, const ::nakama::api::AuthenticateFacebookInstantGameRequest* /*request*/, ::nakama::api::Session* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AuthenticateFacebookInstantGame(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::AuthenticateFacebookInstantGameRequest* /*request*/, ::nakama::api::Session* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AuthenticateFacebookInstantGame(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::AuthenticateFacebookInstantGameRequest* /*request*/, ::nakama::api::Session* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_AuthenticateGameCenter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_AuthenticateGameCenter() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::AuthenticateGameCenterRequest, ::nakama::api::Session>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::AuthenticateGameCenterRequest* request, ::nakama::api::Session* response) { return this->AuthenticateGameCenter(context, request, response); }));}
    void SetMessageAllocatorFor_AuthenticateGameCenter(
        ::grpc::experimental::MessageAllocator< ::nakama::api::AuthenticateGameCenterRequest, ::nakama::api::Session>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(10);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::AuthenticateGameCenterRequest, ::nakama::api::Session>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_AuthenticateGameCenter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AuthenticateGameCenter(::grpc::ServerContext* /*context*/, const ::nakama::api::AuthenticateGameCenterRequest* /*request*/, ::nakama::api::Session* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AuthenticateGameCenter(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::AuthenticateGameCenterRequest* /*request*/, ::nakama::api::Session* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AuthenticateGameCenter(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::AuthenticateGameCenterRequest* /*request*/, ::nakama::api::Session* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_AuthenticateGoogle : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_AuthenticateGoogle() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::AuthenticateGoogleRequest, ::nakama::api::Session>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::AuthenticateGoogleRequest* request, ::nakama::api::Session* response) { return this->AuthenticateGoogle(context, request, response); }));}
    void SetMessageAllocatorFor_AuthenticateGoogle(
        ::grpc::experimental::MessageAllocator< ::nakama::api::AuthenticateGoogleRequest, ::nakama::api::Session>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(11);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::AuthenticateGoogleRequest, ::nakama::api::Session>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_AuthenticateGoogle() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AuthenticateGoogle(::grpc::ServerContext* /*context*/, const ::nakama::api::AuthenticateGoogleRequest* /*request*/, ::nakama::api::Session* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AuthenticateGoogle(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::AuthenticateGoogleRequest* /*request*/, ::nakama::api::Session* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AuthenticateGoogle(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::AuthenticateGoogleRequest* /*request*/, ::nakama::api::Session* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_AuthenticateSteam : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_AuthenticateSteam() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::AuthenticateSteamRequest, ::nakama::api::Session>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::AuthenticateSteamRequest* request, ::nakama::api::Session* response) { return this->AuthenticateSteam(context, request, response); }));}
    void SetMessageAllocatorFor_AuthenticateSteam(
        ::grpc::experimental::MessageAllocator< ::nakama::api::AuthenticateSteamRequest, ::nakama::api::Session>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(12);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::AuthenticateSteamRequest, ::nakama::api::Session>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_AuthenticateSteam() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AuthenticateSteam(::grpc::ServerContext* /*context*/, const ::nakama::api::AuthenticateSteamRequest* /*request*/, ::nakama::api::Session* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AuthenticateSteam(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::AuthenticateSteamRequest* /*request*/, ::nakama::api::Session* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AuthenticateSteam(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::AuthenticateSteamRequest* /*request*/, ::nakama::api::Session* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_BanGroupUsers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_BanGroupUsers() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::BanGroupUsersRequest, ::google::protobuf::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::BanGroupUsersRequest* request, ::google::protobuf::Empty* response) { return this->BanGroupUsers(context, request, response); }));}
    void SetMessageAllocatorFor_BanGroupUsers(
        ::grpc::experimental::MessageAllocator< ::nakama::api::BanGroupUsersRequest, ::google::protobuf::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(13);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::BanGroupUsersRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_BanGroupUsers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BanGroupUsers(::grpc::ServerContext* /*context*/, const ::nakama::api::BanGroupUsersRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* BanGroupUsers(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::BanGroupUsersRequest* /*request*/, ::google::protobuf::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* BanGroupUsers(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::BanGroupUsersRequest* /*request*/, ::google::protobuf::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_BlockFriends : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_BlockFriends() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::BlockFriendsRequest, ::google::protobuf::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::BlockFriendsRequest* request, ::google::protobuf::Empty* response) { return this->BlockFriends(context, request, response); }));}
    void SetMessageAllocatorFor_BlockFriends(
        ::grpc::experimental::MessageAllocator< ::nakama::api::BlockFriendsRequest, ::google::protobuf::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(14);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(14);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::BlockFriendsRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_BlockFriends() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BlockFriends(::grpc::ServerContext* /*context*/, const ::nakama::api::BlockFriendsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* BlockFriends(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::BlockFriendsRequest* /*request*/, ::google::protobuf::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* BlockFriends(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::BlockFriendsRequest* /*request*/, ::google::protobuf::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CreateGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_CreateGroup() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::CreateGroupRequest, ::nakama::api::Group>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::CreateGroupRequest* request, ::nakama::api::Group* response) { return this->CreateGroup(context, request, response); }));}
    void SetMessageAllocatorFor_CreateGroup(
        ::grpc::experimental::MessageAllocator< ::nakama::api::CreateGroupRequest, ::nakama::api::Group>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(15);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(15);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::CreateGroupRequest, ::nakama::api::Group>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_CreateGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateGroup(::grpc::ServerContext* /*context*/, const ::nakama::api::CreateGroupRequest* /*request*/, ::nakama::api::Group* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CreateGroup(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::CreateGroupRequest* /*request*/, ::nakama::api::Group* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CreateGroup(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::CreateGroupRequest* /*request*/, ::nakama::api::Group* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteFriends : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DeleteFriends() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::DeleteFriendsRequest, ::google::protobuf::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::DeleteFriendsRequest* request, ::google::protobuf::Empty* response) { return this->DeleteFriends(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteFriends(
        ::grpc::experimental::MessageAllocator< ::nakama::api::DeleteFriendsRequest, ::google::protobuf::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(16);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(16);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::DeleteFriendsRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteFriends() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteFriends(::grpc::ServerContext* /*context*/, const ::nakama::api::DeleteFriendsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteFriends(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::DeleteFriendsRequest* /*request*/, ::google::protobuf::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteFriends(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::DeleteFriendsRequest* /*request*/, ::google::protobuf::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DeleteGroup() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::DeleteGroupRequest, ::google::protobuf::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::DeleteGroupRequest* request, ::google::protobuf::Empty* response) { return this->DeleteGroup(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteGroup(
        ::grpc::experimental::MessageAllocator< ::nakama::api::DeleteGroupRequest, ::google::protobuf::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(17);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(17);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::DeleteGroupRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteGroup(::grpc::ServerContext* /*context*/, const ::nakama::api::DeleteGroupRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteGroup(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::DeleteGroupRequest* /*request*/, ::google::protobuf::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteGroup(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::DeleteGroupRequest* /*request*/, ::google::protobuf::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteLeaderboardRecord : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DeleteLeaderboardRecord() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::DeleteLeaderboardRecordRequest, ::google::protobuf::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::DeleteLeaderboardRecordRequest* request, ::google::protobuf::Empty* response) { return this->DeleteLeaderboardRecord(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteLeaderboardRecord(
        ::grpc::experimental::MessageAllocator< ::nakama::api::DeleteLeaderboardRecordRequest, ::google::protobuf::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(18);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(18);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::DeleteLeaderboardRecordRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteLeaderboardRecord() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteLeaderboardRecord(::grpc::ServerContext* /*context*/, const ::nakama::api::DeleteLeaderboardRecordRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteLeaderboardRecord(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::DeleteLeaderboardRecordRequest* /*request*/, ::google::protobuf::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteLeaderboardRecord(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::DeleteLeaderboardRecordRequest* /*request*/, ::google::protobuf::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteNotifications : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DeleteNotifications() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::DeleteNotificationsRequest, ::google::protobuf::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::DeleteNotificationsRequest* request, ::google::protobuf::Empty* response) { return this->DeleteNotifications(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteNotifications(
        ::grpc::experimental::MessageAllocator< ::nakama::api::DeleteNotificationsRequest, ::google::protobuf::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(19);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(19);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::DeleteNotificationsRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteNotifications() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteNotifications(::grpc::ServerContext* /*context*/, const ::nakama::api::DeleteNotificationsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteNotifications(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::DeleteNotificationsRequest* /*request*/, ::google::protobuf::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteNotifications(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::DeleteNotificationsRequest* /*request*/, ::google::protobuf::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteStorageObjects : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DeleteStorageObjects() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(20,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::DeleteStorageObjectsRequest, ::google::protobuf::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::DeleteStorageObjectsRequest* request, ::google::protobuf::Empty* response) { return this->DeleteStorageObjects(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteStorageObjects(
        ::grpc::experimental::MessageAllocator< ::nakama::api::DeleteStorageObjectsRequest, ::google::protobuf::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(20);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(20);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::DeleteStorageObjectsRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteStorageObjects() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteStorageObjects(::grpc::ServerContext* /*context*/, const ::nakama::api::DeleteStorageObjectsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteStorageObjects(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::DeleteStorageObjectsRequest* /*request*/, ::google::protobuf::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteStorageObjects(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::DeleteStorageObjectsRequest* /*request*/, ::google::protobuf::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Event : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Event() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(21,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::Event, ::google::protobuf::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::Event* request, ::google::protobuf::Empty* response) { return this->Event(context, request, response); }));}
    void SetMessageAllocatorFor_Event(
        ::grpc::experimental::MessageAllocator< ::nakama::api::Event, ::google::protobuf::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(21);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(21);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::Event, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Event() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Event(::grpc::ServerContext* /*context*/, const ::nakama::api::Event* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Event(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::Event* /*request*/, ::google::protobuf::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Event(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::Event* /*request*/, ::google::protobuf::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetAccount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetAccount() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(22,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::nakama::api::Account>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::google::protobuf::Empty* request, ::nakama::api::Account* response) { return this->GetAccount(context, request, response); }));}
    void SetMessageAllocatorFor_GetAccount(
        ::grpc::experimental::MessageAllocator< ::google::protobuf::Empty, ::nakama::api::Account>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(22);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(22);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::nakama::api::Account>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetAccount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAccount(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::nakama::api::Account* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetAccount(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::nakama::api::Account* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetAccount(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::nakama::api::Account* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetUsers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetUsers() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(23,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::GetUsersRequest, ::nakama::api::Users>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::GetUsersRequest* request, ::nakama::api::Users* response) { return this->GetUsers(context, request, response); }));}
    void SetMessageAllocatorFor_GetUsers(
        ::grpc::experimental::MessageAllocator< ::nakama::api::GetUsersRequest, ::nakama::api::Users>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(23);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(23);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::GetUsersRequest, ::nakama::api::Users>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetUsers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetUsers(::grpc::ServerContext* /*context*/, const ::nakama::api::GetUsersRequest* /*request*/, ::nakama::api::Users* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetUsers(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::GetUsersRequest* /*request*/, ::nakama::api::Users* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetUsers(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::GetUsersRequest* /*request*/, ::nakama::api::Users* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Healthcheck : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Healthcheck() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(24,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::google::protobuf::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response) { return this->Healthcheck(context, request, response); }));}
    void SetMessageAllocatorFor_Healthcheck(
        ::grpc::experimental::MessageAllocator< ::google::protobuf::Empty, ::google::protobuf::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(24);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(24);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Healthcheck() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Healthcheck(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Healthcheck(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Healthcheck(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ImportFacebookFriends : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ImportFacebookFriends() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(25,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::ImportFacebookFriendsRequest, ::google::protobuf::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::ImportFacebookFriendsRequest* request, ::google::protobuf::Empty* response) { return this->ImportFacebookFriends(context, request, response); }));}
    void SetMessageAllocatorFor_ImportFacebookFriends(
        ::grpc::experimental::MessageAllocator< ::nakama::api::ImportFacebookFriendsRequest, ::google::protobuf::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(25);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(25);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::ImportFacebookFriendsRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ImportFacebookFriends() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportFacebookFriends(::grpc::ServerContext* /*context*/, const ::nakama::api::ImportFacebookFriendsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ImportFacebookFriends(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::ImportFacebookFriendsRequest* /*request*/, ::google::protobuf::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ImportFacebookFriends(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::ImportFacebookFriendsRequest* /*request*/, ::google::protobuf::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ImportSteamFriends : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ImportSteamFriends() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(26,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::ImportSteamFriendsRequest, ::google::protobuf::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::ImportSteamFriendsRequest* request, ::google::protobuf::Empty* response) { return this->ImportSteamFriends(context, request, response); }));}
    void SetMessageAllocatorFor_ImportSteamFriends(
        ::grpc::experimental::MessageAllocator< ::nakama::api::ImportSteamFriendsRequest, ::google::protobuf::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(26);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(26);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::ImportSteamFriendsRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ImportSteamFriends() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportSteamFriends(::grpc::ServerContext* /*context*/, const ::nakama::api::ImportSteamFriendsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ImportSteamFriends(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::ImportSteamFriendsRequest* /*request*/, ::google::protobuf::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ImportSteamFriends(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::ImportSteamFriendsRequest* /*request*/, ::google::protobuf::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_JoinGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_JoinGroup() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(27,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::JoinGroupRequest, ::google::protobuf::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::JoinGroupRequest* request, ::google::protobuf::Empty* response) { return this->JoinGroup(context, request, response); }));}
    void SetMessageAllocatorFor_JoinGroup(
        ::grpc::experimental::MessageAllocator< ::nakama::api::JoinGroupRequest, ::google::protobuf::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(27);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(27);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::JoinGroupRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_JoinGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status JoinGroup(::grpc::ServerContext* /*context*/, const ::nakama::api::JoinGroupRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* JoinGroup(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::JoinGroupRequest* /*request*/, ::google::protobuf::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* JoinGroup(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::JoinGroupRequest* /*request*/, ::google::protobuf::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_JoinTournament : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_JoinTournament() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(28,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::JoinTournamentRequest, ::google::protobuf::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::JoinTournamentRequest* request, ::google::protobuf::Empty* response) { return this->JoinTournament(context, request, response); }));}
    void SetMessageAllocatorFor_JoinTournament(
        ::grpc::experimental::MessageAllocator< ::nakama::api::JoinTournamentRequest, ::google::protobuf::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(28);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(28);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::JoinTournamentRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_JoinTournament() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status JoinTournament(::grpc::ServerContext* /*context*/, const ::nakama::api::JoinTournamentRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* JoinTournament(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::JoinTournamentRequest* /*request*/, ::google::protobuf::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* JoinTournament(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::JoinTournamentRequest* /*request*/, ::google::protobuf::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_KickGroupUsers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_KickGroupUsers() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(29,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::KickGroupUsersRequest, ::google::protobuf::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::KickGroupUsersRequest* request, ::google::protobuf::Empty* response) { return this->KickGroupUsers(context, request, response); }));}
    void SetMessageAllocatorFor_KickGroupUsers(
        ::grpc::experimental::MessageAllocator< ::nakama::api::KickGroupUsersRequest, ::google::protobuf::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(29);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(29);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::KickGroupUsersRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_KickGroupUsers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KickGroupUsers(::grpc::ServerContext* /*context*/, const ::nakama::api::KickGroupUsersRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* KickGroupUsers(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::KickGroupUsersRequest* /*request*/, ::google::protobuf::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* KickGroupUsers(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::KickGroupUsersRequest* /*request*/, ::google::protobuf::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_LeaveGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_LeaveGroup() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(30,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::LeaveGroupRequest, ::google::protobuf::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::LeaveGroupRequest* request, ::google::protobuf::Empty* response) { return this->LeaveGroup(context, request, response); }));}
    void SetMessageAllocatorFor_LeaveGroup(
        ::grpc::experimental::MessageAllocator< ::nakama::api::LeaveGroupRequest, ::google::protobuf::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(30);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(30);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::LeaveGroupRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_LeaveGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LeaveGroup(::grpc::ServerContext* /*context*/, const ::nakama::api::LeaveGroupRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* LeaveGroup(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::LeaveGroupRequest* /*request*/, ::google::protobuf::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* LeaveGroup(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::LeaveGroupRequest* /*request*/, ::google::protobuf::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_LinkApple : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_LinkApple() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(31,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::AccountApple, ::google::protobuf::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::AccountApple* request, ::google::protobuf::Empty* response) { return this->LinkApple(context, request, response); }));}
    void SetMessageAllocatorFor_LinkApple(
        ::grpc::experimental::MessageAllocator< ::nakama::api::AccountApple, ::google::protobuf::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(31);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(31);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::AccountApple, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_LinkApple() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LinkApple(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountApple* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* LinkApple(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::AccountApple* /*request*/, ::google::protobuf::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* LinkApple(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::AccountApple* /*request*/, ::google::protobuf::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_LinkCustom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_LinkCustom() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(32,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::AccountCustom, ::google::protobuf::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::AccountCustom* request, ::google::protobuf::Empty* response) { return this->LinkCustom(context, request, response); }));}
    void SetMessageAllocatorFor_LinkCustom(
        ::grpc::experimental::MessageAllocator< ::nakama::api::AccountCustom, ::google::protobuf::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(32);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(32);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::AccountCustom, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_LinkCustom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LinkCustom(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountCustom* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* LinkCustom(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::AccountCustom* /*request*/, ::google::protobuf::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* LinkCustom(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::AccountCustom* /*request*/, ::google::protobuf::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_LinkDevice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_LinkDevice() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(33,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::AccountDevice, ::google::protobuf::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::AccountDevice* request, ::google::protobuf::Empty* response) { return this->LinkDevice(context, request, response); }));}
    void SetMessageAllocatorFor_LinkDevice(
        ::grpc::experimental::MessageAllocator< ::nakama::api::AccountDevice, ::google::protobuf::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(33);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(33);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::AccountDevice, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_LinkDevice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LinkDevice(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountDevice* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* LinkDevice(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::AccountDevice* /*request*/, ::google::protobuf::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* LinkDevice(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::AccountDevice* /*request*/, ::google::protobuf::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_LinkEmail : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_LinkEmail() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(34,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::AccountEmail, ::google::protobuf::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::AccountEmail* request, ::google::protobuf::Empty* response) { return this->LinkEmail(context, request, response); }));}
    void SetMessageAllocatorFor_LinkEmail(
        ::grpc::experimental::MessageAllocator< ::nakama::api::AccountEmail, ::google::protobuf::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(34);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(34);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::AccountEmail, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_LinkEmail() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LinkEmail(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountEmail* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* LinkEmail(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::AccountEmail* /*request*/, ::google::protobuf::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* LinkEmail(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::AccountEmail* /*request*/, ::google::protobuf::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_LinkFacebook : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_LinkFacebook() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(35,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::LinkFacebookRequest, ::google::protobuf::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::LinkFacebookRequest* request, ::google::protobuf::Empty* response) { return this->LinkFacebook(context, request, response); }));}
    void SetMessageAllocatorFor_LinkFacebook(
        ::grpc::experimental::MessageAllocator< ::nakama::api::LinkFacebookRequest, ::google::protobuf::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(35);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(35);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::LinkFacebookRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_LinkFacebook() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LinkFacebook(::grpc::ServerContext* /*context*/, const ::nakama::api::LinkFacebookRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* LinkFacebook(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::LinkFacebookRequest* /*request*/, ::google::protobuf::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* LinkFacebook(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::LinkFacebookRequest* /*request*/, ::google::protobuf::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_LinkFacebookInstantGame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_LinkFacebookInstantGame() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(36,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::AccountFacebookInstantGame, ::google::protobuf::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::AccountFacebookInstantGame* request, ::google::protobuf::Empty* response) { return this->LinkFacebookInstantGame(context, request, response); }));}
    void SetMessageAllocatorFor_LinkFacebookInstantGame(
        ::grpc::experimental::MessageAllocator< ::nakama::api::AccountFacebookInstantGame, ::google::protobuf::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(36);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(36);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::AccountFacebookInstantGame, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_LinkFacebookInstantGame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LinkFacebookInstantGame(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountFacebookInstantGame* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* LinkFacebookInstantGame(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::AccountFacebookInstantGame* /*request*/, ::google::protobuf::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* LinkFacebookInstantGame(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::AccountFacebookInstantGame* /*request*/, ::google::protobuf::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_LinkGameCenter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_LinkGameCenter() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(37,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::AccountGameCenter, ::google::protobuf::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::AccountGameCenter* request, ::google::protobuf::Empty* response) { return this->LinkGameCenter(context, request, response); }));}
    void SetMessageAllocatorFor_LinkGameCenter(
        ::grpc::experimental::MessageAllocator< ::nakama::api::AccountGameCenter, ::google::protobuf::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(37);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(37);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::AccountGameCenter, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_LinkGameCenter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LinkGameCenter(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountGameCenter* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* LinkGameCenter(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::AccountGameCenter* /*request*/, ::google::protobuf::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* LinkGameCenter(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::AccountGameCenter* /*request*/, ::google::protobuf::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_LinkGoogle : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_LinkGoogle() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(38,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::AccountGoogle, ::google::protobuf::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::AccountGoogle* request, ::google::protobuf::Empty* response) { return this->LinkGoogle(context, request, response); }));}
    void SetMessageAllocatorFor_LinkGoogle(
        ::grpc::experimental::MessageAllocator< ::nakama::api::AccountGoogle, ::google::protobuf::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(38);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(38);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::AccountGoogle, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_LinkGoogle() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LinkGoogle(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountGoogle* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* LinkGoogle(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::AccountGoogle* /*request*/, ::google::protobuf::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* LinkGoogle(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::AccountGoogle* /*request*/, ::google::protobuf::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_LinkSteam : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_LinkSteam() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(39,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::LinkSteamRequest, ::google::protobuf::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::LinkSteamRequest* request, ::google::protobuf::Empty* response) { return this->LinkSteam(context, request, response); }));}
    void SetMessageAllocatorFor_LinkSteam(
        ::grpc::experimental::MessageAllocator< ::nakama::api::LinkSteamRequest, ::google::protobuf::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(39);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(39);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::LinkSteamRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_LinkSteam() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LinkSteam(::grpc::ServerContext* /*context*/, const ::nakama::api::LinkSteamRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* LinkSteam(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::LinkSteamRequest* /*request*/, ::google::protobuf::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* LinkSteam(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::LinkSteamRequest* /*request*/, ::google::protobuf::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListChannelMessages : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListChannelMessages() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(40,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::ListChannelMessagesRequest, ::nakama::api::ChannelMessageList>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::ListChannelMessagesRequest* request, ::nakama::api::ChannelMessageList* response) { return this->ListChannelMessages(context, request, response); }));}
    void SetMessageAllocatorFor_ListChannelMessages(
        ::grpc::experimental::MessageAllocator< ::nakama::api::ListChannelMessagesRequest, ::nakama::api::ChannelMessageList>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(40);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(40);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::ListChannelMessagesRequest, ::nakama::api::ChannelMessageList>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListChannelMessages() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListChannelMessages(::grpc::ServerContext* /*context*/, const ::nakama::api::ListChannelMessagesRequest* /*request*/, ::nakama::api::ChannelMessageList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListChannelMessages(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::ListChannelMessagesRequest* /*request*/, ::nakama::api::ChannelMessageList* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListChannelMessages(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::ListChannelMessagesRequest* /*request*/, ::nakama::api::ChannelMessageList* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListFriends : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListFriends() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(41,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::ListFriendsRequest, ::nakama::api::FriendList>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::ListFriendsRequest* request, ::nakama::api::FriendList* response) { return this->ListFriends(context, request, response); }));}
    void SetMessageAllocatorFor_ListFriends(
        ::grpc::experimental::MessageAllocator< ::nakama::api::ListFriendsRequest, ::nakama::api::FriendList>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(41);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(41);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::ListFriendsRequest, ::nakama::api::FriendList>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListFriends() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListFriends(::grpc::ServerContext* /*context*/, const ::nakama::api::ListFriendsRequest* /*request*/, ::nakama::api::FriendList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListFriends(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::ListFriendsRequest* /*request*/, ::nakama::api::FriendList* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListFriends(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::ListFriendsRequest* /*request*/, ::nakama::api::FriendList* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListGroups : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListGroups() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(42,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::ListGroupsRequest, ::nakama::api::GroupList>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::ListGroupsRequest* request, ::nakama::api::GroupList* response) { return this->ListGroups(context, request, response); }));}
    void SetMessageAllocatorFor_ListGroups(
        ::grpc::experimental::MessageAllocator< ::nakama::api::ListGroupsRequest, ::nakama::api::GroupList>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(42);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(42);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::ListGroupsRequest, ::nakama::api::GroupList>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListGroups() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListGroups(::grpc::ServerContext* /*context*/, const ::nakama::api::ListGroupsRequest* /*request*/, ::nakama::api::GroupList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListGroups(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::ListGroupsRequest* /*request*/, ::nakama::api::GroupList* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListGroups(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::ListGroupsRequest* /*request*/, ::nakama::api::GroupList* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListGroupUsers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListGroupUsers() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(43,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::ListGroupUsersRequest, ::nakama::api::GroupUserList>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::ListGroupUsersRequest* request, ::nakama::api::GroupUserList* response) { return this->ListGroupUsers(context, request, response); }));}
    void SetMessageAllocatorFor_ListGroupUsers(
        ::grpc::experimental::MessageAllocator< ::nakama::api::ListGroupUsersRequest, ::nakama::api::GroupUserList>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(43);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(43);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::ListGroupUsersRequest, ::nakama::api::GroupUserList>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListGroupUsers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListGroupUsers(::grpc::ServerContext* /*context*/, const ::nakama::api::ListGroupUsersRequest* /*request*/, ::nakama::api::GroupUserList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListGroupUsers(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::ListGroupUsersRequest* /*request*/, ::nakama::api::GroupUserList* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListGroupUsers(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::ListGroupUsersRequest* /*request*/, ::nakama::api::GroupUserList* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListLeaderboardRecords : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListLeaderboardRecords() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(44,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::ListLeaderboardRecordsRequest, ::nakama::api::LeaderboardRecordList>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::ListLeaderboardRecordsRequest* request, ::nakama::api::LeaderboardRecordList* response) { return this->ListLeaderboardRecords(context, request, response); }));}
    void SetMessageAllocatorFor_ListLeaderboardRecords(
        ::grpc::experimental::MessageAllocator< ::nakama::api::ListLeaderboardRecordsRequest, ::nakama::api::LeaderboardRecordList>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(44);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(44);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::ListLeaderboardRecordsRequest, ::nakama::api::LeaderboardRecordList>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListLeaderboardRecords() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListLeaderboardRecords(::grpc::ServerContext* /*context*/, const ::nakama::api::ListLeaderboardRecordsRequest* /*request*/, ::nakama::api::LeaderboardRecordList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListLeaderboardRecords(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::ListLeaderboardRecordsRequest* /*request*/, ::nakama::api::LeaderboardRecordList* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListLeaderboardRecords(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::ListLeaderboardRecordsRequest* /*request*/, ::nakama::api::LeaderboardRecordList* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListLeaderboardRecordsAroundOwner : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListLeaderboardRecordsAroundOwner() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(45,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::ListLeaderboardRecordsAroundOwnerRequest, ::nakama::api::LeaderboardRecordList>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::ListLeaderboardRecordsAroundOwnerRequest* request, ::nakama::api::LeaderboardRecordList* response) { return this->ListLeaderboardRecordsAroundOwner(context, request, response); }));}
    void SetMessageAllocatorFor_ListLeaderboardRecordsAroundOwner(
        ::grpc::experimental::MessageAllocator< ::nakama::api::ListLeaderboardRecordsAroundOwnerRequest, ::nakama::api::LeaderboardRecordList>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(45);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(45);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::ListLeaderboardRecordsAroundOwnerRequest, ::nakama::api::LeaderboardRecordList>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListLeaderboardRecordsAroundOwner() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListLeaderboardRecordsAroundOwner(::grpc::ServerContext* /*context*/, const ::nakama::api::ListLeaderboardRecordsAroundOwnerRequest* /*request*/, ::nakama::api::LeaderboardRecordList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListLeaderboardRecordsAroundOwner(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::ListLeaderboardRecordsAroundOwnerRequest* /*request*/, ::nakama::api::LeaderboardRecordList* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListLeaderboardRecordsAroundOwner(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::ListLeaderboardRecordsAroundOwnerRequest* /*request*/, ::nakama::api::LeaderboardRecordList* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListMatches : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListMatches() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(46,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::ListMatchesRequest, ::nakama::api::MatchList>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::ListMatchesRequest* request, ::nakama::api::MatchList* response) { return this->ListMatches(context, request, response); }));}
    void SetMessageAllocatorFor_ListMatches(
        ::grpc::experimental::MessageAllocator< ::nakama::api::ListMatchesRequest, ::nakama::api::MatchList>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(46);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(46);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::ListMatchesRequest, ::nakama::api::MatchList>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListMatches() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListMatches(::grpc::ServerContext* /*context*/, const ::nakama::api::ListMatchesRequest* /*request*/, ::nakama::api::MatchList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListMatches(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::ListMatchesRequest* /*request*/, ::nakama::api::MatchList* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListMatches(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::ListMatchesRequest* /*request*/, ::nakama::api::MatchList* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListNotifications : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListNotifications() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(47,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::ListNotificationsRequest, ::nakama::api::NotificationList>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::ListNotificationsRequest* request, ::nakama::api::NotificationList* response) { return this->ListNotifications(context, request, response); }));}
    void SetMessageAllocatorFor_ListNotifications(
        ::grpc::experimental::MessageAllocator< ::nakama::api::ListNotificationsRequest, ::nakama::api::NotificationList>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(47);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(47);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::ListNotificationsRequest, ::nakama::api::NotificationList>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListNotifications() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListNotifications(::grpc::ServerContext* /*context*/, const ::nakama::api::ListNotificationsRequest* /*request*/, ::nakama::api::NotificationList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListNotifications(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::ListNotificationsRequest* /*request*/, ::nakama::api::NotificationList* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListNotifications(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::ListNotificationsRequest* /*request*/, ::nakama::api::NotificationList* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListStorageObjects : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListStorageObjects() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(48,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::ListStorageObjectsRequest, ::nakama::api::StorageObjectList>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::ListStorageObjectsRequest* request, ::nakama::api::StorageObjectList* response) { return this->ListStorageObjects(context, request, response); }));}
    void SetMessageAllocatorFor_ListStorageObjects(
        ::grpc::experimental::MessageAllocator< ::nakama::api::ListStorageObjectsRequest, ::nakama::api::StorageObjectList>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(48);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(48);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::ListStorageObjectsRequest, ::nakama::api::StorageObjectList>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListStorageObjects() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListStorageObjects(::grpc::ServerContext* /*context*/, const ::nakama::api::ListStorageObjectsRequest* /*request*/, ::nakama::api::StorageObjectList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListStorageObjects(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::ListStorageObjectsRequest* /*request*/, ::nakama::api::StorageObjectList* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListStorageObjects(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::ListStorageObjectsRequest* /*request*/, ::nakama::api::StorageObjectList* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListTournaments : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListTournaments() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(49,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::ListTournamentsRequest, ::nakama::api::TournamentList>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::ListTournamentsRequest* request, ::nakama::api::TournamentList* response) { return this->ListTournaments(context, request, response); }));}
    void SetMessageAllocatorFor_ListTournaments(
        ::grpc::experimental::MessageAllocator< ::nakama::api::ListTournamentsRequest, ::nakama::api::TournamentList>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(49);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(49);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::ListTournamentsRequest, ::nakama::api::TournamentList>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListTournaments() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListTournaments(::grpc::ServerContext* /*context*/, const ::nakama::api::ListTournamentsRequest* /*request*/, ::nakama::api::TournamentList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListTournaments(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::ListTournamentsRequest* /*request*/, ::nakama::api::TournamentList* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListTournaments(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::ListTournamentsRequest* /*request*/, ::nakama::api::TournamentList* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListTournamentRecords : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListTournamentRecords() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(50,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::ListTournamentRecordsRequest, ::nakama::api::TournamentRecordList>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::ListTournamentRecordsRequest* request, ::nakama::api::TournamentRecordList* response) { return this->ListTournamentRecords(context, request, response); }));}
    void SetMessageAllocatorFor_ListTournamentRecords(
        ::grpc::experimental::MessageAllocator< ::nakama::api::ListTournamentRecordsRequest, ::nakama::api::TournamentRecordList>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(50);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(50);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::ListTournamentRecordsRequest, ::nakama::api::TournamentRecordList>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListTournamentRecords() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListTournamentRecords(::grpc::ServerContext* /*context*/, const ::nakama::api::ListTournamentRecordsRequest* /*request*/, ::nakama::api::TournamentRecordList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListTournamentRecords(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::ListTournamentRecordsRequest* /*request*/, ::nakama::api::TournamentRecordList* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListTournamentRecords(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::ListTournamentRecordsRequest* /*request*/, ::nakama::api::TournamentRecordList* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListTournamentRecordsAroundOwner : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListTournamentRecordsAroundOwner() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(51,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::ListTournamentRecordsAroundOwnerRequest, ::nakama::api::TournamentRecordList>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::ListTournamentRecordsAroundOwnerRequest* request, ::nakama::api::TournamentRecordList* response) { return this->ListTournamentRecordsAroundOwner(context, request, response); }));}
    void SetMessageAllocatorFor_ListTournamentRecordsAroundOwner(
        ::grpc::experimental::MessageAllocator< ::nakama::api::ListTournamentRecordsAroundOwnerRequest, ::nakama::api::TournamentRecordList>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(51);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(51);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::ListTournamentRecordsAroundOwnerRequest, ::nakama::api::TournamentRecordList>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListTournamentRecordsAroundOwner() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListTournamentRecordsAroundOwner(::grpc::ServerContext* /*context*/, const ::nakama::api::ListTournamentRecordsAroundOwnerRequest* /*request*/, ::nakama::api::TournamentRecordList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListTournamentRecordsAroundOwner(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::ListTournamentRecordsAroundOwnerRequest* /*request*/, ::nakama::api::TournamentRecordList* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListTournamentRecordsAroundOwner(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::ListTournamentRecordsAroundOwnerRequest* /*request*/, ::nakama::api::TournamentRecordList* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListUserGroups : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListUserGroups() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(52,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::ListUserGroupsRequest, ::nakama::api::UserGroupList>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::ListUserGroupsRequest* request, ::nakama::api::UserGroupList* response) { return this->ListUserGroups(context, request, response); }));}
    void SetMessageAllocatorFor_ListUserGroups(
        ::grpc::experimental::MessageAllocator< ::nakama::api::ListUserGroupsRequest, ::nakama::api::UserGroupList>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(52);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(52);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::ListUserGroupsRequest, ::nakama::api::UserGroupList>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListUserGroups() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListUserGroups(::grpc::ServerContext* /*context*/, const ::nakama::api::ListUserGroupsRequest* /*request*/, ::nakama::api::UserGroupList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListUserGroups(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::ListUserGroupsRequest* /*request*/, ::nakama::api::UserGroupList* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListUserGroups(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::ListUserGroupsRequest* /*request*/, ::nakama::api::UserGroupList* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PromoteGroupUsers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PromoteGroupUsers() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(53,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::PromoteGroupUsersRequest, ::google::protobuf::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::PromoteGroupUsersRequest* request, ::google::protobuf::Empty* response) { return this->PromoteGroupUsers(context, request, response); }));}
    void SetMessageAllocatorFor_PromoteGroupUsers(
        ::grpc::experimental::MessageAllocator< ::nakama::api::PromoteGroupUsersRequest, ::google::protobuf::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(53);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(53);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::PromoteGroupUsersRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PromoteGroupUsers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PromoteGroupUsers(::grpc::ServerContext* /*context*/, const ::nakama::api::PromoteGroupUsersRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PromoteGroupUsers(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::PromoteGroupUsersRequest* /*request*/, ::google::protobuf::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PromoteGroupUsers(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::PromoteGroupUsersRequest* /*request*/, ::google::protobuf::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DemoteGroupUsers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DemoteGroupUsers() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(54,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::DemoteGroupUsersRequest, ::google::protobuf::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::DemoteGroupUsersRequest* request, ::google::protobuf::Empty* response) { return this->DemoteGroupUsers(context, request, response); }));}
    void SetMessageAllocatorFor_DemoteGroupUsers(
        ::grpc::experimental::MessageAllocator< ::nakama::api::DemoteGroupUsersRequest, ::google::protobuf::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(54);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(54);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::DemoteGroupUsersRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DemoteGroupUsers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DemoteGroupUsers(::grpc::ServerContext* /*context*/, const ::nakama::api::DemoteGroupUsersRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DemoteGroupUsers(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::DemoteGroupUsersRequest* /*request*/, ::google::protobuf::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DemoteGroupUsers(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::DemoteGroupUsersRequest* /*request*/, ::google::protobuf::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ReadStorageObjects : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ReadStorageObjects() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(55,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::ReadStorageObjectsRequest, ::nakama::api::StorageObjects>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::ReadStorageObjectsRequest* request, ::nakama::api::StorageObjects* response) { return this->ReadStorageObjects(context, request, response); }));}
    void SetMessageAllocatorFor_ReadStorageObjects(
        ::grpc::experimental::MessageAllocator< ::nakama::api::ReadStorageObjectsRequest, ::nakama::api::StorageObjects>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(55);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(55);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::ReadStorageObjectsRequest, ::nakama::api::StorageObjects>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ReadStorageObjects() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadStorageObjects(::grpc::ServerContext* /*context*/, const ::nakama::api::ReadStorageObjectsRequest* /*request*/, ::nakama::api::StorageObjects* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ReadStorageObjects(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::ReadStorageObjectsRequest* /*request*/, ::nakama::api::StorageObjects* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ReadStorageObjects(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::ReadStorageObjectsRequest* /*request*/, ::nakama::api::StorageObjects* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_RpcFunc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_RpcFunc() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(56,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::Rpc, ::nakama::api::Rpc>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::Rpc* request, ::nakama::api::Rpc* response) { return this->RpcFunc(context, request, response); }));}
    void SetMessageAllocatorFor_RpcFunc(
        ::grpc::experimental::MessageAllocator< ::nakama::api::Rpc, ::nakama::api::Rpc>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(56);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(56);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::Rpc, ::nakama::api::Rpc>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_RpcFunc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RpcFunc(::grpc::ServerContext* /*context*/, const ::nakama::api::Rpc* /*request*/, ::nakama::api::Rpc* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RpcFunc(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::Rpc* /*request*/, ::nakama::api::Rpc* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RpcFunc(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::Rpc* /*request*/, ::nakama::api::Rpc* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_UnlinkApple : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_UnlinkApple() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(57,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::AccountApple, ::google::protobuf::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::AccountApple* request, ::google::protobuf::Empty* response) { return this->UnlinkApple(context, request, response); }));}
    void SetMessageAllocatorFor_UnlinkApple(
        ::grpc::experimental::MessageAllocator< ::nakama::api::AccountApple, ::google::protobuf::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(57);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(57);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::AccountApple, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_UnlinkApple() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnlinkApple(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountApple* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UnlinkApple(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::AccountApple* /*request*/, ::google::protobuf::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UnlinkApple(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::AccountApple* /*request*/, ::google::protobuf::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_UnlinkCustom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_UnlinkCustom() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(58,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::AccountCustom, ::google::protobuf::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::AccountCustom* request, ::google::protobuf::Empty* response) { return this->UnlinkCustom(context, request, response); }));}
    void SetMessageAllocatorFor_UnlinkCustom(
        ::grpc::experimental::MessageAllocator< ::nakama::api::AccountCustom, ::google::protobuf::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(58);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(58);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::AccountCustom, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_UnlinkCustom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnlinkCustom(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountCustom* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UnlinkCustom(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::AccountCustom* /*request*/, ::google::protobuf::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UnlinkCustom(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::AccountCustom* /*request*/, ::google::protobuf::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_UnlinkDevice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_UnlinkDevice() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(59,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::AccountDevice, ::google::protobuf::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::AccountDevice* request, ::google::protobuf::Empty* response) { return this->UnlinkDevice(context, request, response); }));}
    void SetMessageAllocatorFor_UnlinkDevice(
        ::grpc::experimental::MessageAllocator< ::nakama::api::AccountDevice, ::google::protobuf::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(59);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(59);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::AccountDevice, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_UnlinkDevice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnlinkDevice(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountDevice* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UnlinkDevice(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::AccountDevice* /*request*/, ::google::protobuf::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UnlinkDevice(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::AccountDevice* /*request*/, ::google::protobuf::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_UnlinkEmail : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_UnlinkEmail() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(60,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::AccountEmail, ::google::protobuf::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::AccountEmail* request, ::google::protobuf::Empty* response) { return this->UnlinkEmail(context, request, response); }));}
    void SetMessageAllocatorFor_UnlinkEmail(
        ::grpc::experimental::MessageAllocator< ::nakama::api::AccountEmail, ::google::protobuf::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(60);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(60);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::AccountEmail, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_UnlinkEmail() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnlinkEmail(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountEmail* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UnlinkEmail(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::AccountEmail* /*request*/, ::google::protobuf::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UnlinkEmail(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::AccountEmail* /*request*/, ::google::protobuf::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_UnlinkFacebook : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_UnlinkFacebook() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(61,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::AccountFacebook, ::google::protobuf::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::AccountFacebook* request, ::google::protobuf::Empty* response) { return this->UnlinkFacebook(context, request, response); }));}
    void SetMessageAllocatorFor_UnlinkFacebook(
        ::grpc::experimental::MessageAllocator< ::nakama::api::AccountFacebook, ::google::protobuf::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(61);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(61);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::AccountFacebook, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_UnlinkFacebook() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnlinkFacebook(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountFacebook* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UnlinkFacebook(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::AccountFacebook* /*request*/, ::google::protobuf::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UnlinkFacebook(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::AccountFacebook* /*request*/, ::google::protobuf::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_UnlinkFacebookInstantGame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_UnlinkFacebookInstantGame() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(62,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::AccountFacebookInstantGame, ::google::protobuf::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::AccountFacebookInstantGame* request, ::google::protobuf::Empty* response) { return this->UnlinkFacebookInstantGame(context, request, response); }));}
    void SetMessageAllocatorFor_UnlinkFacebookInstantGame(
        ::grpc::experimental::MessageAllocator< ::nakama::api::AccountFacebookInstantGame, ::google::protobuf::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(62);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(62);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::AccountFacebookInstantGame, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_UnlinkFacebookInstantGame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnlinkFacebookInstantGame(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountFacebookInstantGame* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UnlinkFacebookInstantGame(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::AccountFacebookInstantGame* /*request*/, ::google::protobuf::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UnlinkFacebookInstantGame(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::AccountFacebookInstantGame* /*request*/, ::google::protobuf::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_UnlinkGameCenter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_UnlinkGameCenter() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(63,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::AccountGameCenter, ::google::protobuf::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::AccountGameCenter* request, ::google::protobuf::Empty* response) { return this->UnlinkGameCenter(context, request, response); }));}
    void SetMessageAllocatorFor_UnlinkGameCenter(
        ::grpc::experimental::MessageAllocator< ::nakama::api::AccountGameCenter, ::google::protobuf::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(63);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(63);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::AccountGameCenter, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_UnlinkGameCenter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnlinkGameCenter(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountGameCenter* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UnlinkGameCenter(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::AccountGameCenter* /*request*/, ::google::protobuf::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UnlinkGameCenter(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::AccountGameCenter* /*request*/, ::google::protobuf::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_UnlinkGoogle : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_UnlinkGoogle() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(64,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::AccountGoogle, ::google::protobuf::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::AccountGoogle* request, ::google::protobuf::Empty* response) { return this->UnlinkGoogle(context, request, response); }));}
    void SetMessageAllocatorFor_UnlinkGoogle(
        ::grpc::experimental::MessageAllocator< ::nakama::api::AccountGoogle, ::google::protobuf::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(64);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(64);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::AccountGoogle, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_UnlinkGoogle() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnlinkGoogle(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountGoogle* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UnlinkGoogle(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::AccountGoogle* /*request*/, ::google::protobuf::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UnlinkGoogle(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::AccountGoogle* /*request*/, ::google::protobuf::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_UnlinkSteam : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_UnlinkSteam() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(65,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::AccountSteam, ::google::protobuf::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::AccountSteam* request, ::google::protobuf::Empty* response) { return this->UnlinkSteam(context, request, response); }));}
    void SetMessageAllocatorFor_UnlinkSteam(
        ::grpc::experimental::MessageAllocator< ::nakama::api::AccountSteam, ::google::protobuf::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(65);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(65);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::AccountSteam, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_UnlinkSteam() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnlinkSteam(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountSteam* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UnlinkSteam(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::AccountSteam* /*request*/, ::google::protobuf::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UnlinkSteam(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::AccountSteam* /*request*/, ::google::protobuf::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_UpdateAccount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_UpdateAccount() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(66,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::UpdateAccountRequest, ::google::protobuf::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::UpdateAccountRequest* request, ::google::protobuf::Empty* response) { return this->UpdateAccount(context, request, response); }));}
    void SetMessageAllocatorFor_UpdateAccount(
        ::grpc::experimental::MessageAllocator< ::nakama::api::UpdateAccountRequest, ::google::protobuf::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(66);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(66);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::UpdateAccountRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_UpdateAccount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateAccount(::grpc::ServerContext* /*context*/, const ::nakama::api::UpdateAccountRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UpdateAccount(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::UpdateAccountRequest* /*request*/, ::google::protobuf::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UpdateAccount(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::UpdateAccountRequest* /*request*/, ::google::protobuf::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_UpdateGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_UpdateGroup() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(67,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::UpdateGroupRequest, ::google::protobuf::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::UpdateGroupRequest* request, ::google::protobuf::Empty* response) { return this->UpdateGroup(context, request, response); }));}
    void SetMessageAllocatorFor_UpdateGroup(
        ::grpc::experimental::MessageAllocator< ::nakama::api::UpdateGroupRequest, ::google::protobuf::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(67);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(67);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::UpdateGroupRequest, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_UpdateGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateGroup(::grpc::ServerContext* /*context*/, const ::nakama::api::UpdateGroupRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UpdateGroup(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::UpdateGroupRequest* /*request*/, ::google::protobuf::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UpdateGroup(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::UpdateGroupRequest* /*request*/, ::google::protobuf::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ValidatePurchaseApple : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ValidatePurchaseApple() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(68,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::ValidatePurchaseAppleRequest, ::nakama::api::ValidatePurchaseResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::ValidatePurchaseAppleRequest* request, ::nakama::api::ValidatePurchaseResponse* response) { return this->ValidatePurchaseApple(context, request, response); }));}
    void SetMessageAllocatorFor_ValidatePurchaseApple(
        ::grpc::experimental::MessageAllocator< ::nakama::api::ValidatePurchaseAppleRequest, ::nakama::api::ValidatePurchaseResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(68);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(68);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::ValidatePurchaseAppleRequest, ::nakama::api::ValidatePurchaseResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ValidatePurchaseApple() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ValidatePurchaseApple(::grpc::ServerContext* /*context*/, const ::nakama::api::ValidatePurchaseAppleRequest* /*request*/, ::nakama::api::ValidatePurchaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ValidatePurchaseApple(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::ValidatePurchaseAppleRequest* /*request*/, ::nakama::api::ValidatePurchaseResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ValidatePurchaseApple(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::ValidatePurchaseAppleRequest* /*request*/, ::nakama::api::ValidatePurchaseResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ValidatePurchaseGoogle : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ValidatePurchaseGoogle() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(69,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::ValidatePurchaseGoogleRequest, ::nakama::api::ValidatePurchaseResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::ValidatePurchaseGoogleRequest* request, ::nakama::api::ValidatePurchaseResponse* response) { return this->ValidatePurchaseGoogle(context, request, response); }));}
    void SetMessageAllocatorFor_ValidatePurchaseGoogle(
        ::grpc::experimental::MessageAllocator< ::nakama::api::ValidatePurchaseGoogleRequest, ::nakama::api::ValidatePurchaseResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(69);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(69);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::ValidatePurchaseGoogleRequest, ::nakama::api::ValidatePurchaseResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ValidatePurchaseGoogle() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ValidatePurchaseGoogle(::grpc::ServerContext* /*context*/, const ::nakama::api::ValidatePurchaseGoogleRequest* /*request*/, ::nakama::api::ValidatePurchaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ValidatePurchaseGoogle(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::ValidatePurchaseGoogleRequest* /*request*/, ::nakama::api::ValidatePurchaseResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ValidatePurchaseGoogle(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::ValidatePurchaseGoogleRequest* /*request*/, ::nakama::api::ValidatePurchaseResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ValidatePurchaseHuawei : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ValidatePurchaseHuawei() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(70,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::ValidatePurchaseHuaweiRequest, ::nakama::api::ValidatePurchaseResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::ValidatePurchaseHuaweiRequest* request, ::nakama::api::ValidatePurchaseResponse* response) { return this->ValidatePurchaseHuawei(context, request, response); }));}
    void SetMessageAllocatorFor_ValidatePurchaseHuawei(
        ::grpc::experimental::MessageAllocator< ::nakama::api::ValidatePurchaseHuaweiRequest, ::nakama::api::ValidatePurchaseResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(70);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(70);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::ValidatePurchaseHuaweiRequest, ::nakama::api::ValidatePurchaseResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ValidatePurchaseHuawei() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ValidatePurchaseHuawei(::grpc::ServerContext* /*context*/, const ::nakama::api::ValidatePurchaseHuaweiRequest* /*request*/, ::nakama::api::ValidatePurchaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ValidatePurchaseHuawei(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::ValidatePurchaseHuaweiRequest* /*request*/, ::nakama::api::ValidatePurchaseResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ValidatePurchaseHuawei(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::ValidatePurchaseHuaweiRequest* /*request*/, ::nakama::api::ValidatePurchaseResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_WriteLeaderboardRecord : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_WriteLeaderboardRecord() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(71,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::WriteLeaderboardRecordRequest, ::nakama::api::LeaderboardRecord>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::WriteLeaderboardRecordRequest* request, ::nakama::api::LeaderboardRecord* response) { return this->WriteLeaderboardRecord(context, request, response); }));}
    void SetMessageAllocatorFor_WriteLeaderboardRecord(
        ::grpc::experimental::MessageAllocator< ::nakama::api::WriteLeaderboardRecordRequest, ::nakama::api::LeaderboardRecord>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(71);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(71);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::WriteLeaderboardRecordRequest, ::nakama::api::LeaderboardRecord>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_WriteLeaderboardRecord() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WriteLeaderboardRecord(::grpc::ServerContext* /*context*/, const ::nakama::api::WriteLeaderboardRecordRequest* /*request*/, ::nakama::api::LeaderboardRecord* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* WriteLeaderboardRecord(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::WriteLeaderboardRecordRequest* /*request*/, ::nakama::api::LeaderboardRecord* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* WriteLeaderboardRecord(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::WriteLeaderboardRecordRequest* /*request*/, ::nakama::api::LeaderboardRecord* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_WriteStorageObjects : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_WriteStorageObjects() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(72,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::WriteStorageObjectsRequest, ::nakama::api::StorageObjectAcks>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::WriteStorageObjectsRequest* request, ::nakama::api::StorageObjectAcks* response) { return this->WriteStorageObjects(context, request, response); }));}
    void SetMessageAllocatorFor_WriteStorageObjects(
        ::grpc::experimental::MessageAllocator< ::nakama::api::WriteStorageObjectsRequest, ::nakama::api::StorageObjectAcks>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(72);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(72);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::WriteStorageObjectsRequest, ::nakama::api::StorageObjectAcks>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_WriteStorageObjects() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WriteStorageObjects(::grpc::ServerContext* /*context*/, const ::nakama::api::WriteStorageObjectsRequest* /*request*/, ::nakama::api::StorageObjectAcks* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* WriteStorageObjects(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::WriteStorageObjectsRequest* /*request*/, ::nakama::api::StorageObjectAcks* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* WriteStorageObjects(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::WriteStorageObjectsRequest* /*request*/, ::nakama::api::StorageObjectAcks* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_WriteTournamentRecord : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_WriteTournamentRecord() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(73,
          new ::grpc::internal::CallbackUnaryHandler< ::nakama::api::WriteTournamentRecordRequest, ::nakama::api::LeaderboardRecord>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::nakama::api::WriteTournamentRecordRequest* request, ::nakama::api::LeaderboardRecord* response) { return this->WriteTournamentRecord(context, request, response); }));}
    void SetMessageAllocatorFor_WriteTournamentRecord(
        ::grpc::experimental::MessageAllocator< ::nakama::api::WriteTournamentRecordRequest, ::nakama::api::LeaderboardRecord>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(73);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(73);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::nakama::api::WriteTournamentRecordRequest, ::nakama::api::LeaderboardRecord>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_WriteTournamentRecord() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WriteTournamentRecord(::grpc::ServerContext* /*context*/, const ::nakama::api::WriteTournamentRecordRequest* /*request*/, ::nakama::api::LeaderboardRecord* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* WriteTournamentRecord(
      ::grpc::CallbackServerContext* /*context*/, const ::nakama::api::WriteTournamentRecordRequest* /*request*/, ::nakama::api::LeaderboardRecord* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* WriteTournamentRecord(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::nakama::api::WriteTournamentRecordRequest* /*request*/, ::nakama::api::LeaderboardRecord* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_AddFriends<ExperimentalWithCallbackMethod_AddGroupUsers<ExperimentalWithCallbackMethod_SessionRefresh<ExperimentalWithCallbackMethod_SessionLogout<ExperimentalWithCallbackMethod_AuthenticateApple<ExperimentalWithCallbackMethod_AuthenticateCustom<ExperimentalWithCallbackMethod_AuthenticateDevice<ExperimentalWithCallbackMethod_AuthenticateEmail<ExperimentalWithCallbackMethod_AuthenticateFacebook<ExperimentalWithCallbackMethod_AuthenticateFacebookInstantGame<ExperimentalWithCallbackMethod_AuthenticateGameCenter<ExperimentalWithCallbackMethod_AuthenticateGoogle<ExperimentalWithCallbackMethod_AuthenticateSteam<ExperimentalWithCallbackMethod_BanGroupUsers<ExperimentalWithCallbackMethod_BlockFriends<ExperimentalWithCallbackMethod_CreateGroup<ExperimentalWithCallbackMethod_DeleteFriends<ExperimentalWithCallbackMethod_DeleteGroup<ExperimentalWithCallbackMethod_DeleteLeaderboardRecord<ExperimentalWithCallbackMethod_DeleteNotifications<ExperimentalWithCallbackMethod_DeleteStorageObjects<ExperimentalWithCallbackMethod_Event<ExperimentalWithCallbackMethod_GetAccount<ExperimentalWithCallbackMethod_GetUsers<ExperimentalWithCallbackMethod_Healthcheck<ExperimentalWithCallbackMethod_ImportFacebookFriends<ExperimentalWithCallbackMethod_ImportSteamFriends<ExperimentalWithCallbackMethod_JoinGroup<ExperimentalWithCallbackMethod_JoinTournament<ExperimentalWithCallbackMethod_KickGroupUsers<ExperimentalWithCallbackMethod_LeaveGroup<ExperimentalWithCallbackMethod_LinkApple<ExperimentalWithCallbackMethod_LinkCustom<ExperimentalWithCallbackMethod_LinkDevice<ExperimentalWithCallbackMethod_LinkEmail<ExperimentalWithCallbackMethod_LinkFacebook<ExperimentalWithCallbackMethod_LinkFacebookInstantGame<ExperimentalWithCallbackMethod_LinkGameCenter<ExperimentalWithCallbackMethod_LinkGoogle<ExperimentalWithCallbackMethod_LinkSteam<ExperimentalWithCallbackMethod_ListChannelMessages<ExperimentalWithCallbackMethod_ListFriends<ExperimentalWithCallbackMethod_ListGroups<ExperimentalWithCallbackMethod_ListGroupUsers<ExperimentalWithCallbackMethod_ListLeaderboardRecords<ExperimentalWithCallbackMethod_ListLeaderboardRecordsAroundOwner<ExperimentalWithCallbackMethod_ListMatches<ExperimentalWithCallbackMethod_ListNotifications<ExperimentalWithCallbackMethod_ListStorageObjects<ExperimentalWithCallbackMethod_ListTournaments<ExperimentalWithCallbackMethod_ListTournamentRecords<ExperimentalWithCallbackMethod_ListTournamentRecordsAroundOwner<ExperimentalWithCallbackMethod_ListUserGroups<ExperimentalWithCallbackMethod_PromoteGroupUsers<ExperimentalWithCallbackMethod_DemoteGroupUsers<ExperimentalWithCallbackMethod_ReadStorageObjects<ExperimentalWithCallbackMethod_RpcFunc<ExperimentalWithCallbackMethod_UnlinkApple<ExperimentalWithCallbackMethod_UnlinkCustom<ExperimentalWithCallbackMethod_UnlinkDevice<ExperimentalWithCallbackMethod_UnlinkEmail<ExperimentalWithCallbackMethod_UnlinkFacebook<ExperimentalWithCallbackMethod_UnlinkFacebookInstantGame<ExperimentalWithCallbackMethod_UnlinkGameCenter<ExperimentalWithCallbackMethod_UnlinkGoogle<ExperimentalWithCallbackMethod_UnlinkSteam<ExperimentalWithCallbackMethod_UpdateAccount<ExperimentalWithCallbackMethod_UpdateGroup<ExperimentalWithCallbackMethod_ValidatePurchaseApple<ExperimentalWithCallbackMethod_ValidatePurchaseGoogle<ExperimentalWithCallbackMethod_ValidatePurchaseHuawei<ExperimentalWithCallbackMethod_WriteLeaderboardRecord<ExperimentalWithCallbackMethod_WriteStorageObjects<ExperimentalWithCallbackMethod_WriteTournamentRecord<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_AddFriends<ExperimentalWithCallbackMethod_AddGroupUsers<ExperimentalWithCallbackMethod_SessionRefresh<ExperimentalWithCallbackMethod_SessionLogout<ExperimentalWithCallbackMethod_AuthenticateApple<ExperimentalWithCallbackMethod_AuthenticateCustom<ExperimentalWithCallbackMethod_AuthenticateDevice<ExperimentalWithCallbackMethod_AuthenticateEmail<ExperimentalWithCallbackMethod_AuthenticateFacebook<ExperimentalWithCallbackMethod_AuthenticateFacebookInstantGame<ExperimentalWithCallbackMethod_AuthenticateGameCenter<ExperimentalWithCallbackMethod_AuthenticateGoogle<ExperimentalWithCallbackMethod_AuthenticateSteam<ExperimentalWithCallbackMethod_BanGroupUsers<ExperimentalWithCallbackMethod_BlockFriends<ExperimentalWithCallbackMethod_CreateGroup<ExperimentalWithCallbackMethod_DeleteFriends<ExperimentalWithCallbackMethod_DeleteGroup<ExperimentalWithCallbackMethod_DeleteLeaderboardRecord<ExperimentalWithCallbackMethod_DeleteNotifications<ExperimentalWithCallbackMethod_DeleteStorageObjects<ExperimentalWithCallbackMethod_Event<ExperimentalWithCallbackMethod_GetAccount<ExperimentalWithCallbackMethod_GetUsers<ExperimentalWithCallbackMethod_Healthcheck<ExperimentalWithCallbackMethod_ImportFacebookFriends<ExperimentalWithCallbackMethod_ImportSteamFriends<ExperimentalWithCallbackMethod_JoinGroup<ExperimentalWithCallbackMethod_JoinTournament<ExperimentalWithCallbackMethod_KickGroupUsers<ExperimentalWithCallbackMethod_LeaveGroup<ExperimentalWithCallbackMethod_LinkApple<ExperimentalWithCallbackMethod_LinkCustom<ExperimentalWithCallbackMethod_LinkDevice<ExperimentalWithCallbackMethod_LinkEmail<ExperimentalWithCallbackMethod_LinkFacebook<ExperimentalWithCallbackMethod_LinkFacebookInstantGame<ExperimentalWithCallbackMethod_LinkGameCenter<ExperimentalWithCallbackMethod_LinkGoogle<ExperimentalWithCallbackMethod_LinkSteam<ExperimentalWithCallbackMethod_ListChannelMessages<ExperimentalWithCallbackMethod_ListFriends<ExperimentalWithCallbackMethod_ListGroups<ExperimentalWithCallbackMethod_ListGroupUsers<ExperimentalWithCallbackMethod_ListLeaderboardRecords<ExperimentalWithCallbackMethod_ListLeaderboardRecordsAroundOwner<ExperimentalWithCallbackMethod_ListMatches<ExperimentalWithCallbackMethod_ListNotifications<ExperimentalWithCallbackMethod_ListStorageObjects<ExperimentalWithCallbackMethod_ListTournaments<ExperimentalWithCallbackMethod_ListTournamentRecords<ExperimentalWithCallbackMethod_ListTournamentRecordsAroundOwner<ExperimentalWithCallbackMethod_ListUserGroups<ExperimentalWithCallbackMethod_PromoteGroupUsers<ExperimentalWithCallbackMethod_DemoteGroupUsers<ExperimentalWithCallbackMethod_ReadStorageObjects<ExperimentalWithCallbackMethod_RpcFunc<ExperimentalWithCallbackMethod_UnlinkApple<ExperimentalWithCallbackMethod_UnlinkCustom<ExperimentalWithCallbackMethod_UnlinkDevice<ExperimentalWithCallbackMethod_UnlinkEmail<ExperimentalWithCallbackMethod_UnlinkFacebook<ExperimentalWithCallbackMethod_UnlinkFacebookInstantGame<ExperimentalWithCallbackMethod_UnlinkGameCenter<ExperimentalWithCallbackMethod_UnlinkGoogle<ExperimentalWithCallbackMethod_UnlinkSteam<ExperimentalWithCallbackMethod_UpdateAccount<ExperimentalWithCallbackMethod_UpdateGroup<ExperimentalWithCallbackMethod_ValidatePurchaseApple<ExperimentalWithCallbackMethod_ValidatePurchaseGoogle<ExperimentalWithCallbackMethod_ValidatePurchaseHuawei<ExperimentalWithCallbackMethod_WriteLeaderboardRecord<ExperimentalWithCallbackMethod_WriteStorageObjects<ExperimentalWithCallbackMethod_WriteTournamentRecord<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_AddFriends : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AddFriends() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_AddFriends() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddFriends(::grpc::ServerContext* /*context*/, const ::nakama::api::AddFriendsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AddGroupUsers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AddGroupUsers() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_AddGroupUsers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddGroupUsers(::grpc::ServerContext* /*context*/, const ::nakama::api::AddGroupUsersRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SessionRefresh : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SessionRefresh() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_SessionRefresh() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SessionRefresh(::grpc::ServerContext* /*context*/, const ::nakama::api::SessionRefreshRequest* /*request*/, ::nakama::api::Session* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SessionLogout : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SessionLogout() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_SessionLogout() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SessionLogout(::grpc::ServerContext* /*context*/, const ::nakama::api::SessionLogoutRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AuthenticateApple : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AuthenticateApple() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_AuthenticateApple() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AuthenticateApple(::grpc::ServerContext* /*context*/, const ::nakama::api::AuthenticateAppleRequest* /*request*/, ::nakama::api::Session* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AuthenticateCustom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AuthenticateCustom() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_AuthenticateCustom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AuthenticateCustom(::grpc::ServerContext* /*context*/, const ::nakama::api::AuthenticateCustomRequest* /*request*/, ::nakama::api::Session* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AuthenticateDevice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AuthenticateDevice() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_AuthenticateDevice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AuthenticateDevice(::grpc::ServerContext* /*context*/, const ::nakama::api::AuthenticateDeviceRequest* /*request*/, ::nakama::api::Session* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AuthenticateEmail : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AuthenticateEmail() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_AuthenticateEmail() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AuthenticateEmail(::grpc::ServerContext* /*context*/, const ::nakama::api::AuthenticateEmailRequest* /*request*/, ::nakama::api::Session* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AuthenticateFacebook : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AuthenticateFacebook() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_AuthenticateFacebook() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AuthenticateFacebook(::grpc::ServerContext* /*context*/, const ::nakama::api::AuthenticateFacebookRequest* /*request*/, ::nakama::api::Session* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AuthenticateFacebookInstantGame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AuthenticateFacebookInstantGame() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_AuthenticateFacebookInstantGame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AuthenticateFacebookInstantGame(::grpc::ServerContext* /*context*/, const ::nakama::api::AuthenticateFacebookInstantGameRequest* /*request*/, ::nakama::api::Session* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AuthenticateGameCenter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AuthenticateGameCenter() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_AuthenticateGameCenter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AuthenticateGameCenter(::grpc::ServerContext* /*context*/, const ::nakama::api::AuthenticateGameCenterRequest* /*request*/, ::nakama::api::Session* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AuthenticateGoogle : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AuthenticateGoogle() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_AuthenticateGoogle() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AuthenticateGoogle(::grpc::ServerContext* /*context*/, const ::nakama::api::AuthenticateGoogleRequest* /*request*/, ::nakama::api::Session* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AuthenticateSteam : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AuthenticateSteam() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_AuthenticateSteam() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AuthenticateSteam(::grpc::ServerContext* /*context*/, const ::nakama::api::AuthenticateSteamRequest* /*request*/, ::nakama::api::Session* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_BanGroupUsers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_BanGroupUsers() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_BanGroupUsers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BanGroupUsers(::grpc::ServerContext* /*context*/, const ::nakama::api::BanGroupUsersRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_BlockFriends : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_BlockFriends() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_BlockFriends() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BlockFriends(::grpc::ServerContext* /*context*/, const ::nakama::api::BlockFriendsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CreateGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CreateGroup() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_CreateGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateGroup(::grpc::ServerContext* /*context*/, const ::nakama::api::CreateGroupRequest* /*request*/, ::nakama::api::Group* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteFriends : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteFriends() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_DeleteFriends() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteFriends(::grpc::ServerContext* /*context*/, const ::nakama::api::DeleteFriendsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteGroup() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_DeleteGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteGroup(::grpc::ServerContext* /*context*/, const ::nakama::api::DeleteGroupRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteLeaderboardRecord : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteLeaderboardRecord() {
      ::grpc::Service::MarkMethodGeneric(18);
    }
    ~WithGenericMethod_DeleteLeaderboardRecord() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteLeaderboardRecord(::grpc::ServerContext* /*context*/, const ::nakama::api::DeleteLeaderboardRecordRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteNotifications : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteNotifications() {
      ::grpc::Service::MarkMethodGeneric(19);
    }
    ~WithGenericMethod_DeleteNotifications() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteNotifications(::grpc::ServerContext* /*context*/, const ::nakama::api::DeleteNotificationsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteStorageObjects : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteStorageObjects() {
      ::grpc::Service::MarkMethodGeneric(20);
    }
    ~WithGenericMethod_DeleteStorageObjects() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteStorageObjects(::grpc::ServerContext* /*context*/, const ::nakama::api::DeleteStorageObjectsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Event : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Event() {
      ::grpc::Service::MarkMethodGeneric(21);
    }
    ~WithGenericMethod_Event() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Event(::grpc::ServerContext* /*context*/, const ::nakama::api::Event* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetAccount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetAccount() {
      ::grpc::Service::MarkMethodGeneric(22);
    }
    ~WithGenericMethod_GetAccount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAccount(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::nakama::api::Account* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetUsers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetUsers() {
      ::grpc::Service::MarkMethodGeneric(23);
    }
    ~WithGenericMethod_GetUsers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetUsers(::grpc::ServerContext* /*context*/, const ::nakama::api::GetUsersRequest* /*request*/, ::nakama::api::Users* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Healthcheck : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Healthcheck() {
      ::grpc::Service::MarkMethodGeneric(24);
    }
    ~WithGenericMethod_Healthcheck() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Healthcheck(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ImportFacebookFriends : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ImportFacebookFriends() {
      ::grpc::Service::MarkMethodGeneric(25);
    }
    ~WithGenericMethod_ImportFacebookFriends() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportFacebookFriends(::grpc::ServerContext* /*context*/, const ::nakama::api::ImportFacebookFriendsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ImportSteamFriends : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ImportSteamFriends() {
      ::grpc::Service::MarkMethodGeneric(26);
    }
    ~WithGenericMethod_ImportSteamFriends() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportSteamFriends(::grpc::ServerContext* /*context*/, const ::nakama::api::ImportSteamFriendsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_JoinGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_JoinGroup() {
      ::grpc::Service::MarkMethodGeneric(27);
    }
    ~WithGenericMethod_JoinGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status JoinGroup(::grpc::ServerContext* /*context*/, const ::nakama::api::JoinGroupRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_JoinTournament : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_JoinTournament() {
      ::grpc::Service::MarkMethodGeneric(28);
    }
    ~WithGenericMethod_JoinTournament() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status JoinTournament(::grpc::ServerContext* /*context*/, const ::nakama::api::JoinTournamentRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_KickGroupUsers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_KickGroupUsers() {
      ::grpc::Service::MarkMethodGeneric(29);
    }
    ~WithGenericMethod_KickGroupUsers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KickGroupUsers(::grpc::ServerContext* /*context*/, const ::nakama::api::KickGroupUsersRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_LeaveGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_LeaveGroup() {
      ::grpc::Service::MarkMethodGeneric(30);
    }
    ~WithGenericMethod_LeaveGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LeaveGroup(::grpc::ServerContext* /*context*/, const ::nakama::api::LeaveGroupRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_LinkApple : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_LinkApple() {
      ::grpc::Service::MarkMethodGeneric(31);
    }
    ~WithGenericMethod_LinkApple() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LinkApple(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountApple* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_LinkCustom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_LinkCustom() {
      ::grpc::Service::MarkMethodGeneric(32);
    }
    ~WithGenericMethod_LinkCustom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LinkCustom(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountCustom* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_LinkDevice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_LinkDevice() {
      ::grpc::Service::MarkMethodGeneric(33);
    }
    ~WithGenericMethod_LinkDevice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LinkDevice(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountDevice* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_LinkEmail : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_LinkEmail() {
      ::grpc::Service::MarkMethodGeneric(34);
    }
    ~WithGenericMethod_LinkEmail() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LinkEmail(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountEmail* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_LinkFacebook : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_LinkFacebook() {
      ::grpc::Service::MarkMethodGeneric(35);
    }
    ~WithGenericMethod_LinkFacebook() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LinkFacebook(::grpc::ServerContext* /*context*/, const ::nakama::api::LinkFacebookRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_LinkFacebookInstantGame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_LinkFacebookInstantGame() {
      ::grpc::Service::MarkMethodGeneric(36);
    }
    ~WithGenericMethod_LinkFacebookInstantGame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LinkFacebookInstantGame(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountFacebookInstantGame* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_LinkGameCenter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_LinkGameCenter() {
      ::grpc::Service::MarkMethodGeneric(37);
    }
    ~WithGenericMethod_LinkGameCenter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LinkGameCenter(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountGameCenter* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_LinkGoogle : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_LinkGoogle() {
      ::grpc::Service::MarkMethodGeneric(38);
    }
    ~WithGenericMethod_LinkGoogle() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LinkGoogle(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountGoogle* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_LinkSteam : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_LinkSteam() {
      ::grpc::Service::MarkMethodGeneric(39);
    }
    ~WithGenericMethod_LinkSteam() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LinkSteam(::grpc::ServerContext* /*context*/, const ::nakama::api::LinkSteamRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListChannelMessages : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListChannelMessages() {
      ::grpc::Service::MarkMethodGeneric(40);
    }
    ~WithGenericMethod_ListChannelMessages() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListChannelMessages(::grpc::ServerContext* /*context*/, const ::nakama::api::ListChannelMessagesRequest* /*request*/, ::nakama::api::ChannelMessageList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListFriends : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListFriends() {
      ::grpc::Service::MarkMethodGeneric(41);
    }
    ~WithGenericMethod_ListFriends() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListFriends(::grpc::ServerContext* /*context*/, const ::nakama::api::ListFriendsRequest* /*request*/, ::nakama::api::FriendList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListGroups : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListGroups() {
      ::grpc::Service::MarkMethodGeneric(42);
    }
    ~WithGenericMethod_ListGroups() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListGroups(::grpc::ServerContext* /*context*/, const ::nakama::api::ListGroupsRequest* /*request*/, ::nakama::api::GroupList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListGroupUsers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListGroupUsers() {
      ::grpc::Service::MarkMethodGeneric(43);
    }
    ~WithGenericMethod_ListGroupUsers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListGroupUsers(::grpc::ServerContext* /*context*/, const ::nakama::api::ListGroupUsersRequest* /*request*/, ::nakama::api::GroupUserList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListLeaderboardRecords : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListLeaderboardRecords() {
      ::grpc::Service::MarkMethodGeneric(44);
    }
    ~WithGenericMethod_ListLeaderboardRecords() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListLeaderboardRecords(::grpc::ServerContext* /*context*/, const ::nakama::api::ListLeaderboardRecordsRequest* /*request*/, ::nakama::api::LeaderboardRecordList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListLeaderboardRecordsAroundOwner : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListLeaderboardRecordsAroundOwner() {
      ::grpc::Service::MarkMethodGeneric(45);
    }
    ~WithGenericMethod_ListLeaderboardRecordsAroundOwner() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListLeaderboardRecordsAroundOwner(::grpc::ServerContext* /*context*/, const ::nakama::api::ListLeaderboardRecordsAroundOwnerRequest* /*request*/, ::nakama::api::LeaderboardRecordList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListMatches : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListMatches() {
      ::grpc::Service::MarkMethodGeneric(46);
    }
    ~WithGenericMethod_ListMatches() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListMatches(::grpc::ServerContext* /*context*/, const ::nakama::api::ListMatchesRequest* /*request*/, ::nakama::api::MatchList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListNotifications : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListNotifications() {
      ::grpc::Service::MarkMethodGeneric(47);
    }
    ~WithGenericMethod_ListNotifications() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListNotifications(::grpc::ServerContext* /*context*/, const ::nakama::api::ListNotificationsRequest* /*request*/, ::nakama::api::NotificationList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListStorageObjects : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListStorageObjects() {
      ::grpc::Service::MarkMethodGeneric(48);
    }
    ~WithGenericMethod_ListStorageObjects() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListStorageObjects(::grpc::ServerContext* /*context*/, const ::nakama::api::ListStorageObjectsRequest* /*request*/, ::nakama::api::StorageObjectList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListTournaments : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListTournaments() {
      ::grpc::Service::MarkMethodGeneric(49);
    }
    ~WithGenericMethod_ListTournaments() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListTournaments(::grpc::ServerContext* /*context*/, const ::nakama::api::ListTournamentsRequest* /*request*/, ::nakama::api::TournamentList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListTournamentRecords : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListTournamentRecords() {
      ::grpc::Service::MarkMethodGeneric(50);
    }
    ~WithGenericMethod_ListTournamentRecords() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListTournamentRecords(::grpc::ServerContext* /*context*/, const ::nakama::api::ListTournamentRecordsRequest* /*request*/, ::nakama::api::TournamentRecordList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListTournamentRecordsAroundOwner : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListTournamentRecordsAroundOwner() {
      ::grpc::Service::MarkMethodGeneric(51);
    }
    ~WithGenericMethod_ListTournamentRecordsAroundOwner() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListTournamentRecordsAroundOwner(::grpc::ServerContext* /*context*/, const ::nakama::api::ListTournamentRecordsAroundOwnerRequest* /*request*/, ::nakama::api::TournamentRecordList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListUserGroups : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListUserGroups() {
      ::grpc::Service::MarkMethodGeneric(52);
    }
    ~WithGenericMethod_ListUserGroups() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListUserGroups(::grpc::ServerContext* /*context*/, const ::nakama::api::ListUserGroupsRequest* /*request*/, ::nakama::api::UserGroupList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PromoteGroupUsers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PromoteGroupUsers() {
      ::grpc::Service::MarkMethodGeneric(53);
    }
    ~WithGenericMethod_PromoteGroupUsers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PromoteGroupUsers(::grpc::ServerContext* /*context*/, const ::nakama::api::PromoteGroupUsersRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DemoteGroupUsers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DemoteGroupUsers() {
      ::grpc::Service::MarkMethodGeneric(54);
    }
    ~WithGenericMethod_DemoteGroupUsers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DemoteGroupUsers(::grpc::ServerContext* /*context*/, const ::nakama::api::DemoteGroupUsersRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ReadStorageObjects : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ReadStorageObjects() {
      ::grpc::Service::MarkMethodGeneric(55);
    }
    ~WithGenericMethod_ReadStorageObjects() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadStorageObjects(::grpc::ServerContext* /*context*/, const ::nakama::api::ReadStorageObjectsRequest* /*request*/, ::nakama::api::StorageObjects* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RpcFunc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RpcFunc() {
      ::grpc::Service::MarkMethodGeneric(56);
    }
    ~WithGenericMethod_RpcFunc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RpcFunc(::grpc::ServerContext* /*context*/, const ::nakama::api::Rpc* /*request*/, ::nakama::api::Rpc* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UnlinkApple : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UnlinkApple() {
      ::grpc::Service::MarkMethodGeneric(57);
    }
    ~WithGenericMethod_UnlinkApple() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnlinkApple(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountApple* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UnlinkCustom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UnlinkCustom() {
      ::grpc::Service::MarkMethodGeneric(58);
    }
    ~WithGenericMethod_UnlinkCustom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnlinkCustom(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountCustom* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UnlinkDevice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UnlinkDevice() {
      ::grpc::Service::MarkMethodGeneric(59);
    }
    ~WithGenericMethod_UnlinkDevice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnlinkDevice(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountDevice* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UnlinkEmail : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UnlinkEmail() {
      ::grpc::Service::MarkMethodGeneric(60);
    }
    ~WithGenericMethod_UnlinkEmail() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnlinkEmail(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountEmail* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UnlinkFacebook : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UnlinkFacebook() {
      ::grpc::Service::MarkMethodGeneric(61);
    }
    ~WithGenericMethod_UnlinkFacebook() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnlinkFacebook(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountFacebook* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UnlinkFacebookInstantGame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UnlinkFacebookInstantGame() {
      ::grpc::Service::MarkMethodGeneric(62);
    }
    ~WithGenericMethod_UnlinkFacebookInstantGame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnlinkFacebookInstantGame(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountFacebookInstantGame* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UnlinkGameCenter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UnlinkGameCenter() {
      ::grpc::Service::MarkMethodGeneric(63);
    }
    ~WithGenericMethod_UnlinkGameCenter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnlinkGameCenter(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountGameCenter* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UnlinkGoogle : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UnlinkGoogle() {
      ::grpc::Service::MarkMethodGeneric(64);
    }
    ~WithGenericMethod_UnlinkGoogle() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnlinkGoogle(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountGoogle* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UnlinkSteam : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UnlinkSteam() {
      ::grpc::Service::MarkMethodGeneric(65);
    }
    ~WithGenericMethod_UnlinkSteam() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnlinkSteam(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountSteam* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UpdateAccount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UpdateAccount() {
      ::grpc::Service::MarkMethodGeneric(66);
    }
    ~WithGenericMethod_UpdateAccount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateAccount(::grpc::ServerContext* /*context*/, const ::nakama::api::UpdateAccountRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UpdateGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UpdateGroup() {
      ::grpc::Service::MarkMethodGeneric(67);
    }
    ~WithGenericMethod_UpdateGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateGroup(::grpc::ServerContext* /*context*/, const ::nakama::api::UpdateGroupRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ValidatePurchaseApple : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ValidatePurchaseApple() {
      ::grpc::Service::MarkMethodGeneric(68);
    }
    ~WithGenericMethod_ValidatePurchaseApple() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ValidatePurchaseApple(::grpc::ServerContext* /*context*/, const ::nakama::api::ValidatePurchaseAppleRequest* /*request*/, ::nakama::api::ValidatePurchaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ValidatePurchaseGoogle : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ValidatePurchaseGoogle() {
      ::grpc::Service::MarkMethodGeneric(69);
    }
    ~WithGenericMethod_ValidatePurchaseGoogle() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ValidatePurchaseGoogle(::grpc::ServerContext* /*context*/, const ::nakama::api::ValidatePurchaseGoogleRequest* /*request*/, ::nakama::api::ValidatePurchaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ValidatePurchaseHuawei : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ValidatePurchaseHuawei() {
      ::grpc::Service::MarkMethodGeneric(70);
    }
    ~WithGenericMethod_ValidatePurchaseHuawei() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ValidatePurchaseHuawei(::grpc::ServerContext* /*context*/, const ::nakama::api::ValidatePurchaseHuaweiRequest* /*request*/, ::nakama::api::ValidatePurchaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_WriteLeaderboardRecord : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_WriteLeaderboardRecord() {
      ::grpc::Service::MarkMethodGeneric(71);
    }
    ~WithGenericMethod_WriteLeaderboardRecord() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WriteLeaderboardRecord(::grpc::ServerContext* /*context*/, const ::nakama::api::WriteLeaderboardRecordRequest* /*request*/, ::nakama::api::LeaderboardRecord* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_WriteStorageObjects : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_WriteStorageObjects() {
      ::grpc::Service::MarkMethodGeneric(72);
    }
    ~WithGenericMethod_WriteStorageObjects() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WriteStorageObjects(::grpc::ServerContext* /*context*/, const ::nakama::api::WriteStorageObjectsRequest* /*request*/, ::nakama::api::StorageObjectAcks* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_WriteTournamentRecord : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_WriteTournamentRecord() {
      ::grpc::Service::MarkMethodGeneric(73);
    }
    ~WithGenericMethod_WriteTournamentRecord() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WriteTournamentRecord(::grpc::ServerContext* /*context*/, const ::nakama::api::WriteTournamentRecordRequest* /*request*/, ::nakama::api::LeaderboardRecord* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_AddFriends : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AddFriends() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_AddFriends() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddFriends(::grpc::ServerContext* /*context*/, const ::nakama::api::AddFriendsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAddFriends(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AddGroupUsers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AddGroupUsers() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_AddGroupUsers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddGroupUsers(::grpc::ServerContext* /*context*/, const ::nakama::api::AddGroupUsersRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAddGroupUsers(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SessionRefresh : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SessionRefresh() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_SessionRefresh() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SessionRefresh(::grpc::ServerContext* /*context*/, const ::nakama::api::SessionRefreshRequest* /*request*/, ::nakama::api::Session* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSessionRefresh(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SessionLogout : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SessionLogout() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_SessionLogout() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SessionLogout(::grpc::ServerContext* /*context*/, const ::nakama::api::SessionLogoutRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSessionLogout(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AuthenticateApple : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AuthenticateApple() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_AuthenticateApple() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AuthenticateApple(::grpc::ServerContext* /*context*/, const ::nakama::api::AuthenticateAppleRequest* /*request*/, ::nakama::api::Session* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAuthenticateApple(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AuthenticateCustom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AuthenticateCustom() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_AuthenticateCustom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AuthenticateCustom(::grpc::ServerContext* /*context*/, const ::nakama::api::AuthenticateCustomRequest* /*request*/, ::nakama::api::Session* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAuthenticateCustom(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AuthenticateDevice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AuthenticateDevice() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_AuthenticateDevice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AuthenticateDevice(::grpc::ServerContext* /*context*/, const ::nakama::api::AuthenticateDeviceRequest* /*request*/, ::nakama::api::Session* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAuthenticateDevice(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AuthenticateEmail : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AuthenticateEmail() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_AuthenticateEmail() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AuthenticateEmail(::grpc::ServerContext* /*context*/, const ::nakama::api::AuthenticateEmailRequest* /*request*/, ::nakama::api::Session* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAuthenticateEmail(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AuthenticateFacebook : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AuthenticateFacebook() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_AuthenticateFacebook() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AuthenticateFacebook(::grpc::ServerContext* /*context*/, const ::nakama::api::AuthenticateFacebookRequest* /*request*/, ::nakama::api::Session* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAuthenticateFacebook(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AuthenticateFacebookInstantGame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AuthenticateFacebookInstantGame() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_AuthenticateFacebookInstantGame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AuthenticateFacebookInstantGame(::grpc::ServerContext* /*context*/, const ::nakama::api::AuthenticateFacebookInstantGameRequest* /*request*/, ::nakama::api::Session* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAuthenticateFacebookInstantGame(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AuthenticateGameCenter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AuthenticateGameCenter() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_AuthenticateGameCenter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AuthenticateGameCenter(::grpc::ServerContext* /*context*/, const ::nakama::api::AuthenticateGameCenterRequest* /*request*/, ::nakama::api::Session* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAuthenticateGameCenter(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AuthenticateGoogle : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AuthenticateGoogle() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_AuthenticateGoogle() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AuthenticateGoogle(::grpc::ServerContext* /*context*/, const ::nakama::api::AuthenticateGoogleRequest* /*request*/, ::nakama::api::Session* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAuthenticateGoogle(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AuthenticateSteam : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AuthenticateSteam() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_AuthenticateSteam() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AuthenticateSteam(::grpc::ServerContext* /*context*/, const ::nakama::api::AuthenticateSteamRequest* /*request*/, ::nakama::api::Session* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAuthenticateSteam(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_BanGroupUsers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_BanGroupUsers() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_BanGroupUsers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BanGroupUsers(::grpc::ServerContext* /*context*/, const ::nakama::api::BanGroupUsersRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBanGroupUsers(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_BlockFriends : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_BlockFriends() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_BlockFriends() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BlockFriends(::grpc::ServerContext* /*context*/, const ::nakama::api::BlockFriendsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBlockFriends(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CreateGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CreateGroup() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_CreateGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateGroup(::grpc::ServerContext* /*context*/, const ::nakama::api::CreateGroupRequest* /*request*/, ::nakama::api::Group* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateGroup(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteFriends : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteFriends() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_DeleteFriends() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteFriends(::grpc::ServerContext* /*context*/, const ::nakama::api::DeleteFriendsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteFriends(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteGroup() {
      ::grpc::Service::MarkMethodRaw(17);
    }
    ~WithRawMethod_DeleteGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteGroup(::grpc::ServerContext* /*context*/, const ::nakama::api::DeleteGroupRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteGroup(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteLeaderboardRecord : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteLeaderboardRecord() {
      ::grpc::Service::MarkMethodRaw(18);
    }
    ~WithRawMethod_DeleteLeaderboardRecord() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteLeaderboardRecord(::grpc::ServerContext* /*context*/, const ::nakama::api::DeleteLeaderboardRecordRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteLeaderboardRecord(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteNotifications : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteNotifications() {
      ::grpc::Service::MarkMethodRaw(19);
    }
    ~WithRawMethod_DeleteNotifications() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteNotifications(::grpc::ServerContext* /*context*/, const ::nakama::api::DeleteNotificationsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteNotifications(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteStorageObjects : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteStorageObjects() {
      ::grpc::Service::MarkMethodRaw(20);
    }
    ~WithRawMethod_DeleteStorageObjects() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteStorageObjects(::grpc::ServerContext* /*context*/, const ::nakama::api::DeleteStorageObjectsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteStorageObjects(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Event : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Event() {
      ::grpc::Service::MarkMethodRaw(21);
    }
    ~WithRawMethod_Event() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Event(::grpc::ServerContext* /*context*/, const ::nakama::api::Event* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEvent(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetAccount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetAccount() {
      ::grpc::Service::MarkMethodRaw(22);
    }
    ~WithRawMethod_GetAccount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAccount(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::nakama::api::Account* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAccount(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetUsers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetUsers() {
      ::grpc::Service::MarkMethodRaw(23);
    }
    ~WithRawMethod_GetUsers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetUsers(::grpc::ServerContext* /*context*/, const ::nakama::api::GetUsersRequest* /*request*/, ::nakama::api::Users* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetUsers(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Healthcheck : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Healthcheck() {
      ::grpc::Service::MarkMethodRaw(24);
    }
    ~WithRawMethod_Healthcheck() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Healthcheck(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHealthcheck(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(24, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ImportFacebookFriends : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ImportFacebookFriends() {
      ::grpc::Service::MarkMethodRaw(25);
    }
    ~WithRawMethod_ImportFacebookFriends() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportFacebookFriends(::grpc::ServerContext* /*context*/, const ::nakama::api::ImportFacebookFriendsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestImportFacebookFriends(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(25, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ImportSteamFriends : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ImportSteamFriends() {
      ::grpc::Service::MarkMethodRaw(26);
    }
    ~WithRawMethod_ImportSteamFriends() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportSteamFriends(::grpc::ServerContext* /*context*/, const ::nakama::api::ImportSteamFriendsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestImportSteamFriends(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(26, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_JoinGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_JoinGroup() {
      ::grpc::Service::MarkMethodRaw(27);
    }
    ~WithRawMethod_JoinGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status JoinGroup(::grpc::ServerContext* /*context*/, const ::nakama::api::JoinGroupRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestJoinGroup(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(27, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_JoinTournament : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_JoinTournament() {
      ::grpc::Service::MarkMethodRaw(28);
    }
    ~WithRawMethod_JoinTournament() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status JoinTournament(::grpc::ServerContext* /*context*/, const ::nakama::api::JoinTournamentRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestJoinTournament(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(28, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_KickGroupUsers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_KickGroupUsers() {
      ::grpc::Service::MarkMethodRaw(29);
    }
    ~WithRawMethod_KickGroupUsers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KickGroupUsers(::grpc::ServerContext* /*context*/, const ::nakama::api::KickGroupUsersRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestKickGroupUsers(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(29, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_LeaveGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_LeaveGroup() {
      ::grpc::Service::MarkMethodRaw(30);
    }
    ~WithRawMethod_LeaveGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LeaveGroup(::grpc::ServerContext* /*context*/, const ::nakama::api::LeaveGroupRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLeaveGroup(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(30, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_LinkApple : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_LinkApple() {
      ::grpc::Service::MarkMethodRaw(31);
    }
    ~WithRawMethod_LinkApple() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LinkApple(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountApple* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLinkApple(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(31, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_LinkCustom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_LinkCustom() {
      ::grpc::Service::MarkMethodRaw(32);
    }
    ~WithRawMethod_LinkCustom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LinkCustom(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountCustom* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLinkCustom(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(32, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_LinkDevice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_LinkDevice() {
      ::grpc::Service::MarkMethodRaw(33);
    }
    ~WithRawMethod_LinkDevice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LinkDevice(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountDevice* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLinkDevice(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(33, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_LinkEmail : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_LinkEmail() {
      ::grpc::Service::MarkMethodRaw(34);
    }
    ~WithRawMethod_LinkEmail() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LinkEmail(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountEmail* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLinkEmail(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(34, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_LinkFacebook : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_LinkFacebook() {
      ::grpc::Service::MarkMethodRaw(35);
    }
    ~WithRawMethod_LinkFacebook() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LinkFacebook(::grpc::ServerContext* /*context*/, const ::nakama::api::LinkFacebookRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLinkFacebook(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(35, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_LinkFacebookInstantGame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_LinkFacebookInstantGame() {
      ::grpc::Service::MarkMethodRaw(36);
    }
    ~WithRawMethod_LinkFacebookInstantGame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LinkFacebookInstantGame(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountFacebookInstantGame* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLinkFacebookInstantGame(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(36, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_LinkGameCenter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_LinkGameCenter() {
      ::grpc::Service::MarkMethodRaw(37);
    }
    ~WithRawMethod_LinkGameCenter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LinkGameCenter(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountGameCenter* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLinkGameCenter(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(37, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_LinkGoogle : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_LinkGoogle() {
      ::grpc::Service::MarkMethodRaw(38);
    }
    ~WithRawMethod_LinkGoogle() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LinkGoogle(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountGoogle* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLinkGoogle(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(38, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_LinkSteam : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_LinkSteam() {
      ::grpc::Service::MarkMethodRaw(39);
    }
    ~WithRawMethod_LinkSteam() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LinkSteam(::grpc::ServerContext* /*context*/, const ::nakama::api::LinkSteamRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLinkSteam(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(39, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListChannelMessages : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListChannelMessages() {
      ::grpc::Service::MarkMethodRaw(40);
    }
    ~WithRawMethod_ListChannelMessages() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListChannelMessages(::grpc::ServerContext* /*context*/, const ::nakama::api::ListChannelMessagesRequest* /*request*/, ::nakama::api::ChannelMessageList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListChannelMessages(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(40, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListFriends : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListFriends() {
      ::grpc::Service::MarkMethodRaw(41);
    }
    ~WithRawMethod_ListFriends() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListFriends(::grpc::ServerContext* /*context*/, const ::nakama::api::ListFriendsRequest* /*request*/, ::nakama::api::FriendList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListFriends(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(41, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListGroups : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListGroups() {
      ::grpc::Service::MarkMethodRaw(42);
    }
    ~WithRawMethod_ListGroups() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListGroups(::grpc::ServerContext* /*context*/, const ::nakama::api::ListGroupsRequest* /*request*/, ::nakama::api::GroupList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListGroups(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(42, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListGroupUsers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListGroupUsers() {
      ::grpc::Service::MarkMethodRaw(43);
    }
    ~WithRawMethod_ListGroupUsers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListGroupUsers(::grpc::ServerContext* /*context*/, const ::nakama::api::ListGroupUsersRequest* /*request*/, ::nakama::api::GroupUserList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListGroupUsers(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(43, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListLeaderboardRecords : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListLeaderboardRecords() {
      ::grpc::Service::MarkMethodRaw(44);
    }
    ~WithRawMethod_ListLeaderboardRecords() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListLeaderboardRecords(::grpc::ServerContext* /*context*/, const ::nakama::api::ListLeaderboardRecordsRequest* /*request*/, ::nakama::api::LeaderboardRecordList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListLeaderboardRecords(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(44, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListLeaderboardRecordsAroundOwner : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListLeaderboardRecordsAroundOwner() {
      ::grpc::Service::MarkMethodRaw(45);
    }
    ~WithRawMethod_ListLeaderboardRecordsAroundOwner() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListLeaderboardRecordsAroundOwner(::grpc::ServerContext* /*context*/, const ::nakama::api::ListLeaderboardRecordsAroundOwnerRequest* /*request*/, ::nakama::api::LeaderboardRecordList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListLeaderboardRecordsAroundOwner(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(45, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListMatches : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListMatches() {
      ::grpc::Service::MarkMethodRaw(46);
    }
    ~WithRawMethod_ListMatches() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListMatches(::grpc::ServerContext* /*context*/, const ::nakama::api::ListMatchesRequest* /*request*/, ::nakama::api::MatchList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListMatches(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(46, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListNotifications : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListNotifications() {
      ::grpc::Service::MarkMethodRaw(47);
    }
    ~WithRawMethod_ListNotifications() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListNotifications(::grpc::ServerContext* /*context*/, const ::nakama::api::ListNotificationsRequest* /*request*/, ::nakama::api::NotificationList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListNotifications(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(47, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListStorageObjects : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListStorageObjects() {
      ::grpc::Service::MarkMethodRaw(48);
    }
    ~WithRawMethod_ListStorageObjects() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListStorageObjects(::grpc::ServerContext* /*context*/, const ::nakama::api::ListStorageObjectsRequest* /*request*/, ::nakama::api::StorageObjectList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListStorageObjects(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(48, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListTournaments : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListTournaments() {
      ::grpc::Service::MarkMethodRaw(49);
    }
    ~WithRawMethod_ListTournaments() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListTournaments(::grpc::ServerContext* /*context*/, const ::nakama::api::ListTournamentsRequest* /*request*/, ::nakama::api::TournamentList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListTournaments(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(49, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListTournamentRecords : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListTournamentRecords() {
      ::grpc::Service::MarkMethodRaw(50);
    }
    ~WithRawMethod_ListTournamentRecords() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListTournamentRecords(::grpc::ServerContext* /*context*/, const ::nakama::api::ListTournamentRecordsRequest* /*request*/, ::nakama::api::TournamentRecordList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListTournamentRecords(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(50, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListTournamentRecordsAroundOwner : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListTournamentRecordsAroundOwner() {
      ::grpc::Service::MarkMethodRaw(51);
    }
    ~WithRawMethod_ListTournamentRecordsAroundOwner() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListTournamentRecordsAroundOwner(::grpc::ServerContext* /*context*/, const ::nakama::api::ListTournamentRecordsAroundOwnerRequest* /*request*/, ::nakama::api::TournamentRecordList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListTournamentRecordsAroundOwner(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(51, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListUserGroups : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListUserGroups() {
      ::grpc::Service::MarkMethodRaw(52);
    }
    ~WithRawMethod_ListUserGroups() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListUserGroups(::grpc::ServerContext* /*context*/, const ::nakama::api::ListUserGroupsRequest* /*request*/, ::nakama::api::UserGroupList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListUserGroups(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(52, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PromoteGroupUsers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PromoteGroupUsers() {
      ::grpc::Service::MarkMethodRaw(53);
    }
    ~WithRawMethod_PromoteGroupUsers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PromoteGroupUsers(::grpc::ServerContext* /*context*/, const ::nakama::api::PromoteGroupUsersRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPromoteGroupUsers(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(53, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DemoteGroupUsers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DemoteGroupUsers() {
      ::grpc::Service::MarkMethodRaw(54);
    }
    ~WithRawMethod_DemoteGroupUsers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DemoteGroupUsers(::grpc::ServerContext* /*context*/, const ::nakama::api::DemoteGroupUsersRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDemoteGroupUsers(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(54, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ReadStorageObjects : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ReadStorageObjects() {
      ::grpc::Service::MarkMethodRaw(55);
    }
    ~WithRawMethod_ReadStorageObjects() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadStorageObjects(::grpc::ServerContext* /*context*/, const ::nakama::api::ReadStorageObjectsRequest* /*request*/, ::nakama::api::StorageObjects* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestReadStorageObjects(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(55, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RpcFunc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RpcFunc() {
      ::grpc::Service::MarkMethodRaw(56);
    }
    ~WithRawMethod_RpcFunc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RpcFunc(::grpc::ServerContext* /*context*/, const ::nakama::api::Rpc* /*request*/, ::nakama::api::Rpc* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRpcFunc(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(56, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UnlinkApple : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UnlinkApple() {
      ::grpc::Service::MarkMethodRaw(57);
    }
    ~WithRawMethod_UnlinkApple() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnlinkApple(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountApple* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUnlinkApple(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(57, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UnlinkCustom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UnlinkCustom() {
      ::grpc::Service::MarkMethodRaw(58);
    }
    ~WithRawMethod_UnlinkCustom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnlinkCustom(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountCustom* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUnlinkCustom(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(58, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UnlinkDevice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UnlinkDevice() {
      ::grpc::Service::MarkMethodRaw(59);
    }
    ~WithRawMethod_UnlinkDevice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnlinkDevice(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountDevice* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUnlinkDevice(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(59, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UnlinkEmail : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UnlinkEmail() {
      ::grpc::Service::MarkMethodRaw(60);
    }
    ~WithRawMethod_UnlinkEmail() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnlinkEmail(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountEmail* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUnlinkEmail(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(60, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UnlinkFacebook : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UnlinkFacebook() {
      ::grpc::Service::MarkMethodRaw(61);
    }
    ~WithRawMethod_UnlinkFacebook() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnlinkFacebook(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountFacebook* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUnlinkFacebook(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(61, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UnlinkFacebookInstantGame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UnlinkFacebookInstantGame() {
      ::grpc::Service::MarkMethodRaw(62);
    }
    ~WithRawMethod_UnlinkFacebookInstantGame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnlinkFacebookInstantGame(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountFacebookInstantGame* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUnlinkFacebookInstantGame(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(62, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UnlinkGameCenter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UnlinkGameCenter() {
      ::grpc::Service::MarkMethodRaw(63);
    }
    ~WithRawMethod_UnlinkGameCenter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnlinkGameCenter(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountGameCenter* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUnlinkGameCenter(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(63, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UnlinkGoogle : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UnlinkGoogle() {
      ::grpc::Service::MarkMethodRaw(64);
    }
    ~WithRawMethod_UnlinkGoogle() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnlinkGoogle(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountGoogle* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUnlinkGoogle(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(64, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UnlinkSteam : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UnlinkSteam() {
      ::grpc::Service::MarkMethodRaw(65);
    }
    ~WithRawMethod_UnlinkSteam() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnlinkSteam(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountSteam* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUnlinkSteam(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(65, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UpdateAccount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UpdateAccount() {
      ::grpc::Service::MarkMethodRaw(66);
    }
    ~WithRawMethod_UpdateAccount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateAccount(::grpc::ServerContext* /*context*/, const ::nakama::api::UpdateAccountRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateAccount(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(66, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UpdateGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UpdateGroup() {
      ::grpc::Service::MarkMethodRaw(67);
    }
    ~WithRawMethod_UpdateGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateGroup(::grpc::ServerContext* /*context*/, const ::nakama::api::UpdateGroupRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateGroup(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(67, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ValidatePurchaseApple : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ValidatePurchaseApple() {
      ::grpc::Service::MarkMethodRaw(68);
    }
    ~WithRawMethod_ValidatePurchaseApple() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ValidatePurchaseApple(::grpc::ServerContext* /*context*/, const ::nakama::api::ValidatePurchaseAppleRequest* /*request*/, ::nakama::api::ValidatePurchaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestValidatePurchaseApple(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(68, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ValidatePurchaseGoogle : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ValidatePurchaseGoogle() {
      ::grpc::Service::MarkMethodRaw(69);
    }
    ~WithRawMethod_ValidatePurchaseGoogle() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ValidatePurchaseGoogle(::grpc::ServerContext* /*context*/, const ::nakama::api::ValidatePurchaseGoogleRequest* /*request*/, ::nakama::api::ValidatePurchaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestValidatePurchaseGoogle(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(69, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ValidatePurchaseHuawei : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ValidatePurchaseHuawei() {
      ::grpc::Service::MarkMethodRaw(70);
    }
    ~WithRawMethod_ValidatePurchaseHuawei() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ValidatePurchaseHuawei(::grpc::ServerContext* /*context*/, const ::nakama::api::ValidatePurchaseHuaweiRequest* /*request*/, ::nakama::api::ValidatePurchaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestValidatePurchaseHuawei(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(70, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_WriteLeaderboardRecord : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_WriteLeaderboardRecord() {
      ::grpc::Service::MarkMethodRaw(71);
    }
    ~WithRawMethod_WriteLeaderboardRecord() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WriteLeaderboardRecord(::grpc::ServerContext* /*context*/, const ::nakama::api::WriteLeaderboardRecordRequest* /*request*/, ::nakama::api::LeaderboardRecord* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWriteLeaderboardRecord(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(71, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_WriteStorageObjects : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_WriteStorageObjects() {
      ::grpc::Service::MarkMethodRaw(72);
    }
    ~WithRawMethod_WriteStorageObjects() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WriteStorageObjects(::grpc::ServerContext* /*context*/, const ::nakama::api::WriteStorageObjectsRequest* /*request*/, ::nakama::api::StorageObjectAcks* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWriteStorageObjects(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(72, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_WriteTournamentRecord : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_WriteTournamentRecord() {
      ::grpc::Service::MarkMethodRaw(73);
    }
    ~WithRawMethod_WriteTournamentRecord() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WriteTournamentRecord(::grpc::ServerContext* /*context*/, const ::nakama::api::WriteTournamentRecordRequest* /*request*/, ::nakama::api::LeaderboardRecord* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWriteTournamentRecord(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(73, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_AddFriends : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_AddFriends() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->AddFriends(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_AddFriends() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddFriends(::grpc::ServerContext* /*context*/, const ::nakama::api::AddFriendsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AddFriends(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AddFriends(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_AddGroupUsers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_AddGroupUsers() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->AddGroupUsers(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_AddGroupUsers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddGroupUsers(::grpc::ServerContext* /*context*/, const ::nakama::api::AddGroupUsersRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AddGroupUsers(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AddGroupUsers(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SessionRefresh : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SessionRefresh() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SessionRefresh(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_SessionRefresh() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SessionRefresh(::grpc::ServerContext* /*context*/, const ::nakama::api::SessionRefreshRequest* /*request*/, ::nakama::api::Session* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SessionRefresh(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SessionRefresh(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SessionLogout : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SessionLogout() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SessionLogout(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_SessionLogout() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SessionLogout(::grpc::ServerContext* /*context*/, const ::nakama::api::SessionLogoutRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SessionLogout(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SessionLogout(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_AuthenticateApple : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_AuthenticateApple() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->AuthenticateApple(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_AuthenticateApple() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AuthenticateApple(::grpc::ServerContext* /*context*/, const ::nakama::api::AuthenticateAppleRequest* /*request*/, ::nakama::api::Session* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AuthenticateApple(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AuthenticateApple(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_AuthenticateCustom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_AuthenticateCustom() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->AuthenticateCustom(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_AuthenticateCustom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AuthenticateCustom(::grpc::ServerContext* /*context*/, const ::nakama::api::AuthenticateCustomRequest* /*request*/, ::nakama::api::Session* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AuthenticateCustom(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AuthenticateCustom(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_AuthenticateDevice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_AuthenticateDevice() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->AuthenticateDevice(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_AuthenticateDevice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AuthenticateDevice(::grpc::ServerContext* /*context*/, const ::nakama::api::AuthenticateDeviceRequest* /*request*/, ::nakama::api::Session* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AuthenticateDevice(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AuthenticateDevice(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_AuthenticateEmail : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_AuthenticateEmail() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->AuthenticateEmail(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_AuthenticateEmail() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AuthenticateEmail(::grpc::ServerContext* /*context*/, const ::nakama::api::AuthenticateEmailRequest* /*request*/, ::nakama::api::Session* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AuthenticateEmail(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AuthenticateEmail(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_AuthenticateFacebook : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_AuthenticateFacebook() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->AuthenticateFacebook(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_AuthenticateFacebook() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AuthenticateFacebook(::grpc::ServerContext* /*context*/, const ::nakama::api::AuthenticateFacebookRequest* /*request*/, ::nakama::api::Session* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AuthenticateFacebook(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AuthenticateFacebook(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_AuthenticateFacebookInstantGame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_AuthenticateFacebookInstantGame() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->AuthenticateFacebookInstantGame(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_AuthenticateFacebookInstantGame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AuthenticateFacebookInstantGame(::grpc::ServerContext* /*context*/, const ::nakama::api::AuthenticateFacebookInstantGameRequest* /*request*/, ::nakama::api::Session* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AuthenticateFacebookInstantGame(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AuthenticateFacebookInstantGame(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_AuthenticateGameCenter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_AuthenticateGameCenter() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->AuthenticateGameCenter(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_AuthenticateGameCenter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AuthenticateGameCenter(::grpc::ServerContext* /*context*/, const ::nakama::api::AuthenticateGameCenterRequest* /*request*/, ::nakama::api::Session* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AuthenticateGameCenter(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AuthenticateGameCenter(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_AuthenticateGoogle : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_AuthenticateGoogle() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->AuthenticateGoogle(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_AuthenticateGoogle() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AuthenticateGoogle(::grpc::ServerContext* /*context*/, const ::nakama::api::AuthenticateGoogleRequest* /*request*/, ::nakama::api::Session* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AuthenticateGoogle(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AuthenticateGoogle(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_AuthenticateSteam : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_AuthenticateSteam() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->AuthenticateSteam(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_AuthenticateSteam() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AuthenticateSteam(::grpc::ServerContext* /*context*/, const ::nakama::api::AuthenticateSteamRequest* /*request*/, ::nakama::api::Session* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AuthenticateSteam(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AuthenticateSteam(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_BanGroupUsers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_BanGroupUsers() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->BanGroupUsers(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_BanGroupUsers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BanGroupUsers(::grpc::ServerContext* /*context*/, const ::nakama::api::BanGroupUsersRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* BanGroupUsers(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* BanGroupUsers(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_BlockFriends : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_BlockFriends() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->BlockFriends(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_BlockFriends() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BlockFriends(::grpc::ServerContext* /*context*/, const ::nakama::api::BlockFriendsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* BlockFriends(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* BlockFriends(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CreateGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_CreateGroup() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CreateGroup(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_CreateGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateGroup(::grpc::ServerContext* /*context*/, const ::nakama::api::CreateGroupRequest* /*request*/, ::nakama::api::Group* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CreateGroup(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CreateGroup(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteFriends : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteFriends() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteFriends(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteFriends() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteFriends(::grpc::ServerContext* /*context*/, const ::nakama::api::DeleteFriendsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteFriends(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteFriends(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteGroup() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteGroup(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteGroup(::grpc::ServerContext* /*context*/, const ::nakama::api::DeleteGroupRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteGroup(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteGroup(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteLeaderboardRecord : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteLeaderboardRecord() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteLeaderboardRecord(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteLeaderboardRecord() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteLeaderboardRecord(::grpc::ServerContext* /*context*/, const ::nakama::api::DeleteLeaderboardRecordRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteLeaderboardRecord(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteLeaderboardRecord(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteNotifications : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteNotifications() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteNotifications(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteNotifications() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteNotifications(::grpc::ServerContext* /*context*/, const ::nakama::api::DeleteNotificationsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteNotifications(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteNotifications(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteStorageObjects : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteStorageObjects() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(20,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteStorageObjects(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteStorageObjects() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteStorageObjects(::grpc::ServerContext* /*context*/, const ::nakama::api::DeleteStorageObjectsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteStorageObjects(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteStorageObjects(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Event : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Event() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(21,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Event(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Event() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Event(::grpc::ServerContext* /*context*/, const ::nakama::api::Event* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Event(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Event(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetAccount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetAccount() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(22,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetAccount(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetAccount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAccount(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::nakama::api::Account* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetAccount(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetAccount(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetUsers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetUsers() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(23,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetUsers(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetUsers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetUsers(::grpc::ServerContext* /*context*/, const ::nakama::api::GetUsersRequest* /*request*/, ::nakama::api::Users* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetUsers(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetUsers(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Healthcheck : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Healthcheck() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(24,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Healthcheck(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Healthcheck() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Healthcheck(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Healthcheck(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Healthcheck(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ImportFacebookFriends : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ImportFacebookFriends() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(25,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ImportFacebookFriends(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ImportFacebookFriends() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportFacebookFriends(::grpc::ServerContext* /*context*/, const ::nakama::api::ImportFacebookFriendsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ImportFacebookFriends(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ImportFacebookFriends(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ImportSteamFriends : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ImportSteamFriends() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(26,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ImportSteamFriends(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ImportSteamFriends() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ImportSteamFriends(::grpc::ServerContext* /*context*/, const ::nakama::api::ImportSteamFriendsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ImportSteamFriends(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ImportSteamFriends(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_JoinGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_JoinGroup() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(27,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->JoinGroup(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_JoinGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status JoinGroup(::grpc::ServerContext* /*context*/, const ::nakama::api::JoinGroupRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* JoinGroup(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* JoinGroup(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_JoinTournament : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_JoinTournament() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(28,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->JoinTournament(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_JoinTournament() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status JoinTournament(::grpc::ServerContext* /*context*/, const ::nakama::api::JoinTournamentRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* JoinTournament(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* JoinTournament(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_KickGroupUsers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_KickGroupUsers() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(29,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->KickGroupUsers(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_KickGroupUsers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status KickGroupUsers(::grpc::ServerContext* /*context*/, const ::nakama::api::KickGroupUsersRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* KickGroupUsers(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* KickGroupUsers(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_LeaveGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_LeaveGroup() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(30,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->LeaveGroup(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_LeaveGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LeaveGroup(::grpc::ServerContext* /*context*/, const ::nakama::api::LeaveGroupRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* LeaveGroup(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* LeaveGroup(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_LinkApple : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_LinkApple() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(31,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->LinkApple(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_LinkApple() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LinkApple(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountApple* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* LinkApple(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* LinkApple(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_LinkCustom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_LinkCustom() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(32,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->LinkCustom(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_LinkCustom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LinkCustom(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountCustom* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* LinkCustom(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* LinkCustom(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_LinkDevice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_LinkDevice() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(33,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->LinkDevice(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_LinkDevice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LinkDevice(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountDevice* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* LinkDevice(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* LinkDevice(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_LinkEmail : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_LinkEmail() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(34,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->LinkEmail(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_LinkEmail() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LinkEmail(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountEmail* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* LinkEmail(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* LinkEmail(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_LinkFacebook : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_LinkFacebook() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(35,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->LinkFacebook(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_LinkFacebook() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LinkFacebook(::grpc::ServerContext* /*context*/, const ::nakama::api::LinkFacebookRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* LinkFacebook(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* LinkFacebook(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_LinkFacebookInstantGame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_LinkFacebookInstantGame() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(36,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->LinkFacebookInstantGame(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_LinkFacebookInstantGame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LinkFacebookInstantGame(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountFacebookInstantGame* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* LinkFacebookInstantGame(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* LinkFacebookInstantGame(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_LinkGameCenter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_LinkGameCenter() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(37,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->LinkGameCenter(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_LinkGameCenter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LinkGameCenter(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountGameCenter* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* LinkGameCenter(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* LinkGameCenter(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_LinkGoogle : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_LinkGoogle() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(38,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->LinkGoogle(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_LinkGoogle() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LinkGoogle(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountGoogle* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* LinkGoogle(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* LinkGoogle(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_LinkSteam : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_LinkSteam() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(39,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->LinkSteam(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_LinkSteam() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LinkSteam(::grpc::ServerContext* /*context*/, const ::nakama::api::LinkSteamRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* LinkSteam(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* LinkSteam(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListChannelMessages : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListChannelMessages() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(40,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListChannelMessages(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListChannelMessages() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListChannelMessages(::grpc::ServerContext* /*context*/, const ::nakama::api::ListChannelMessagesRequest* /*request*/, ::nakama::api::ChannelMessageList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListChannelMessages(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListChannelMessages(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListFriends : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListFriends() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(41,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListFriends(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListFriends() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListFriends(::grpc::ServerContext* /*context*/, const ::nakama::api::ListFriendsRequest* /*request*/, ::nakama::api::FriendList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListFriends(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListFriends(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListGroups : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListGroups() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(42,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListGroups(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListGroups() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListGroups(::grpc::ServerContext* /*context*/, const ::nakama::api::ListGroupsRequest* /*request*/, ::nakama::api::GroupList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListGroups(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListGroups(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListGroupUsers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListGroupUsers() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(43,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListGroupUsers(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListGroupUsers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListGroupUsers(::grpc::ServerContext* /*context*/, const ::nakama::api::ListGroupUsersRequest* /*request*/, ::nakama::api::GroupUserList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListGroupUsers(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListGroupUsers(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListLeaderboardRecords : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListLeaderboardRecords() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(44,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListLeaderboardRecords(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListLeaderboardRecords() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListLeaderboardRecords(::grpc::ServerContext* /*context*/, const ::nakama::api::ListLeaderboardRecordsRequest* /*request*/, ::nakama::api::LeaderboardRecordList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListLeaderboardRecords(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListLeaderboardRecords(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListLeaderboardRecordsAroundOwner : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListLeaderboardRecordsAroundOwner() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(45,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListLeaderboardRecordsAroundOwner(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListLeaderboardRecordsAroundOwner() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListLeaderboardRecordsAroundOwner(::grpc::ServerContext* /*context*/, const ::nakama::api::ListLeaderboardRecordsAroundOwnerRequest* /*request*/, ::nakama::api::LeaderboardRecordList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListLeaderboardRecordsAroundOwner(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListLeaderboardRecordsAroundOwner(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListMatches : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListMatches() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(46,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListMatches(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListMatches() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListMatches(::grpc::ServerContext* /*context*/, const ::nakama::api::ListMatchesRequest* /*request*/, ::nakama::api::MatchList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListMatches(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListMatches(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListNotifications : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListNotifications() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(47,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListNotifications(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListNotifications() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListNotifications(::grpc::ServerContext* /*context*/, const ::nakama::api::ListNotificationsRequest* /*request*/, ::nakama::api::NotificationList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListNotifications(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListNotifications(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListStorageObjects : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListStorageObjects() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(48,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListStorageObjects(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListStorageObjects() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListStorageObjects(::grpc::ServerContext* /*context*/, const ::nakama::api::ListStorageObjectsRequest* /*request*/, ::nakama::api::StorageObjectList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListStorageObjects(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListStorageObjects(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListTournaments : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListTournaments() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(49,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListTournaments(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListTournaments() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListTournaments(::grpc::ServerContext* /*context*/, const ::nakama::api::ListTournamentsRequest* /*request*/, ::nakama::api::TournamentList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListTournaments(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListTournaments(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListTournamentRecords : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListTournamentRecords() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(50,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListTournamentRecords(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListTournamentRecords() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListTournamentRecords(::grpc::ServerContext* /*context*/, const ::nakama::api::ListTournamentRecordsRequest* /*request*/, ::nakama::api::TournamentRecordList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListTournamentRecords(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListTournamentRecords(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListTournamentRecordsAroundOwner : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListTournamentRecordsAroundOwner() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(51,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListTournamentRecordsAroundOwner(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListTournamentRecordsAroundOwner() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListTournamentRecordsAroundOwner(::grpc::ServerContext* /*context*/, const ::nakama::api::ListTournamentRecordsAroundOwnerRequest* /*request*/, ::nakama::api::TournamentRecordList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListTournamentRecordsAroundOwner(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListTournamentRecordsAroundOwner(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListUserGroups : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListUserGroups() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(52,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListUserGroups(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListUserGroups() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListUserGroups(::grpc::ServerContext* /*context*/, const ::nakama::api::ListUserGroupsRequest* /*request*/, ::nakama::api::UserGroupList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListUserGroups(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListUserGroups(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PromoteGroupUsers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PromoteGroupUsers() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(53,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PromoteGroupUsers(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PromoteGroupUsers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PromoteGroupUsers(::grpc::ServerContext* /*context*/, const ::nakama::api::PromoteGroupUsersRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PromoteGroupUsers(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PromoteGroupUsers(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DemoteGroupUsers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DemoteGroupUsers() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(54,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DemoteGroupUsers(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DemoteGroupUsers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DemoteGroupUsers(::grpc::ServerContext* /*context*/, const ::nakama::api::DemoteGroupUsersRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DemoteGroupUsers(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DemoteGroupUsers(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ReadStorageObjects : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ReadStorageObjects() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(55,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ReadStorageObjects(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ReadStorageObjects() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadStorageObjects(::grpc::ServerContext* /*context*/, const ::nakama::api::ReadStorageObjectsRequest* /*request*/, ::nakama::api::StorageObjects* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ReadStorageObjects(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ReadStorageObjects(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_RpcFunc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_RpcFunc() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(56,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RpcFunc(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_RpcFunc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RpcFunc(::grpc::ServerContext* /*context*/, const ::nakama::api::Rpc* /*request*/, ::nakama::api::Rpc* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RpcFunc(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RpcFunc(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_UnlinkApple : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_UnlinkApple() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(57,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UnlinkApple(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_UnlinkApple() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnlinkApple(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountApple* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UnlinkApple(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UnlinkApple(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_UnlinkCustom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_UnlinkCustom() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(58,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UnlinkCustom(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_UnlinkCustom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnlinkCustom(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountCustom* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UnlinkCustom(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UnlinkCustom(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_UnlinkDevice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_UnlinkDevice() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(59,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UnlinkDevice(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_UnlinkDevice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnlinkDevice(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountDevice* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UnlinkDevice(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UnlinkDevice(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_UnlinkEmail : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_UnlinkEmail() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(60,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UnlinkEmail(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_UnlinkEmail() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnlinkEmail(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountEmail* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UnlinkEmail(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UnlinkEmail(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_UnlinkFacebook : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_UnlinkFacebook() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(61,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UnlinkFacebook(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_UnlinkFacebook() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnlinkFacebook(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountFacebook* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UnlinkFacebook(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UnlinkFacebook(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_UnlinkFacebookInstantGame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_UnlinkFacebookInstantGame() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(62,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UnlinkFacebookInstantGame(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_UnlinkFacebookInstantGame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnlinkFacebookInstantGame(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountFacebookInstantGame* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UnlinkFacebookInstantGame(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UnlinkFacebookInstantGame(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_UnlinkGameCenter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_UnlinkGameCenter() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(63,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UnlinkGameCenter(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_UnlinkGameCenter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnlinkGameCenter(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountGameCenter* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UnlinkGameCenter(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UnlinkGameCenter(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_UnlinkGoogle : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_UnlinkGoogle() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(64,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UnlinkGoogle(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_UnlinkGoogle() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnlinkGoogle(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountGoogle* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UnlinkGoogle(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UnlinkGoogle(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_UnlinkSteam : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_UnlinkSteam() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(65,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UnlinkSteam(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_UnlinkSteam() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnlinkSteam(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountSteam* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UnlinkSteam(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UnlinkSteam(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_UpdateAccount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_UpdateAccount() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(66,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UpdateAccount(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_UpdateAccount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateAccount(::grpc::ServerContext* /*context*/, const ::nakama::api::UpdateAccountRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UpdateAccount(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UpdateAccount(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_UpdateGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_UpdateGroup() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(67,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UpdateGroup(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_UpdateGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateGroup(::grpc::ServerContext* /*context*/, const ::nakama::api::UpdateGroupRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UpdateGroup(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UpdateGroup(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ValidatePurchaseApple : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ValidatePurchaseApple() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(68,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ValidatePurchaseApple(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ValidatePurchaseApple() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ValidatePurchaseApple(::grpc::ServerContext* /*context*/, const ::nakama::api::ValidatePurchaseAppleRequest* /*request*/, ::nakama::api::ValidatePurchaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ValidatePurchaseApple(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ValidatePurchaseApple(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ValidatePurchaseGoogle : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ValidatePurchaseGoogle() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(69,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ValidatePurchaseGoogle(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ValidatePurchaseGoogle() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ValidatePurchaseGoogle(::grpc::ServerContext* /*context*/, const ::nakama::api::ValidatePurchaseGoogleRequest* /*request*/, ::nakama::api::ValidatePurchaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ValidatePurchaseGoogle(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ValidatePurchaseGoogle(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ValidatePurchaseHuawei : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ValidatePurchaseHuawei() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(70,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ValidatePurchaseHuawei(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ValidatePurchaseHuawei() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ValidatePurchaseHuawei(::grpc::ServerContext* /*context*/, const ::nakama::api::ValidatePurchaseHuaweiRequest* /*request*/, ::nakama::api::ValidatePurchaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ValidatePurchaseHuawei(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ValidatePurchaseHuawei(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_WriteLeaderboardRecord : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_WriteLeaderboardRecord() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(71,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->WriteLeaderboardRecord(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_WriteLeaderboardRecord() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WriteLeaderboardRecord(::grpc::ServerContext* /*context*/, const ::nakama::api::WriteLeaderboardRecordRequest* /*request*/, ::nakama::api::LeaderboardRecord* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* WriteLeaderboardRecord(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* WriteLeaderboardRecord(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_WriteStorageObjects : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_WriteStorageObjects() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(72,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->WriteStorageObjects(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_WriteStorageObjects() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WriteStorageObjects(::grpc::ServerContext* /*context*/, const ::nakama::api::WriteStorageObjectsRequest* /*request*/, ::nakama::api::StorageObjectAcks* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* WriteStorageObjects(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* WriteStorageObjects(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_WriteTournamentRecord : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_WriteTournamentRecord() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(73,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->WriteTournamentRecord(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_WriteTournamentRecord() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WriteTournamentRecord(::grpc::ServerContext* /*context*/, const ::nakama::api::WriteTournamentRecordRequest* /*request*/, ::nakama::api::LeaderboardRecord* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* WriteTournamentRecord(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* WriteTournamentRecord(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AddFriends : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AddFriends() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::AddFriendsRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::AddFriendsRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedAddFriends(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_AddFriends() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AddFriends(::grpc::ServerContext* /*context*/, const ::nakama::api::AddFriendsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAddFriends(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::AddFriendsRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AddGroupUsers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AddGroupUsers() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::AddGroupUsersRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::AddGroupUsersRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedAddGroupUsers(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_AddGroupUsers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AddGroupUsers(::grpc::ServerContext* /*context*/, const ::nakama::api::AddGroupUsersRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAddGroupUsers(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::AddGroupUsersRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SessionRefresh : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SessionRefresh() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::SessionRefreshRequest, ::nakama::api::Session>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::SessionRefreshRequest, ::nakama::api::Session>* streamer) {
                       return this->StreamedSessionRefresh(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SessionRefresh() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SessionRefresh(::grpc::ServerContext* /*context*/, const ::nakama::api::SessionRefreshRequest* /*request*/, ::nakama::api::Session* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSessionRefresh(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::SessionRefreshRequest,::nakama::api::Session>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SessionLogout : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SessionLogout() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::SessionLogoutRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::SessionLogoutRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedSessionLogout(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SessionLogout() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SessionLogout(::grpc::ServerContext* /*context*/, const ::nakama::api::SessionLogoutRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSessionLogout(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::SessionLogoutRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AuthenticateApple : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AuthenticateApple() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::AuthenticateAppleRequest, ::nakama::api::Session>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::AuthenticateAppleRequest, ::nakama::api::Session>* streamer) {
                       return this->StreamedAuthenticateApple(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_AuthenticateApple() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AuthenticateApple(::grpc::ServerContext* /*context*/, const ::nakama::api::AuthenticateAppleRequest* /*request*/, ::nakama::api::Session* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAuthenticateApple(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::AuthenticateAppleRequest,::nakama::api::Session>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AuthenticateCustom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AuthenticateCustom() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::AuthenticateCustomRequest, ::nakama::api::Session>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::AuthenticateCustomRequest, ::nakama::api::Session>* streamer) {
                       return this->StreamedAuthenticateCustom(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_AuthenticateCustom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AuthenticateCustom(::grpc::ServerContext* /*context*/, const ::nakama::api::AuthenticateCustomRequest* /*request*/, ::nakama::api::Session* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAuthenticateCustom(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::AuthenticateCustomRequest,::nakama::api::Session>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AuthenticateDevice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AuthenticateDevice() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::AuthenticateDeviceRequest, ::nakama::api::Session>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::AuthenticateDeviceRequest, ::nakama::api::Session>* streamer) {
                       return this->StreamedAuthenticateDevice(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_AuthenticateDevice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AuthenticateDevice(::grpc::ServerContext* /*context*/, const ::nakama::api::AuthenticateDeviceRequest* /*request*/, ::nakama::api::Session* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAuthenticateDevice(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::AuthenticateDeviceRequest,::nakama::api::Session>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AuthenticateEmail : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AuthenticateEmail() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::AuthenticateEmailRequest, ::nakama::api::Session>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::AuthenticateEmailRequest, ::nakama::api::Session>* streamer) {
                       return this->StreamedAuthenticateEmail(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_AuthenticateEmail() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AuthenticateEmail(::grpc::ServerContext* /*context*/, const ::nakama::api::AuthenticateEmailRequest* /*request*/, ::nakama::api::Session* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAuthenticateEmail(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::AuthenticateEmailRequest,::nakama::api::Session>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AuthenticateFacebook : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AuthenticateFacebook() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::AuthenticateFacebookRequest, ::nakama::api::Session>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::AuthenticateFacebookRequest, ::nakama::api::Session>* streamer) {
                       return this->StreamedAuthenticateFacebook(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_AuthenticateFacebook() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AuthenticateFacebook(::grpc::ServerContext* /*context*/, const ::nakama::api::AuthenticateFacebookRequest* /*request*/, ::nakama::api::Session* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAuthenticateFacebook(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::AuthenticateFacebookRequest,::nakama::api::Session>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AuthenticateFacebookInstantGame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AuthenticateFacebookInstantGame() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::AuthenticateFacebookInstantGameRequest, ::nakama::api::Session>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::AuthenticateFacebookInstantGameRequest, ::nakama::api::Session>* streamer) {
                       return this->StreamedAuthenticateFacebookInstantGame(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_AuthenticateFacebookInstantGame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AuthenticateFacebookInstantGame(::grpc::ServerContext* /*context*/, const ::nakama::api::AuthenticateFacebookInstantGameRequest* /*request*/, ::nakama::api::Session* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAuthenticateFacebookInstantGame(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::AuthenticateFacebookInstantGameRequest,::nakama::api::Session>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AuthenticateGameCenter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AuthenticateGameCenter() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::AuthenticateGameCenterRequest, ::nakama::api::Session>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::AuthenticateGameCenterRequest, ::nakama::api::Session>* streamer) {
                       return this->StreamedAuthenticateGameCenter(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_AuthenticateGameCenter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AuthenticateGameCenter(::grpc::ServerContext* /*context*/, const ::nakama::api::AuthenticateGameCenterRequest* /*request*/, ::nakama::api::Session* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAuthenticateGameCenter(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::AuthenticateGameCenterRequest,::nakama::api::Session>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AuthenticateGoogle : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AuthenticateGoogle() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::AuthenticateGoogleRequest, ::nakama::api::Session>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::AuthenticateGoogleRequest, ::nakama::api::Session>* streamer) {
                       return this->StreamedAuthenticateGoogle(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_AuthenticateGoogle() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AuthenticateGoogle(::grpc::ServerContext* /*context*/, const ::nakama::api::AuthenticateGoogleRequest* /*request*/, ::nakama::api::Session* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAuthenticateGoogle(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::AuthenticateGoogleRequest,::nakama::api::Session>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AuthenticateSteam : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AuthenticateSteam() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::AuthenticateSteamRequest, ::nakama::api::Session>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::AuthenticateSteamRequest, ::nakama::api::Session>* streamer) {
                       return this->StreamedAuthenticateSteam(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_AuthenticateSteam() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AuthenticateSteam(::grpc::ServerContext* /*context*/, const ::nakama::api::AuthenticateSteamRequest* /*request*/, ::nakama::api::Session* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAuthenticateSteam(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::AuthenticateSteamRequest,::nakama::api::Session>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_BanGroupUsers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_BanGroupUsers() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::BanGroupUsersRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::BanGroupUsersRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedBanGroupUsers(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_BanGroupUsers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status BanGroupUsers(::grpc::ServerContext* /*context*/, const ::nakama::api::BanGroupUsersRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedBanGroupUsers(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::BanGroupUsersRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_BlockFriends : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_BlockFriends() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::BlockFriendsRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::BlockFriendsRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedBlockFriends(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_BlockFriends() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status BlockFriends(::grpc::ServerContext* /*context*/, const ::nakama::api::BlockFriendsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedBlockFriends(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::BlockFriendsRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CreateGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CreateGroup() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::CreateGroupRequest, ::nakama::api::Group>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::CreateGroupRequest, ::nakama::api::Group>* streamer) {
                       return this->StreamedCreateGroup(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CreateGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CreateGroup(::grpc::ServerContext* /*context*/, const ::nakama::api::CreateGroupRequest* /*request*/, ::nakama::api::Group* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCreateGroup(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::CreateGroupRequest,::nakama::api::Group>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteFriends : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteFriends() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::DeleteFriendsRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::DeleteFriendsRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedDeleteFriends(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DeleteFriends() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteFriends(::grpc::ServerContext* /*context*/, const ::nakama::api::DeleteFriendsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteFriends(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::DeleteFriendsRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteGroup() {
      ::grpc::Service::MarkMethodStreamed(17,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::DeleteGroupRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::DeleteGroupRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedDeleteGroup(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DeleteGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteGroup(::grpc::ServerContext* /*context*/, const ::nakama::api::DeleteGroupRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteGroup(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::DeleteGroupRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteLeaderboardRecord : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteLeaderboardRecord() {
      ::grpc::Service::MarkMethodStreamed(18,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::DeleteLeaderboardRecordRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::DeleteLeaderboardRecordRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedDeleteLeaderboardRecord(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DeleteLeaderboardRecord() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteLeaderboardRecord(::grpc::ServerContext* /*context*/, const ::nakama::api::DeleteLeaderboardRecordRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteLeaderboardRecord(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::DeleteLeaderboardRecordRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteNotifications : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteNotifications() {
      ::grpc::Service::MarkMethodStreamed(19,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::DeleteNotificationsRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::DeleteNotificationsRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedDeleteNotifications(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DeleteNotifications() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteNotifications(::grpc::ServerContext* /*context*/, const ::nakama::api::DeleteNotificationsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteNotifications(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::DeleteNotificationsRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteStorageObjects : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteStorageObjects() {
      ::grpc::Service::MarkMethodStreamed(20,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::DeleteStorageObjectsRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::DeleteStorageObjectsRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedDeleteStorageObjects(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DeleteStorageObjects() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteStorageObjects(::grpc::ServerContext* /*context*/, const ::nakama::api::DeleteStorageObjectsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteStorageObjects(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::DeleteStorageObjectsRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Event : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Event() {
      ::grpc::Service::MarkMethodStreamed(21,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::Event, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::Event, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedEvent(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Event() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Event(::grpc::ServerContext* /*context*/, const ::nakama::api::Event* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedEvent(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::Event,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetAccount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetAccount() {
      ::grpc::Service::MarkMethodStreamed(22,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::nakama::api::Account>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::nakama::api::Account>* streamer) {
                       return this->StreamedGetAccount(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetAccount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetAccount(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::nakama::api::Account* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetAccount(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::nakama::api::Account>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetUsers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetUsers() {
      ::grpc::Service::MarkMethodStreamed(23,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::GetUsersRequest, ::nakama::api::Users>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::GetUsersRequest, ::nakama::api::Users>* streamer) {
                       return this->StreamedGetUsers(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetUsers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetUsers(::grpc::ServerContext* /*context*/, const ::nakama::api::GetUsersRequest* /*request*/, ::nakama::api::Users* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetUsers(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::GetUsersRequest,::nakama::api::Users>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Healthcheck : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Healthcheck() {
      ::grpc::Service::MarkMethodStreamed(24,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedHealthcheck(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Healthcheck() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Healthcheck(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedHealthcheck(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ImportFacebookFriends : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ImportFacebookFriends() {
      ::grpc::Service::MarkMethodStreamed(25,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::ImportFacebookFriendsRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::ImportFacebookFriendsRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedImportFacebookFriends(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ImportFacebookFriends() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ImportFacebookFriends(::grpc::ServerContext* /*context*/, const ::nakama::api::ImportFacebookFriendsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedImportFacebookFriends(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::ImportFacebookFriendsRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ImportSteamFriends : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ImportSteamFriends() {
      ::grpc::Service::MarkMethodStreamed(26,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::ImportSteamFriendsRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::ImportSteamFriendsRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedImportSteamFriends(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ImportSteamFriends() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ImportSteamFriends(::grpc::ServerContext* /*context*/, const ::nakama::api::ImportSteamFriendsRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedImportSteamFriends(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::ImportSteamFriendsRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_JoinGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_JoinGroup() {
      ::grpc::Service::MarkMethodStreamed(27,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::JoinGroupRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::JoinGroupRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedJoinGroup(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_JoinGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status JoinGroup(::grpc::ServerContext* /*context*/, const ::nakama::api::JoinGroupRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedJoinGroup(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::JoinGroupRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_JoinTournament : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_JoinTournament() {
      ::grpc::Service::MarkMethodStreamed(28,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::JoinTournamentRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::JoinTournamentRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedJoinTournament(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_JoinTournament() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status JoinTournament(::grpc::ServerContext* /*context*/, const ::nakama::api::JoinTournamentRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedJoinTournament(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::JoinTournamentRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_KickGroupUsers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_KickGroupUsers() {
      ::grpc::Service::MarkMethodStreamed(29,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::KickGroupUsersRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::KickGroupUsersRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedKickGroupUsers(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_KickGroupUsers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status KickGroupUsers(::grpc::ServerContext* /*context*/, const ::nakama::api::KickGroupUsersRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedKickGroupUsers(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::KickGroupUsersRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_LeaveGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_LeaveGroup() {
      ::grpc::Service::MarkMethodStreamed(30,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::LeaveGroupRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::LeaveGroupRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedLeaveGroup(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_LeaveGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status LeaveGroup(::grpc::ServerContext* /*context*/, const ::nakama::api::LeaveGroupRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLeaveGroup(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::LeaveGroupRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_LinkApple : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_LinkApple() {
      ::grpc::Service::MarkMethodStreamed(31,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::AccountApple, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::AccountApple, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedLinkApple(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_LinkApple() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status LinkApple(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountApple* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLinkApple(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::AccountApple,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_LinkCustom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_LinkCustom() {
      ::grpc::Service::MarkMethodStreamed(32,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::AccountCustom, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::AccountCustom, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedLinkCustom(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_LinkCustom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status LinkCustom(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountCustom* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLinkCustom(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::AccountCustom,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_LinkDevice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_LinkDevice() {
      ::grpc::Service::MarkMethodStreamed(33,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::AccountDevice, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::AccountDevice, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedLinkDevice(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_LinkDevice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status LinkDevice(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountDevice* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLinkDevice(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::AccountDevice,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_LinkEmail : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_LinkEmail() {
      ::grpc::Service::MarkMethodStreamed(34,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::AccountEmail, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::AccountEmail, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedLinkEmail(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_LinkEmail() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status LinkEmail(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountEmail* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLinkEmail(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::AccountEmail,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_LinkFacebook : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_LinkFacebook() {
      ::grpc::Service::MarkMethodStreamed(35,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::LinkFacebookRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::LinkFacebookRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedLinkFacebook(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_LinkFacebook() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status LinkFacebook(::grpc::ServerContext* /*context*/, const ::nakama::api::LinkFacebookRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLinkFacebook(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::LinkFacebookRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_LinkFacebookInstantGame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_LinkFacebookInstantGame() {
      ::grpc::Service::MarkMethodStreamed(36,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::AccountFacebookInstantGame, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::AccountFacebookInstantGame, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedLinkFacebookInstantGame(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_LinkFacebookInstantGame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status LinkFacebookInstantGame(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountFacebookInstantGame* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLinkFacebookInstantGame(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::AccountFacebookInstantGame,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_LinkGameCenter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_LinkGameCenter() {
      ::grpc::Service::MarkMethodStreamed(37,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::AccountGameCenter, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::AccountGameCenter, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedLinkGameCenter(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_LinkGameCenter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status LinkGameCenter(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountGameCenter* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLinkGameCenter(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::AccountGameCenter,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_LinkGoogle : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_LinkGoogle() {
      ::grpc::Service::MarkMethodStreamed(38,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::AccountGoogle, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::AccountGoogle, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedLinkGoogle(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_LinkGoogle() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status LinkGoogle(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountGoogle* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLinkGoogle(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::AccountGoogle,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_LinkSteam : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_LinkSteam() {
      ::grpc::Service::MarkMethodStreamed(39,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::LinkSteamRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::LinkSteamRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedLinkSteam(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_LinkSteam() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status LinkSteam(::grpc::ServerContext* /*context*/, const ::nakama::api::LinkSteamRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLinkSteam(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::LinkSteamRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListChannelMessages : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListChannelMessages() {
      ::grpc::Service::MarkMethodStreamed(40,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::ListChannelMessagesRequest, ::nakama::api::ChannelMessageList>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::ListChannelMessagesRequest, ::nakama::api::ChannelMessageList>* streamer) {
                       return this->StreamedListChannelMessages(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListChannelMessages() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListChannelMessages(::grpc::ServerContext* /*context*/, const ::nakama::api::ListChannelMessagesRequest* /*request*/, ::nakama::api::ChannelMessageList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListChannelMessages(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::ListChannelMessagesRequest,::nakama::api::ChannelMessageList>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListFriends : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListFriends() {
      ::grpc::Service::MarkMethodStreamed(41,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::ListFriendsRequest, ::nakama::api::FriendList>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::ListFriendsRequest, ::nakama::api::FriendList>* streamer) {
                       return this->StreamedListFriends(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListFriends() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListFriends(::grpc::ServerContext* /*context*/, const ::nakama::api::ListFriendsRequest* /*request*/, ::nakama::api::FriendList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListFriends(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::ListFriendsRequest,::nakama::api::FriendList>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListGroups : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListGroups() {
      ::grpc::Service::MarkMethodStreamed(42,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::ListGroupsRequest, ::nakama::api::GroupList>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::ListGroupsRequest, ::nakama::api::GroupList>* streamer) {
                       return this->StreamedListGroups(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListGroups() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListGroups(::grpc::ServerContext* /*context*/, const ::nakama::api::ListGroupsRequest* /*request*/, ::nakama::api::GroupList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListGroups(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::ListGroupsRequest,::nakama::api::GroupList>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListGroupUsers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListGroupUsers() {
      ::grpc::Service::MarkMethodStreamed(43,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::ListGroupUsersRequest, ::nakama::api::GroupUserList>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::ListGroupUsersRequest, ::nakama::api::GroupUserList>* streamer) {
                       return this->StreamedListGroupUsers(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListGroupUsers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListGroupUsers(::grpc::ServerContext* /*context*/, const ::nakama::api::ListGroupUsersRequest* /*request*/, ::nakama::api::GroupUserList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListGroupUsers(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::ListGroupUsersRequest,::nakama::api::GroupUserList>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListLeaderboardRecords : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListLeaderboardRecords() {
      ::grpc::Service::MarkMethodStreamed(44,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::ListLeaderboardRecordsRequest, ::nakama::api::LeaderboardRecordList>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::ListLeaderboardRecordsRequest, ::nakama::api::LeaderboardRecordList>* streamer) {
                       return this->StreamedListLeaderboardRecords(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListLeaderboardRecords() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListLeaderboardRecords(::grpc::ServerContext* /*context*/, const ::nakama::api::ListLeaderboardRecordsRequest* /*request*/, ::nakama::api::LeaderboardRecordList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListLeaderboardRecords(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::ListLeaderboardRecordsRequest,::nakama::api::LeaderboardRecordList>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListLeaderboardRecordsAroundOwner : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListLeaderboardRecordsAroundOwner() {
      ::grpc::Service::MarkMethodStreamed(45,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::ListLeaderboardRecordsAroundOwnerRequest, ::nakama::api::LeaderboardRecordList>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::ListLeaderboardRecordsAroundOwnerRequest, ::nakama::api::LeaderboardRecordList>* streamer) {
                       return this->StreamedListLeaderboardRecordsAroundOwner(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListLeaderboardRecordsAroundOwner() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListLeaderboardRecordsAroundOwner(::grpc::ServerContext* /*context*/, const ::nakama::api::ListLeaderboardRecordsAroundOwnerRequest* /*request*/, ::nakama::api::LeaderboardRecordList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListLeaderboardRecordsAroundOwner(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::ListLeaderboardRecordsAroundOwnerRequest,::nakama::api::LeaderboardRecordList>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListMatches : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListMatches() {
      ::grpc::Service::MarkMethodStreamed(46,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::ListMatchesRequest, ::nakama::api::MatchList>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::ListMatchesRequest, ::nakama::api::MatchList>* streamer) {
                       return this->StreamedListMatches(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListMatches() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListMatches(::grpc::ServerContext* /*context*/, const ::nakama::api::ListMatchesRequest* /*request*/, ::nakama::api::MatchList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListMatches(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::ListMatchesRequest,::nakama::api::MatchList>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListNotifications : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListNotifications() {
      ::grpc::Service::MarkMethodStreamed(47,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::ListNotificationsRequest, ::nakama::api::NotificationList>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::ListNotificationsRequest, ::nakama::api::NotificationList>* streamer) {
                       return this->StreamedListNotifications(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListNotifications() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListNotifications(::grpc::ServerContext* /*context*/, const ::nakama::api::ListNotificationsRequest* /*request*/, ::nakama::api::NotificationList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListNotifications(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::ListNotificationsRequest,::nakama::api::NotificationList>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListStorageObjects : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListStorageObjects() {
      ::grpc::Service::MarkMethodStreamed(48,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::ListStorageObjectsRequest, ::nakama::api::StorageObjectList>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::ListStorageObjectsRequest, ::nakama::api::StorageObjectList>* streamer) {
                       return this->StreamedListStorageObjects(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListStorageObjects() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListStorageObjects(::grpc::ServerContext* /*context*/, const ::nakama::api::ListStorageObjectsRequest* /*request*/, ::nakama::api::StorageObjectList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListStorageObjects(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::ListStorageObjectsRequest,::nakama::api::StorageObjectList>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListTournaments : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListTournaments() {
      ::grpc::Service::MarkMethodStreamed(49,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::ListTournamentsRequest, ::nakama::api::TournamentList>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::ListTournamentsRequest, ::nakama::api::TournamentList>* streamer) {
                       return this->StreamedListTournaments(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListTournaments() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListTournaments(::grpc::ServerContext* /*context*/, const ::nakama::api::ListTournamentsRequest* /*request*/, ::nakama::api::TournamentList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListTournaments(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::ListTournamentsRequest,::nakama::api::TournamentList>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListTournamentRecords : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListTournamentRecords() {
      ::grpc::Service::MarkMethodStreamed(50,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::ListTournamentRecordsRequest, ::nakama::api::TournamentRecordList>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::ListTournamentRecordsRequest, ::nakama::api::TournamentRecordList>* streamer) {
                       return this->StreamedListTournamentRecords(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListTournamentRecords() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListTournamentRecords(::grpc::ServerContext* /*context*/, const ::nakama::api::ListTournamentRecordsRequest* /*request*/, ::nakama::api::TournamentRecordList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListTournamentRecords(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::ListTournamentRecordsRequest,::nakama::api::TournamentRecordList>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListTournamentRecordsAroundOwner : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListTournamentRecordsAroundOwner() {
      ::grpc::Service::MarkMethodStreamed(51,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::ListTournamentRecordsAroundOwnerRequest, ::nakama::api::TournamentRecordList>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::ListTournamentRecordsAroundOwnerRequest, ::nakama::api::TournamentRecordList>* streamer) {
                       return this->StreamedListTournamentRecordsAroundOwner(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListTournamentRecordsAroundOwner() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListTournamentRecordsAroundOwner(::grpc::ServerContext* /*context*/, const ::nakama::api::ListTournamentRecordsAroundOwnerRequest* /*request*/, ::nakama::api::TournamentRecordList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListTournamentRecordsAroundOwner(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::ListTournamentRecordsAroundOwnerRequest,::nakama::api::TournamentRecordList>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListUserGroups : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListUserGroups() {
      ::grpc::Service::MarkMethodStreamed(52,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::ListUserGroupsRequest, ::nakama::api::UserGroupList>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::ListUserGroupsRequest, ::nakama::api::UserGroupList>* streamer) {
                       return this->StreamedListUserGroups(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListUserGroups() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListUserGroups(::grpc::ServerContext* /*context*/, const ::nakama::api::ListUserGroupsRequest* /*request*/, ::nakama::api::UserGroupList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListUserGroups(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::ListUserGroupsRequest,::nakama::api::UserGroupList>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PromoteGroupUsers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PromoteGroupUsers() {
      ::grpc::Service::MarkMethodStreamed(53,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::PromoteGroupUsersRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::PromoteGroupUsersRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedPromoteGroupUsers(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PromoteGroupUsers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PromoteGroupUsers(::grpc::ServerContext* /*context*/, const ::nakama::api::PromoteGroupUsersRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPromoteGroupUsers(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::PromoteGroupUsersRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DemoteGroupUsers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DemoteGroupUsers() {
      ::grpc::Service::MarkMethodStreamed(54,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::DemoteGroupUsersRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::DemoteGroupUsersRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedDemoteGroupUsers(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DemoteGroupUsers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DemoteGroupUsers(::grpc::ServerContext* /*context*/, const ::nakama::api::DemoteGroupUsersRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDemoteGroupUsers(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::DemoteGroupUsersRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ReadStorageObjects : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ReadStorageObjects() {
      ::grpc::Service::MarkMethodStreamed(55,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::ReadStorageObjectsRequest, ::nakama::api::StorageObjects>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::ReadStorageObjectsRequest, ::nakama::api::StorageObjects>* streamer) {
                       return this->StreamedReadStorageObjects(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ReadStorageObjects() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ReadStorageObjects(::grpc::ServerContext* /*context*/, const ::nakama::api::ReadStorageObjectsRequest* /*request*/, ::nakama::api::StorageObjects* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedReadStorageObjects(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::ReadStorageObjectsRequest,::nakama::api::StorageObjects>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RpcFunc : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RpcFunc() {
      ::grpc::Service::MarkMethodStreamed(56,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::Rpc, ::nakama::api::Rpc>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::Rpc, ::nakama::api::Rpc>* streamer) {
                       return this->StreamedRpcFunc(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RpcFunc() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RpcFunc(::grpc::ServerContext* /*context*/, const ::nakama::api::Rpc* /*request*/, ::nakama::api::Rpc* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRpcFunc(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::Rpc,::nakama::api::Rpc>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UnlinkApple : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UnlinkApple() {
      ::grpc::Service::MarkMethodStreamed(57,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::AccountApple, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::AccountApple, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedUnlinkApple(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UnlinkApple() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UnlinkApple(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountApple* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUnlinkApple(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::AccountApple,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UnlinkCustom : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UnlinkCustom() {
      ::grpc::Service::MarkMethodStreamed(58,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::AccountCustom, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::AccountCustom, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedUnlinkCustom(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UnlinkCustom() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UnlinkCustom(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountCustom* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUnlinkCustom(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::AccountCustom,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UnlinkDevice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UnlinkDevice() {
      ::grpc::Service::MarkMethodStreamed(59,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::AccountDevice, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::AccountDevice, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedUnlinkDevice(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UnlinkDevice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UnlinkDevice(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountDevice* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUnlinkDevice(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::AccountDevice,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UnlinkEmail : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UnlinkEmail() {
      ::grpc::Service::MarkMethodStreamed(60,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::AccountEmail, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::AccountEmail, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedUnlinkEmail(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UnlinkEmail() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UnlinkEmail(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountEmail* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUnlinkEmail(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::AccountEmail,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UnlinkFacebook : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UnlinkFacebook() {
      ::grpc::Service::MarkMethodStreamed(61,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::AccountFacebook, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::AccountFacebook, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedUnlinkFacebook(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UnlinkFacebook() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UnlinkFacebook(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountFacebook* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUnlinkFacebook(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::AccountFacebook,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UnlinkFacebookInstantGame : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UnlinkFacebookInstantGame() {
      ::grpc::Service::MarkMethodStreamed(62,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::AccountFacebookInstantGame, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::AccountFacebookInstantGame, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedUnlinkFacebookInstantGame(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UnlinkFacebookInstantGame() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UnlinkFacebookInstantGame(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountFacebookInstantGame* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUnlinkFacebookInstantGame(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::AccountFacebookInstantGame,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UnlinkGameCenter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UnlinkGameCenter() {
      ::grpc::Service::MarkMethodStreamed(63,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::AccountGameCenter, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::AccountGameCenter, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedUnlinkGameCenter(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UnlinkGameCenter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UnlinkGameCenter(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountGameCenter* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUnlinkGameCenter(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::AccountGameCenter,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UnlinkGoogle : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UnlinkGoogle() {
      ::grpc::Service::MarkMethodStreamed(64,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::AccountGoogle, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::AccountGoogle, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedUnlinkGoogle(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UnlinkGoogle() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UnlinkGoogle(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountGoogle* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUnlinkGoogle(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::AccountGoogle,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UnlinkSteam : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UnlinkSteam() {
      ::grpc::Service::MarkMethodStreamed(65,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::AccountSteam, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::AccountSteam, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedUnlinkSteam(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UnlinkSteam() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UnlinkSteam(::grpc::ServerContext* /*context*/, const ::nakama::api::AccountSteam* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUnlinkSteam(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::AccountSteam,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UpdateAccount : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UpdateAccount() {
      ::grpc::Service::MarkMethodStreamed(66,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::UpdateAccountRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::UpdateAccountRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedUpdateAccount(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UpdateAccount() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UpdateAccount(::grpc::ServerContext* /*context*/, const ::nakama::api::UpdateAccountRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUpdateAccount(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::UpdateAccountRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UpdateGroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UpdateGroup() {
      ::grpc::Service::MarkMethodStreamed(67,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::UpdateGroupRequest, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::UpdateGroupRequest, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedUpdateGroup(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UpdateGroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UpdateGroup(::grpc::ServerContext* /*context*/, const ::nakama::api::UpdateGroupRequest* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUpdateGroup(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::UpdateGroupRequest,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ValidatePurchaseApple : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ValidatePurchaseApple() {
      ::grpc::Service::MarkMethodStreamed(68,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::ValidatePurchaseAppleRequest, ::nakama::api::ValidatePurchaseResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::ValidatePurchaseAppleRequest, ::nakama::api::ValidatePurchaseResponse>* streamer) {
                       return this->StreamedValidatePurchaseApple(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ValidatePurchaseApple() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ValidatePurchaseApple(::grpc::ServerContext* /*context*/, const ::nakama::api::ValidatePurchaseAppleRequest* /*request*/, ::nakama::api::ValidatePurchaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedValidatePurchaseApple(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::ValidatePurchaseAppleRequest,::nakama::api::ValidatePurchaseResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ValidatePurchaseGoogle : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ValidatePurchaseGoogle() {
      ::grpc::Service::MarkMethodStreamed(69,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::ValidatePurchaseGoogleRequest, ::nakama::api::ValidatePurchaseResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::ValidatePurchaseGoogleRequest, ::nakama::api::ValidatePurchaseResponse>* streamer) {
                       return this->StreamedValidatePurchaseGoogle(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ValidatePurchaseGoogle() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ValidatePurchaseGoogle(::grpc::ServerContext* /*context*/, const ::nakama::api::ValidatePurchaseGoogleRequest* /*request*/, ::nakama::api::ValidatePurchaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedValidatePurchaseGoogle(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::ValidatePurchaseGoogleRequest,::nakama::api::ValidatePurchaseResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ValidatePurchaseHuawei : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ValidatePurchaseHuawei() {
      ::grpc::Service::MarkMethodStreamed(70,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::ValidatePurchaseHuaweiRequest, ::nakama::api::ValidatePurchaseResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::ValidatePurchaseHuaweiRequest, ::nakama::api::ValidatePurchaseResponse>* streamer) {
                       return this->StreamedValidatePurchaseHuawei(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ValidatePurchaseHuawei() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ValidatePurchaseHuawei(::grpc::ServerContext* /*context*/, const ::nakama::api::ValidatePurchaseHuaweiRequest* /*request*/, ::nakama::api::ValidatePurchaseResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedValidatePurchaseHuawei(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::ValidatePurchaseHuaweiRequest,::nakama::api::ValidatePurchaseResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_WriteLeaderboardRecord : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_WriteLeaderboardRecord() {
      ::grpc::Service::MarkMethodStreamed(71,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::WriteLeaderboardRecordRequest, ::nakama::api::LeaderboardRecord>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::WriteLeaderboardRecordRequest, ::nakama::api::LeaderboardRecord>* streamer) {
                       return this->StreamedWriteLeaderboardRecord(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_WriteLeaderboardRecord() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status WriteLeaderboardRecord(::grpc::ServerContext* /*context*/, const ::nakama::api::WriteLeaderboardRecordRequest* /*request*/, ::nakama::api::LeaderboardRecord* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedWriteLeaderboardRecord(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::WriteLeaderboardRecordRequest,::nakama::api::LeaderboardRecord>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_WriteStorageObjects : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_WriteStorageObjects() {
      ::grpc::Service::MarkMethodStreamed(72,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::WriteStorageObjectsRequest, ::nakama::api::StorageObjectAcks>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::WriteStorageObjectsRequest, ::nakama::api::StorageObjectAcks>* streamer) {
                       return this->StreamedWriteStorageObjects(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_WriteStorageObjects() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status WriteStorageObjects(::grpc::ServerContext* /*context*/, const ::nakama::api::WriteStorageObjectsRequest* /*request*/, ::nakama::api::StorageObjectAcks* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedWriteStorageObjects(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::WriteStorageObjectsRequest,::nakama::api::StorageObjectAcks>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_WriteTournamentRecord : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_WriteTournamentRecord() {
      ::grpc::Service::MarkMethodStreamed(73,
        new ::grpc::internal::StreamedUnaryHandler<
          ::nakama::api::WriteTournamentRecordRequest, ::nakama::api::LeaderboardRecord>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::nakama::api::WriteTournamentRecordRequest, ::nakama::api::LeaderboardRecord>* streamer) {
                       return this->StreamedWriteTournamentRecord(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_WriteTournamentRecord() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status WriteTournamentRecord(::grpc::ServerContext* /*context*/, const ::nakama::api::WriteTournamentRecordRequest* /*request*/, ::nakama::api::LeaderboardRecord* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedWriteTournamentRecord(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::nakama::api::WriteTournamentRecordRequest,::nakama::api::LeaderboardRecord>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_AddFriends<WithStreamedUnaryMethod_AddGroupUsers<WithStreamedUnaryMethod_SessionRefresh<WithStreamedUnaryMethod_SessionLogout<WithStreamedUnaryMethod_AuthenticateApple<WithStreamedUnaryMethod_AuthenticateCustom<WithStreamedUnaryMethod_AuthenticateDevice<WithStreamedUnaryMethod_AuthenticateEmail<WithStreamedUnaryMethod_AuthenticateFacebook<WithStreamedUnaryMethod_AuthenticateFacebookInstantGame<WithStreamedUnaryMethod_AuthenticateGameCenter<WithStreamedUnaryMethod_AuthenticateGoogle<WithStreamedUnaryMethod_AuthenticateSteam<WithStreamedUnaryMethod_BanGroupUsers<WithStreamedUnaryMethod_BlockFriends<WithStreamedUnaryMethod_CreateGroup<WithStreamedUnaryMethod_DeleteFriends<WithStreamedUnaryMethod_DeleteGroup<WithStreamedUnaryMethod_DeleteLeaderboardRecord<WithStreamedUnaryMethod_DeleteNotifications<WithStreamedUnaryMethod_DeleteStorageObjects<WithStreamedUnaryMethod_Event<WithStreamedUnaryMethod_GetAccount<WithStreamedUnaryMethod_GetUsers<WithStreamedUnaryMethod_Healthcheck<WithStreamedUnaryMethod_ImportFacebookFriends<WithStreamedUnaryMethod_ImportSteamFriends<WithStreamedUnaryMethod_JoinGroup<WithStreamedUnaryMethod_JoinTournament<WithStreamedUnaryMethod_KickGroupUsers<WithStreamedUnaryMethod_LeaveGroup<WithStreamedUnaryMethod_LinkApple<WithStreamedUnaryMethod_LinkCustom<WithStreamedUnaryMethod_LinkDevice<WithStreamedUnaryMethod_LinkEmail<WithStreamedUnaryMethod_LinkFacebook<WithStreamedUnaryMethod_LinkFacebookInstantGame<WithStreamedUnaryMethod_LinkGameCenter<WithStreamedUnaryMethod_LinkGoogle<WithStreamedUnaryMethod_LinkSteam<WithStreamedUnaryMethod_ListChannelMessages<WithStreamedUnaryMethod_ListFriends<WithStreamedUnaryMethod_ListGroups<WithStreamedUnaryMethod_ListGroupUsers<WithStreamedUnaryMethod_ListLeaderboardRecords<WithStreamedUnaryMethod_ListLeaderboardRecordsAroundOwner<WithStreamedUnaryMethod_ListMatches<WithStreamedUnaryMethod_ListNotifications<WithStreamedUnaryMethod_ListStorageObjects<WithStreamedUnaryMethod_ListTournaments<WithStreamedUnaryMethod_ListTournamentRecords<WithStreamedUnaryMethod_ListTournamentRecordsAroundOwner<WithStreamedUnaryMethod_ListUserGroups<WithStreamedUnaryMethod_PromoteGroupUsers<WithStreamedUnaryMethod_DemoteGroupUsers<WithStreamedUnaryMethod_ReadStorageObjects<WithStreamedUnaryMethod_RpcFunc<WithStreamedUnaryMethod_UnlinkApple<WithStreamedUnaryMethod_UnlinkCustom<WithStreamedUnaryMethod_UnlinkDevice<WithStreamedUnaryMethod_UnlinkEmail<WithStreamedUnaryMethod_UnlinkFacebook<WithStreamedUnaryMethod_UnlinkFacebookInstantGame<WithStreamedUnaryMethod_UnlinkGameCenter<WithStreamedUnaryMethod_UnlinkGoogle<WithStreamedUnaryMethod_UnlinkSteam<WithStreamedUnaryMethod_UpdateAccount<WithStreamedUnaryMethod_UpdateGroup<WithStreamedUnaryMethod_ValidatePurchaseApple<WithStreamedUnaryMethod_ValidatePurchaseGoogle<WithStreamedUnaryMethod_ValidatePurchaseHuawei<WithStreamedUnaryMethod_WriteLeaderboardRecord<WithStreamedUnaryMethod_WriteStorageObjects<WithStreamedUnaryMethod_WriteTournamentRecord<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_AddFriends<WithStreamedUnaryMethod_AddGroupUsers<WithStreamedUnaryMethod_SessionRefresh<WithStreamedUnaryMethod_SessionLogout<WithStreamedUnaryMethod_AuthenticateApple<WithStreamedUnaryMethod_AuthenticateCustom<WithStreamedUnaryMethod_AuthenticateDevice<WithStreamedUnaryMethod_AuthenticateEmail<WithStreamedUnaryMethod_AuthenticateFacebook<WithStreamedUnaryMethod_AuthenticateFacebookInstantGame<WithStreamedUnaryMethod_AuthenticateGameCenter<WithStreamedUnaryMethod_AuthenticateGoogle<WithStreamedUnaryMethod_AuthenticateSteam<WithStreamedUnaryMethod_BanGroupUsers<WithStreamedUnaryMethod_BlockFriends<WithStreamedUnaryMethod_CreateGroup<WithStreamedUnaryMethod_DeleteFriends<WithStreamedUnaryMethod_DeleteGroup<WithStreamedUnaryMethod_DeleteLeaderboardRecord<WithStreamedUnaryMethod_DeleteNotifications<WithStreamedUnaryMethod_DeleteStorageObjects<WithStreamedUnaryMethod_Event<WithStreamedUnaryMethod_GetAccount<WithStreamedUnaryMethod_GetUsers<WithStreamedUnaryMethod_Healthcheck<WithStreamedUnaryMethod_ImportFacebookFriends<WithStreamedUnaryMethod_ImportSteamFriends<WithStreamedUnaryMethod_JoinGroup<WithStreamedUnaryMethod_JoinTournament<WithStreamedUnaryMethod_KickGroupUsers<WithStreamedUnaryMethod_LeaveGroup<WithStreamedUnaryMethod_LinkApple<WithStreamedUnaryMethod_LinkCustom<WithStreamedUnaryMethod_LinkDevice<WithStreamedUnaryMethod_LinkEmail<WithStreamedUnaryMethod_LinkFacebook<WithStreamedUnaryMethod_LinkFacebookInstantGame<WithStreamedUnaryMethod_LinkGameCenter<WithStreamedUnaryMethod_LinkGoogle<WithStreamedUnaryMethod_LinkSteam<WithStreamedUnaryMethod_ListChannelMessages<WithStreamedUnaryMethod_ListFriends<WithStreamedUnaryMethod_ListGroups<WithStreamedUnaryMethod_ListGroupUsers<WithStreamedUnaryMethod_ListLeaderboardRecords<WithStreamedUnaryMethod_ListLeaderboardRecordsAroundOwner<WithStreamedUnaryMethod_ListMatches<WithStreamedUnaryMethod_ListNotifications<WithStreamedUnaryMethod_ListStorageObjects<WithStreamedUnaryMethod_ListTournaments<WithStreamedUnaryMethod_ListTournamentRecords<WithStreamedUnaryMethod_ListTournamentRecordsAroundOwner<WithStreamedUnaryMethod_ListUserGroups<WithStreamedUnaryMethod_PromoteGroupUsers<WithStreamedUnaryMethod_DemoteGroupUsers<WithStreamedUnaryMethod_ReadStorageObjects<WithStreamedUnaryMethod_RpcFunc<WithStreamedUnaryMethod_UnlinkApple<WithStreamedUnaryMethod_UnlinkCustom<WithStreamedUnaryMethod_UnlinkDevice<WithStreamedUnaryMethod_UnlinkEmail<WithStreamedUnaryMethod_UnlinkFacebook<WithStreamedUnaryMethod_UnlinkFacebookInstantGame<WithStreamedUnaryMethod_UnlinkGameCenter<WithStreamedUnaryMethod_UnlinkGoogle<WithStreamedUnaryMethod_UnlinkSteam<WithStreamedUnaryMethod_UpdateAccount<WithStreamedUnaryMethod_UpdateGroup<WithStreamedUnaryMethod_ValidatePurchaseApple<WithStreamedUnaryMethod_ValidatePurchaseGoogle<WithStreamedUnaryMethod_ValidatePurchaseHuawei<WithStreamedUnaryMethod_WriteLeaderboardRecord<WithStreamedUnaryMethod_WriteStorageObjects<WithStreamedUnaryMethod_WriteTournamentRecord<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > StreamedService;
};

}  // namespace api
}  // namespace nakama


#endif  // GRPC_github_2ecom_2fheroiclabs_2fnakama_2fapigrpc_2fapigrpc_2eproto__INCLUDED
